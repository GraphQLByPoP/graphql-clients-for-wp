{"version":3,"file":"static/js/58.83abfe0f.chunk.js","mappings":"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","sources":["../node_modules/monaco-editor/esm/vs/base/common/equals.js","../node_modules/monaco-editor/esm/vs/base/common/observableInternal/lazyObservableValue.js","../node_modules/monaco-editor/esm/vs/base/common/observableInternal/api.js","../node_modules/monaco-editor/esm/vs/base/common/observableInternal/autorun.js","../node_modules/monaco-editor/esm/vs/base/common/observableInternal/base.js","../node_modules/monaco-editor/esm/vs/base/common/observableInternal/debugName.js","../node_modules/monaco-editor/esm/vs/base/common/observableInternal/derived.js","../node_modules/monaco-editor/esm/vs/base/common/observableInternal/promise.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from './arrays.js';\n/**\n * Compares two items for equality using strict equality.\n*/\nexport const strictEquals = (a, b) => a === b;\n/**\n * Checks if the items of two arrays are equal.\n * By default, strict equality is used to compare elements, but a custom equality comparer can be provided.\n */\nexport function itemsEquals(itemEquals = strictEquals) {\n    return (a, b) => arrays.equals(a, b, itemEquals);\n}\n/**\n * Uses `item.equals(other)` to determine equality.\n */\nexport function itemEquals() {\n    return (a, b) => a.equals(b);\n}\nexport function equalsIfDefined(equalsOrV1, v2, equals) {\n    if (equals !== undefined) {\n        const v1 = equalsOrV1;\n        if (v1 === undefined || v1 === null || v2 === undefined || v2 === null) {\n            return v2 === v1;\n        }\n        return equals(v1, v2);\n    }\n    else {\n        const equals = equalsOrV1;\n        return (v1, v2) => {\n            if (v1 === undefined || v1 === null || v2 === undefined || v2 === null) {\n                return v2 === v1;\n            }\n            return equals(v1, v2);\n        };\n    }\n}\n/**\n * Drills into arrays (items ordered) and objects (keys unordered) and uses strict equality on everything else.\n*/\nexport function structuralEquals(a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (Array.isArray(a) && Array.isArray(b)) {\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (let i = 0; i < a.length; i++) {\n            if (!structuralEquals(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    if (a && typeof a === 'object' && b && typeof b === 'object') {\n        if (Object.getPrototypeOf(a) === Object.prototype && Object.getPrototypeOf(b) === Object.prototype) {\n            const aObj = a;\n            const bObj = b;\n            const keysA = Object.keys(aObj);\n            const keysB = Object.keys(bObj);\n            const keysBSet = new Set(keysB);\n            if (keysA.length !== keysB.length) {\n                return false;\n            }\n            for (const key of keysA) {\n                if (!keysBSet.has(key)) {\n                    return false;\n                }\n                if (!structuralEquals(aObj[key], bObj[key])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    return false;\n}\nconst objIds = new WeakMap();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BaseObservable, TransactionImpl } from './base.js';\n/**\n * Holds off updating observers until the value is actually read.\n*/\nexport class LazyObservableValue extends BaseObservable {\n    get debugName() {\n        return this._debugNameData.getDebugName(this) ?? 'LazyObservableValue';\n    }\n    constructor(_debugNameData, initialValue, _equalityComparator) {\n        super();\n        this._debugNameData = _debugNameData;\n        this._equalityComparator = _equalityComparator;\n        this._isUpToDate = true;\n        this._deltas = [];\n        this._updateCounter = 0;\n        this._value = initialValue;\n    }\n    get() {\n        this._update();\n        return this._value;\n    }\n    _update() {\n        if (this._isUpToDate) {\n            return;\n        }\n        this._isUpToDate = true;\n        if (this._deltas.length > 0) {\n            for (const observer of this.observers) {\n                for (const change of this._deltas) {\n                    observer.handleChange(this, change);\n                }\n            }\n            this._deltas.length = 0;\n        }\n        else {\n            for (const observer of this.observers) {\n                observer.handleChange(this, undefined);\n            }\n        }\n    }\n    _beginUpdate() {\n        this._updateCounter++;\n        if (this._updateCounter === 1) {\n            for (const observer of this.observers) {\n                observer.beginUpdate(this);\n            }\n        }\n    }\n    _endUpdate() {\n        this._updateCounter--;\n        if (this._updateCounter === 0) {\n            this._update();\n            // End update could change the observer list.\n            const observers = [...this.observers];\n            for (const r of observers) {\n                r.endUpdate(this);\n            }\n        }\n    }\n    addObserver(observer) {\n        const shouldCallBeginUpdate = !this.observers.has(observer) && this._updateCounter > 0;\n        super.addObserver(observer);\n        if (shouldCallBeginUpdate) {\n            observer.beginUpdate(this);\n        }\n    }\n    removeObserver(observer) {\n        const shouldCallEndUpdate = this.observers.has(observer) && this._updateCounter > 0;\n        super.removeObserver(observer);\n        if (shouldCallEndUpdate) {\n            // Calling end update after removing the observer makes sure endUpdate cannot be called twice here.\n            observer.endUpdate(this);\n        }\n    }\n    set(value, tx, change) {\n        if (change === undefined && this._equalityComparator(this._value, value)) {\n            return;\n        }\n        let _tx;\n        if (!tx) {\n            tx = _tx = new TransactionImpl(() => { }, () => `Setting ${this.debugName}`);\n        }\n        try {\n            this._isUpToDate = false;\n            this._setValue(value);\n            if (change !== undefined) {\n                this._deltas.push(change);\n            }\n            tx.updateObserver({\n                beginUpdate: () => this._beginUpdate(),\n                endUpdate: () => this._endUpdate(),\n                handleChange: (observable, change) => { },\n                handlePossibleChange: (observable) => { },\n            }, this);\n            if (this._updateCounter > 1) {\n                // We already started begin/end update, so we need to manually call handlePossibleChange\n                for (const observer of this.observers) {\n                    observer.handlePossibleChange(this);\n                }\n            }\n        }\n        finally {\n            if (_tx) {\n                _tx.finish();\n            }\n        }\n    }\n    toString() {\n        return `${this.debugName}: ${this._value}`;\n    }\n    _setValue(newValue) {\n        this._value = newValue;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { strictEquals } from '../equals.js';\nimport { ObservableValue } from './base.js';\nimport { DebugNameData } from './debugName.js';\nimport { LazyObservableValue } from './lazyObservableValue.js';\nexport function observableValueOpts(options, initialValue) {\n    if (options.lazy) {\n        return new LazyObservableValue(new DebugNameData(options.owner, options.debugName, undefined), initialValue, options.equalsFn ?? strictEquals);\n    }\n    return new ObservableValue(new DebugNameData(options.owner, options.debugName, undefined), initialValue, options.equalsFn ?? strictEquals);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertFn } from '../assert.js';\nimport { DisposableStore, markAsDisposed, toDisposable, trackDisposable } from '../lifecycle.js';\nimport { DebugNameData } from './debugName.js';\nimport { getLogger } from './logging.js';\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n */\nexport function autorun(fn) {\n    return new AutorunObserver(new DebugNameData(undefined, undefined, fn), fn, undefined, undefined);\n}\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n */\nexport function autorunOpts(options, fn) {\n    return new AutorunObserver(new DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? fn), fn, undefined, undefined);\n}\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n *\n * Use `createEmptyChangeSummary` to create a \"change summary\" that can collect the changes.\n * Use `handleChange` to add a reported change to the change summary.\n * The run function is given the last change summary.\n * The change summary is discarded after the run function was called.\n *\n * @see autorun\n */\nexport function autorunHandleChanges(options, fn) {\n    return new AutorunObserver(new DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? fn), fn, options.createEmptyChangeSummary, options.handleChange);\n}\n/**\n * @see autorunHandleChanges (but with a disposable store that is cleared before the next run or on dispose)\n */\nexport function autorunWithStoreHandleChanges(options, fn) {\n    const store = new DisposableStore();\n    const disposable = autorunHandleChanges({\n        owner: options.owner,\n        debugName: options.debugName,\n        debugReferenceFn: options.debugReferenceFn ?? fn,\n        createEmptyChangeSummary: options.createEmptyChangeSummary,\n        handleChange: options.handleChange,\n    }, (reader, changeSummary) => {\n        store.clear();\n        fn(reader, changeSummary, store);\n    });\n    return toDisposable(() => {\n        disposable.dispose();\n        store.dispose();\n    });\n}\n/**\n * @see autorun (but with a disposable store that is cleared before the next run or on dispose)\n */\nexport function autorunWithStore(fn) {\n    const store = new DisposableStore();\n    const disposable = autorunOpts({\n        owner: undefined,\n        debugName: undefined,\n        debugReferenceFn: fn,\n    }, reader => {\n        store.clear();\n        fn(reader, store);\n    });\n    return toDisposable(() => {\n        disposable.dispose();\n        store.dispose();\n    });\n}\nexport class AutorunObserver {\n    get debugName() {\n        return this._debugNameData.getDebugName(this) ?? '(anonymous)';\n    }\n    constructor(_debugNameData, _runFn, createChangeSummary, _handleChange) {\n        this._debugNameData = _debugNameData;\n        this._runFn = _runFn;\n        this.createChangeSummary = createChangeSummary;\n        this._handleChange = _handleChange;\n        this.state = 2 /* AutorunState.stale */;\n        this.updateCount = 0;\n        this.disposed = false;\n        this.dependencies = new Set();\n        this.dependenciesToBeRemoved = new Set();\n        this.changeSummary = this.createChangeSummary?.();\n        getLogger()?.handleAutorunCreated(this);\n        this._runIfNeeded();\n        trackDisposable(this);\n    }\n    dispose() {\n        this.disposed = true;\n        for (const o of this.dependencies) {\n            o.removeObserver(this);\n        }\n        this.dependencies.clear();\n        markAsDisposed(this);\n    }\n    _runIfNeeded() {\n        if (this.state === 3 /* AutorunState.upToDate */) {\n            return;\n        }\n        const emptySet = this.dependenciesToBeRemoved;\n        this.dependenciesToBeRemoved = this.dependencies;\n        this.dependencies = emptySet;\n        this.state = 3 /* AutorunState.upToDate */;\n        const isDisposed = this.disposed;\n        try {\n            if (!isDisposed) {\n                getLogger()?.handleAutorunTriggered(this);\n                const changeSummary = this.changeSummary;\n                this.changeSummary = this.createChangeSummary?.();\n                this._runFn(this, changeSummary);\n            }\n        }\n        finally {\n            if (!isDisposed) {\n                getLogger()?.handleAutorunFinished(this);\n            }\n            // We don't want our observed observables to think that they are (not even temporarily) not being observed.\n            // Thus, we only unsubscribe from observables that are definitely not read anymore.\n            for (const o of this.dependenciesToBeRemoved) {\n                o.removeObserver(this);\n            }\n            this.dependenciesToBeRemoved.clear();\n        }\n    }\n    toString() {\n        return `Autorun<${this.debugName}>`;\n    }\n    // IObserver implementation\n    beginUpdate() {\n        if (this.state === 3 /* AutorunState.upToDate */) {\n            this.state = 1 /* AutorunState.dependenciesMightHaveChanged */;\n        }\n        this.updateCount++;\n    }\n    endUpdate() {\n        if (this.updateCount === 1) {\n            do {\n                if (this.state === 1 /* AutorunState.dependenciesMightHaveChanged */) {\n                    this.state = 3 /* AutorunState.upToDate */;\n                    for (const d of this.dependencies) {\n                        d.reportChanges();\n                        if (this.state === 2 /* AutorunState.stale */) {\n                            // The other dependencies will refresh on demand\n                            break;\n                        }\n                    }\n                }\n                this._runIfNeeded();\n            } while (this.state !== 3 /* AutorunState.upToDate */);\n        }\n        this.updateCount--;\n        assertFn(() => this.updateCount >= 0);\n    }\n    handlePossibleChange(observable) {\n        if (this.state === 3 /* AutorunState.upToDate */ && this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n            this.state = 1 /* AutorunState.dependenciesMightHaveChanged */;\n        }\n    }\n    handleChange(observable, change) {\n        if (this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n            const shouldReact = this._handleChange ? this._handleChange({\n                changedObservable: observable,\n                change,\n                didChange: (o) => o === observable,\n            }, this.changeSummary) : true;\n            if (shouldReact) {\n                this.state = 2 /* AutorunState.stale */;\n            }\n        }\n    }\n    // IReader implementation\n    readObservable(observable) {\n        // In case the run action disposes the autorun\n        if (this.disposed) {\n            return observable.get();\n        }\n        observable.addObserver(this);\n        const value = observable.get();\n        this.dependencies.add(observable);\n        this.dependenciesToBeRemoved.delete(observable);\n        return value;\n    }\n}\n(function (autorun) {\n    autorun.Observer = AutorunObserver;\n})(autorun || (autorun = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { strictEquals } from '../equals.js';\nimport { DebugNameData, getFunctionName } from './debugName.js';\nimport { getLogger } from './logging.js';\nlet _recomputeInitiallyAndOnChange;\nexport function _setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange) {\n    _recomputeInitiallyAndOnChange = recomputeInitiallyAndOnChange;\n}\nlet _keepObserved;\nexport function _setKeepObserved(keepObserved) {\n    _keepObserved = keepObserved;\n}\nlet _derived;\n/**\n * @internal\n * This is to allow splitting files.\n*/\nexport function _setDerivedOpts(derived) {\n    _derived = derived;\n}\nexport class ConvenientObservable {\n    get TChange() { return null; }\n    reportChanges() {\n        this.get();\n    }\n    /** @sealed */\n    read(reader) {\n        if (reader) {\n            return reader.readObservable(this);\n        }\n        else {\n            return this.get();\n        }\n    }\n    map(fnOrOwner, fnOrUndefined) {\n        const owner = fnOrUndefined === undefined ? undefined : fnOrOwner;\n        const fn = fnOrUndefined === undefined ? fnOrOwner : fnOrUndefined;\n        return _derived({\n            owner,\n            debugName: () => {\n                const name = getFunctionName(fn);\n                if (name !== undefined) {\n                    return name;\n                }\n                // regexp to match `x => x.y` or `x => x?.y` where x and y can be arbitrary identifiers (uses backref):\n                const regexp = /^\\s*\\(?\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*\\)?\\s*=>\\s*\\1(?:\\??)\\.([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*$/;\n                const match = regexp.exec(fn.toString());\n                if (match) {\n                    return `${this.debugName}.${match[2]}`;\n                }\n                if (!owner) {\n                    return `${this.debugName} (mapped)`;\n                }\n                return undefined;\n            },\n            debugReferenceFn: fn,\n        }, (reader) => fn(this.read(reader), reader));\n    }\n    /**\n     * @sealed\n     * Converts an observable of an observable value into a direct observable of the value.\n    */\n    flatten() {\n        return _derived({\n            owner: undefined,\n            debugName: () => `${this.debugName} (flattened)`,\n        }, (reader) => this.read(reader).read(reader));\n    }\n    recomputeInitiallyAndOnChange(store, handleValue) {\n        store.add(_recomputeInitiallyAndOnChange(this, handleValue));\n        return this;\n    }\n    /**\n     * Ensures that this observable is observed. This keeps the cache alive.\n     * However, in case of deriveds, it does not force eager evaluation (only when the value is read/get).\n     * Use `recomputeInitiallyAndOnChange` for eager evaluation.\n     */\n    keepObserved(store) {\n        store.add(_keepObserved(this));\n        return this;\n    }\n}\nexport class BaseObservable extends ConvenientObservable {\n    constructor() {\n        super(...arguments);\n        this.observers = new Set();\n    }\n    addObserver(observer) {\n        const len = this.observers.size;\n        this.observers.add(observer);\n        if (len === 0) {\n            this.onFirstObserverAdded();\n        }\n    }\n    removeObserver(observer) {\n        const deleted = this.observers.delete(observer);\n        if (deleted && this.observers.size === 0) {\n            this.onLastObserverRemoved();\n        }\n    }\n    onFirstObserverAdded() { }\n    onLastObserverRemoved() { }\n}\n/**\n * Starts a transaction in which many observables can be changed at once.\n * {@link fn} should start with a JS Doc using `@description` to give the transaction a debug name.\n * Reaction run on demand or when the transaction ends.\n */\nexport function transaction(fn, getDebugName) {\n    const tx = new TransactionImpl(fn, getDebugName);\n    try {\n        fn(tx);\n    }\n    finally {\n        tx.finish();\n    }\n}\nlet _globalTransaction = undefined;\nexport function globalTransaction(fn) {\n    if (_globalTransaction) {\n        fn(_globalTransaction);\n    }\n    else {\n        const tx = new TransactionImpl(fn, undefined);\n        _globalTransaction = tx;\n        try {\n            fn(tx);\n        }\n        finally {\n            tx.finish(); // During finish, more actions might be added to the transaction.\n            // Which is why we only clear the global transaction after finish.\n            _globalTransaction = undefined;\n        }\n    }\n}\nexport async function asyncTransaction(fn, getDebugName) {\n    const tx = new TransactionImpl(fn, getDebugName);\n    try {\n        await fn(tx);\n    }\n    finally {\n        tx.finish();\n    }\n}\n/**\n * Allows to chain transactions.\n */\nexport function subtransaction(tx, fn, getDebugName) {\n    if (!tx) {\n        transaction(fn, getDebugName);\n    }\n    else {\n        fn(tx);\n    }\n}\nexport class TransactionImpl {\n    constructor(_fn, _getDebugName) {\n        this._fn = _fn;\n        this._getDebugName = _getDebugName;\n        this.updatingObservers = [];\n        getLogger()?.handleBeginTransaction(this);\n    }\n    getDebugName() {\n        if (this._getDebugName) {\n            return this._getDebugName();\n        }\n        return getFunctionName(this._fn);\n    }\n    updateObserver(observer, observable) {\n        // When this gets called while finish is active, they will still get considered\n        this.updatingObservers.push({ observer, observable });\n        observer.beginUpdate(observable);\n    }\n    finish() {\n        const updatingObservers = this.updatingObservers;\n        for (let i = 0; i < updatingObservers.length; i++) {\n            const { observer, observable } = updatingObservers[i];\n            observer.endUpdate(observable);\n        }\n        // Prevent anyone from updating observers from now on.\n        this.updatingObservers = null;\n        getLogger()?.handleEndTransaction();\n    }\n}\nexport function observableValue(nameOrOwner, initialValue) {\n    let debugNameData;\n    if (typeof nameOrOwner === 'string') {\n        debugNameData = new DebugNameData(undefined, nameOrOwner, undefined);\n    }\n    else {\n        debugNameData = new DebugNameData(nameOrOwner, undefined, undefined);\n    }\n    return new ObservableValue(debugNameData, initialValue, strictEquals);\n}\nexport class ObservableValue extends BaseObservable {\n    get debugName() {\n        return this._debugNameData.getDebugName(this) ?? 'ObservableValue';\n    }\n    constructor(_debugNameData, initialValue, _equalityComparator) {\n        super();\n        this._debugNameData = _debugNameData;\n        this._equalityComparator = _equalityComparator;\n        this._value = initialValue;\n    }\n    get() {\n        return this._value;\n    }\n    set(value, tx, change) {\n        if (change === undefined && this._equalityComparator(this._value, value)) {\n            return;\n        }\n        let _tx;\n        if (!tx) {\n            tx = _tx = new TransactionImpl(() => { }, () => `Setting ${this.debugName}`);\n        }\n        try {\n            const oldValue = this._value;\n            this._setValue(value);\n            getLogger()?.handleObservableChanged(this, { oldValue, newValue: value, change, didChange: true, hadValue: true });\n            for (const observer of this.observers) {\n                tx.updateObserver(observer, this);\n                observer.handleChange(this, change);\n            }\n        }\n        finally {\n            if (_tx) {\n                _tx.finish();\n            }\n        }\n    }\n    toString() {\n        return `${this.debugName}: ${this._value}`;\n    }\n    _setValue(newValue) {\n        this._value = newValue;\n    }\n}\n/**\n * A disposable observable. When disposed, its value is also disposed.\n * When a new value is set, the previous value is disposed.\n */\nexport function disposableObservableValue(nameOrOwner, initialValue) {\n    let debugNameData;\n    if (typeof nameOrOwner === 'string') {\n        debugNameData = new DebugNameData(undefined, nameOrOwner, undefined);\n    }\n    else {\n        debugNameData = new DebugNameData(nameOrOwner, undefined, undefined);\n    }\n    return new DisposableObservableValue(debugNameData, initialValue, strictEquals);\n}\nexport class DisposableObservableValue extends ObservableValue {\n    _setValue(newValue) {\n        if (this._value === newValue) {\n            return;\n        }\n        if (this._value) {\n            this._value.dispose();\n        }\n        this._value = newValue;\n    }\n    dispose() {\n        this._value?.dispose();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class DebugNameData {\n    constructor(owner, debugNameSource, referenceFn) {\n        this.owner = owner;\n        this.debugNameSource = debugNameSource;\n        this.referenceFn = referenceFn;\n    }\n    getDebugName(target) {\n        return getDebugName(target, this);\n    }\n}\nconst countPerName = new Map();\nconst cachedDebugName = new WeakMap();\nexport function getDebugName(target, data) {\n    const cached = cachedDebugName.get(target);\n    if (cached) {\n        return cached;\n    }\n    const dbgName = computeDebugName(target, data);\n    if (dbgName) {\n        let count = countPerName.get(dbgName) ?? 0;\n        count++;\n        countPerName.set(dbgName, count);\n        const result = count === 1 ? dbgName : `${dbgName}#${count}`;\n        cachedDebugName.set(target, result);\n        return result;\n    }\n    return undefined;\n}\nfunction computeDebugName(self, data) {\n    const cached = cachedDebugName.get(self);\n    if (cached) {\n        return cached;\n    }\n    const ownerStr = data.owner ? formatOwner(data.owner) + `.` : '';\n    let result;\n    const debugNameSource = data.debugNameSource;\n    if (debugNameSource !== undefined) {\n        if (typeof debugNameSource === 'function') {\n            result = debugNameSource();\n            if (result !== undefined) {\n                return ownerStr + result;\n            }\n        }\n        else {\n            return ownerStr + debugNameSource;\n        }\n    }\n    const referenceFn = data.referenceFn;\n    if (referenceFn !== undefined) {\n        result = getFunctionName(referenceFn);\n        if (result !== undefined) {\n            return ownerStr + result;\n        }\n    }\n    if (data.owner !== undefined) {\n        const key = findKey(data.owner, self);\n        if (key !== undefined) {\n            return ownerStr + key;\n        }\n    }\n    return undefined;\n}\nfunction findKey(obj, value) {\n    for (const key in obj) {\n        if (obj[key] === value) {\n            return key;\n        }\n    }\n    return undefined;\n}\nconst countPerClassName = new Map();\nconst ownerId = new WeakMap();\nfunction formatOwner(owner) {\n    const id = ownerId.get(owner);\n    if (id) {\n        return id;\n    }\n    const className = getClassName(owner);\n    let count = countPerClassName.get(className) ?? 0;\n    count++;\n    countPerClassName.set(className, count);\n    const result = count === 1 ? className : `${className}#${count}`;\n    ownerId.set(owner, result);\n    return result;\n}\nfunction getClassName(obj) {\n    const ctor = obj.constructor;\n    if (ctor) {\n        return ctor.name;\n    }\n    return 'Object';\n}\nexport function getFunctionName(fn) {\n    const fnSrc = fn.toString();\n    // Pattern: /** @description ... */\n    const regexp = /\\/\\*\\*\\s*@description\\s*([^*]*)\\*\\//;\n    const match = regexp.exec(fnSrc);\n    const result = match ? match[1] : undefined;\n    return result?.trim();\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertFn } from '../assert.js';\nimport { strictEquals } from '../equals.js';\nimport { DisposableStore } from '../lifecycle.js';\nimport { BaseObservable, _setDerivedOpts } from './base.js';\nimport { DebugNameData } from './debugName.js';\nimport { getLogger } from './logging.js';\nexport function derived(computeFnOrOwner, computeFn) {\n    if (computeFn !== undefined) {\n        return new Derived(new DebugNameData(computeFnOrOwner, undefined, computeFn), computeFn, undefined, undefined, undefined, strictEquals);\n    }\n    return new Derived(new DebugNameData(undefined, undefined, computeFnOrOwner), computeFnOrOwner, undefined, undefined, undefined, strictEquals);\n}\nexport function derivedWithSetter(owner, computeFn, setter) {\n    return new DerivedWithSetter(new DebugNameData(owner, undefined, computeFn), computeFn, undefined, undefined, undefined, strictEquals, setter);\n}\nexport function derivedOpts(options, computeFn) {\n    return new Derived(new DebugNameData(options.owner, options.debugName, options.debugReferenceFn), computeFn, undefined, undefined, options.onLastObserverRemoved, options.equalsFn ?? strictEquals);\n}\n_setDerivedOpts(derivedOpts);\n/**\n * Represents an observable that is derived from other observables.\n * The value is only recomputed when absolutely needed.\n *\n * {@link computeFn} should start with a JS Doc using `@description` to name the derived.\n *\n * Use `createEmptyChangeSummary` to create a \"change summary\" that can collect the changes.\n * Use `handleChange` to add a reported change to the change summary.\n * The compute function is given the last change summary.\n * The change summary is discarded after the compute function was called.\n *\n * @see derived\n */\nexport function derivedHandleChanges(options, computeFn) {\n    return new Derived(new DebugNameData(options.owner, options.debugName, undefined), computeFn, options.createEmptyChangeSummary, options.handleChange, undefined, options.equalityComparer ?? strictEquals);\n}\nexport function derivedWithStore(computeFnOrOwner, computeFnOrUndefined) {\n    let computeFn;\n    let owner;\n    if (computeFnOrUndefined === undefined) {\n        computeFn = computeFnOrOwner;\n        owner = undefined;\n    }\n    else {\n        owner = computeFnOrOwner;\n        computeFn = computeFnOrUndefined;\n    }\n    const store = new DisposableStore();\n    return new Derived(new DebugNameData(owner, undefined, computeFn), r => {\n        store.clear();\n        return computeFn(r, store);\n    }, undefined, undefined, () => store.dispose(), strictEquals);\n}\nexport function derivedDisposable(computeFnOrOwner, computeFnOrUndefined) {\n    let computeFn;\n    let owner;\n    if (computeFnOrUndefined === undefined) {\n        computeFn = computeFnOrOwner;\n        owner = undefined;\n    }\n    else {\n        owner = computeFnOrOwner;\n        computeFn = computeFnOrUndefined;\n    }\n    let store = undefined;\n    return new Derived(new DebugNameData(owner, undefined, computeFn), r => {\n        if (!store) {\n            store = new DisposableStore();\n        }\n        else {\n            store.clear();\n        }\n        const result = computeFn(r);\n        if (result) {\n            store.add(result);\n        }\n        return result;\n    }, undefined, undefined, () => {\n        if (store) {\n            store.dispose();\n            store = undefined;\n        }\n    }, strictEquals);\n}\nexport class Derived extends BaseObservable {\n    get debugName() {\n        return this._debugNameData.getDebugName(this) ?? '(anonymous)';\n    }\n    constructor(_debugNameData, _computeFn, createChangeSummary, _handleChange, _handleLastObserverRemoved = undefined, _equalityComparator) {\n        super();\n        this._debugNameData = _debugNameData;\n        this._computeFn = _computeFn;\n        this.createChangeSummary = createChangeSummary;\n        this._handleChange = _handleChange;\n        this._handleLastObserverRemoved = _handleLastObserverRemoved;\n        this._equalityComparator = _equalityComparator;\n        this.state = 0 /* DerivedState.initial */;\n        this.value = undefined;\n        this.updateCount = 0;\n        this.dependencies = new Set();\n        this.dependenciesToBeRemoved = new Set();\n        this.changeSummary = undefined;\n        this.changeSummary = this.createChangeSummary?.();\n        getLogger()?.handleDerivedCreated(this);\n    }\n    onLastObserverRemoved() {\n        /**\n         * We are not tracking changes anymore, thus we have to assume\n         * that our cache is invalid.\n         */\n        this.state = 0 /* DerivedState.initial */;\n        this.value = undefined;\n        for (const d of this.dependencies) {\n            d.removeObserver(this);\n        }\n        this.dependencies.clear();\n        this._handleLastObserverRemoved?.();\n    }\n    get() {\n        if (this.observers.size === 0) {\n            // Without observers, we don't know when to clean up stuff.\n            // Thus, we don't cache anything to prevent memory leaks.\n            const result = this._computeFn(this, this.createChangeSummary?.());\n            // Clear new dependencies\n            this.onLastObserverRemoved();\n            return result;\n        }\n        else {\n            do {\n                // We might not get a notification for a dependency that changed while it is updating,\n                // thus we also have to ask all our depedencies if they changed in this case.\n                if (this.state === 1 /* DerivedState.dependenciesMightHaveChanged */) {\n                    for (const d of this.dependencies) {\n                        /** might call {@link handleChange} indirectly, which could make us stale */\n                        d.reportChanges();\n                        if (this.state === 2 /* DerivedState.stale */) {\n                            // The other dependencies will refresh on demand, so early break\n                            break;\n                        }\n                    }\n                }\n                // We called report changes of all dependencies.\n                // If we are still not stale, we can assume to be up to date again.\n                if (this.state === 1 /* DerivedState.dependenciesMightHaveChanged */) {\n                    this.state = 3 /* DerivedState.upToDate */;\n                }\n                this._recomputeIfNeeded();\n                // In case recomputation changed one of our dependencies, we need to recompute again.\n            } while (this.state !== 3 /* DerivedState.upToDate */);\n            return this.value;\n        }\n    }\n    _recomputeIfNeeded() {\n        if (this.state === 3 /* DerivedState.upToDate */) {\n            return;\n        }\n        const emptySet = this.dependenciesToBeRemoved;\n        this.dependenciesToBeRemoved = this.dependencies;\n        this.dependencies = emptySet;\n        const hadValue = this.state !== 0 /* DerivedState.initial */;\n        const oldValue = this.value;\n        this.state = 3 /* DerivedState.upToDate */;\n        const changeSummary = this.changeSummary;\n        this.changeSummary = this.createChangeSummary?.();\n        try {\n            /** might call {@link handleChange} indirectly, which could invalidate us */\n            this.value = this._computeFn(this, changeSummary);\n        }\n        finally {\n            // We don't want our observed observables to think that they are (not even temporarily) not being observed.\n            // Thus, we only unsubscribe from observables that are definitely not read anymore.\n            for (const o of this.dependenciesToBeRemoved) {\n                o.removeObserver(this);\n            }\n            this.dependenciesToBeRemoved.clear();\n        }\n        const didChange = hadValue && !(this._equalityComparator(oldValue, this.value));\n        getLogger()?.handleDerivedRecomputed(this, {\n            oldValue,\n            newValue: this.value,\n            change: undefined,\n            didChange,\n            hadValue,\n        });\n        if (didChange) {\n            for (const r of this.observers) {\n                r.handleChange(this, undefined);\n            }\n        }\n    }\n    toString() {\n        return `LazyDerived<${this.debugName}>`;\n    }\n    // IObserver Implementation\n    beginUpdate(_observable) {\n        this.updateCount++;\n        const propagateBeginUpdate = this.updateCount === 1;\n        if (this.state === 3 /* DerivedState.upToDate */) {\n            this.state = 1 /* DerivedState.dependenciesMightHaveChanged */;\n            // If we propagate begin update, that will already signal a possible change.\n            if (!propagateBeginUpdate) {\n                for (const r of this.observers) {\n                    r.handlePossibleChange(this);\n                }\n            }\n        }\n        if (propagateBeginUpdate) {\n            for (const r of this.observers) {\n                r.beginUpdate(this); // This signals a possible change\n            }\n        }\n    }\n    endUpdate(_observable) {\n        this.updateCount--;\n        if (this.updateCount === 0) {\n            // End update could change the observer list.\n            const observers = [...this.observers];\n            for (const r of observers) {\n                r.endUpdate(this);\n            }\n        }\n        assertFn(() => this.updateCount >= 0);\n    }\n    handlePossibleChange(observable) {\n        // In all other states, observers already know that we might have changed.\n        if (this.state === 3 /* DerivedState.upToDate */ && this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n            this.state = 1 /* DerivedState.dependenciesMightHaveChanged */;\n            for (const r of this.observers) {\n                r.handlePossibleChange(this);\n            }\n        }\n    }\n    handleChange(observable, change) {\n        if (this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n            const shouldReact = this._handleChange ? this._handleChange({\n                changedObservable: observable,\n                change,\n                didChange: (o) => o === observable,\n            }, this.changeSummary) : true;\n            const wasUpToDate = this.state === 3 /* DerivedState.upToDate */;\n            if (shouldReact && (this.state === 1 /* DerivedState.dependenciesMightHaveChanged */ || wasUpToDate)) {\n                this.state = 2 /* DerivedState.stale */;\n                if (wasUpToDate) {\n                    for (const r of this.observers) {\n                        r.handlePossibleChange(this);\n                    }\n                }\n            }\n        }\n    }\n    // IReader Implementation\n    readObservable(observable) {\n        // Subscribe before getting the value to enable caching\n        observable.addObserver(this);\n        /** This might call {@link handleChange} indirectly, which could invalidate us */\n        const value = observable.get();\n        // Which is why we only add the observable to the dependencies now.\n        this.dependencies.add(observable);\n        this.dependenciesToBeRemoved.delete(observable);\n        return value;\n    }\n    addObserver(observer) {\n        const shouldCallBeginUpdate = !this.observers.has(observer) && this.updateCount > 0;\n        super.addObserver(observer);\n        if (shouldCallBeginUpdate) {\n            observer.beginUpdate(this);\n        }\n    }\n    removeObserver(observer) {\n        const shouldCallEndUpdate = this.observers.has(observer) && this.updateCount > 0;\n        super.removeObserver(observer);\n        if (shouldCallEndUpdate) {\n            // Calling end update after removing the observer makes sure endUpdate cannot be called twice here.\n            observer.endUpdate(this);\n        }\n    }\n}\nexport class DerivedWithSetter extends Derived {\n    constructor(debugNameData, computeFn, createChangeSummary, handleChange, handleLastObserverRemoved = undefined, equalityComparator, set) {\n        super(debugNameData, computeFn, createChangeSummary, handleChange, handleLastObserverRemoved, equalityComparator);\n        this.set = set;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { autorun } from './autorun.js';\nimport { observableValue, transaction } from './base.js';\nimport { CancellationError } from '../errors.js';\n/**\n * A promise whose state is observable.\n */\nexport class ObservablePromise {\n    static fromFn(fn) {\n        return new ObservablePromise(fn());\n    }\n    constructor(promise) {\n        this._value = observableValue(this, undefined);\n        /**\n         * The current state of the promise.\n         * Is `undefined` if the promise didn't resolve yet.\n         */\n        this.promiseResult = this._value;\n        this.promise = promise.then(value => {\n            transaction(tx => {\n                /** @description onPromiseResolved */\n                this._value.set(new PromiseResult(value, undefined), tx);\n            });\n            return value;\n        }, error => {\n            transaction(tx => {\n                /** @description onPromiseRejected */\n                this._value.set(new PromiseResult(undefined, error), tx);\n            });\n            throw error;\n        });\n    }\n}\nexport class PromiseResult {\n    constructor(\n    /**\n     * The value of the resolved promise.\n     * Undefined if the promise rejected.\n     */\n    data, \n    /**\n     * The error in case of a rejected promise.\n     * Undefined if the promise resolved.\n     */\n    error) {\n        this.data = data;\n        this.error = error;\n    }\n}\nexport function waitForState(observable, predicate, isError, cancellationToken) {\n    if (!predicate) {\n        predicate = state => state !== null && state !== undefined;\n    }\n    return new Promise((resolve, reject) => {\n        let isImmediateRun = true;\n        let shouldDispose = false;\n        const stateObs = observable.map(state => {\n            /** @description waitForState.state */\n            return {\n                isFinished: predicate(state),\n                error: isError ? isError(state) : false,\n                state\n            };\n        });\n        const d = autorun(reader => {\n            /** @description waitForState */\n            const { isFinished, error, state } = stateObs.read(reader);\n            if (isFinished || error) {\n                if (isImmediateRun) {\n                    // The variable `d` is not initialized yet\n                    shouldDispose = true;\n                }\n                else {\n                    d.dispose();\n                }\n                if (error) {\n                    reject(error === true ? state : error);\n                }\n                else {\n                    resolve(state);\n                }\n            }\n        });\n        if (cancellationToken) {\n            const dc = cancellationToken.onCancellationRequested(() => {\n                d.dispose();\n                dc.dispose();\n                reject(new CancellationError());\n            });\n            if (cancellationToken.isCancellationRequested) {\n                d.dispose();\n                dc.dispose();\n                reject(new CancellationError());\n                return;\n            }\n        }\n        isImmediateRun = false;\n        if (shouldDispose) {\n            d.dispose();\n        }\n    });\n}\n"],"names":["strictEquals","a","b","itemsEquals","itemEquals","arguments","length","undefined","arrays","equals","equalsIfDefined","equalsOrV1","v2","v1","structuralEquals","Array","isArray","i","Object","getPrototypeOf","prototype","aObj","bObj","keysA","keys","keysB","keysBSet","Set","key","has","WeakMap","LazyObservableValue","BaseObservable","debugName","_this$_debugNameData$","this","_debugNameData","getDebugName","constructor","initialValue","_equalityComparator","super","_isUpToDate","_deltas","_updateCounter","_value","get","_update","observer","observers","change","handleChange","_beginUpdate","beginUpdate","_endUpdate","r","endUpdate","addObserver","shouldCallBeginUpdate","removeObserver","shouldCallEndUpdate","set","value","tx","_tx","TransactionImpl","concat","_setValue","push","updateObserver","observable","handlePossibleChange","finish","toString","newValue","observableValueOpts","options","_options$equalsFn2","_options$equalsFn","lazy","DebugNameData","owner","equalsFn","ObservableValue","autorun","fn","AutorunObserver","autorunOpts","_options$debugReferen","debugReferenceFn","autorunHandleChanges","_options$debugReferen2","createEmptyChangeSummary","autorunWithStoreHandleChanges","_options$debugReferen3","store","DisposableStore","disposable","reader","changeSummary","clear","toDisposable","dispose","autorunWithStore","_runFn","createChangeSummary","_handleChange","_this$createChangeSum","_getLogger","state","updateCount","disposed","dependencies","dependenciesToBeRemoved","call","getLogger","handleAutorunCreated","_runIfNeeded","trackDisposable","o","markAsDisposed","emptySet","isDisposed","_getLogger2","_this$createChangeSum2","handleAutorunTriggered","_getLogger3","handleAutorunFinished","d","reportChanges","assertFn","changedObservable","didChange","readObservable","add","delete","Observer","_recomputeInitiallyAndOnChange","_keepObserved","_derived","_setRecomputeInitiallyAndOnChange","recomputeInitiallyAndOnChange","_setKeepObserved","keepObserved","_setDerivedOpts","derived","ConvenientObservable","TChange","read","map","fnOrOwner","fnOrUndefined","name","getFunctionName","match","exec","flatten","handleValue","len","size","onFirstObserverAdded","onLastObserverRemoved","transaction","_globalTransaction","globalTransaction","async","asyncTransaction","subtransaction","_fn","_getDebugName","updatingObservers","handleBeginTransaction","handleEndTransaction","observableValue","nameOrOwner","debugNameData","oldValue","handleObservableChanged","hadValue","disposableObservableValue","DisposableObservableValue","_this$_value","debugNameSource","referenceFn","target","data","cached","cachedDebugName","dbgName","self","ownerStr","_countPerClassName$ge","id","ownerId","className","obj","ctor","getClassName","count","countPerClassName","result","formatOwner","findKey","computeDebugName","_countPerName$get","countPerName","Map","fnSrc","trim","computeFnOrOwner","computeFn","Derived","derivedWithSetter","setter","DerivedWithSetter","derivedOpts","derivedHandleChanges","_options$equalityComp","equalityComparer","derivedWithStore","computeFnOrUndefined","derivedDisposable","_computeFn","_handleLastObserverRemoved","handleDerivedCreated","_this$_handleLastObse","_recomputeIfNeeded","_this$createChangeSum3","handleDerivedRecomputed","_observable","propagateBeginUpdate","shouldReact","wasUpToDate","ObservablePromise","fromFn","promise","promiseResult","then","PromiseResult","error","waitForState","predicate","isError","cancellationToken","Promise","resolve","reject","isImmediateRun","shouldDispose","stateObs","isFinished","dc","onCancellationRequested","CancellationError","isCancellationRequested"],"sourceRoot":""}