{"version":3,"file":"static/js/2042.6835e469.chunk.js","mappings":"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","sources":["../node_modules/monaco-editor/esm/vs/base/common/buffer.js","../node_modules/monaco-editor/esm/vs/base/common/cache.js","../node_modules/monaco-editor/esm/vs/base/common/lazy.js","../node_modules/monaco-editor/esm/vs/editor/common/core/cursorColumns.js","../node_modules/monaco-editor/esm/vs/editor/common/core/stringBuilder.js","../node_modules/monaco-editor/esm/vs/editor/common/core/textModelDefaults.js","../node_modules/monaco-editor/esm/vs/platform/jsonschemas/common/jsonContributionRegistry.js","../node_modules/monaco-editor/esm/vs/platform/registry/common/platform.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Lazy } from './lazy.js';\nconst hasBuffer = (typeof Buffer !== 'undefined');\nconst indexOfTable = new Lazy(() => new Uint8Array(256));\nlet textDecoder;\nexport class VSBuffer {\n    /**\n     * When running in a nodejs context, if `actual` is not a nodejs Buffer, the backing store for\n     * the returned `VSBuffer` instance might use a nodejs Buffer allocated from node's Buffer pool,\n     * which is not transferrable.\n     */\n    static wrap(actual) {\n        if (hasBuffer && !(Buffer.isBuffer(actual))) {\n            // https://nodejs.org/dist/latest-v10.x/docs/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\n            // Create a zero-copy Buffer wrapper around the ArrayBuffer pointed to by the Uint8Array\n            actual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);\n        }\n        return new VSBuffer(actual);\n    }\n    constructor(buffer) {\n        this.buffer = buffer;\n        this.byteLength = this.buffer.byteLength;\n    }\n    toString() {\n        if (hasBuffer) {\n            return this.buffer.toString();\n        }\n        else {\n            if (!textDecoder) {\n                textDecoder = new TextDecoder();\n            }\n            return textDecoder.decode(this.buffer);\n        }\n    }\n}\nexport function readUInt16LE(source, offset) {\n    return (((source[offset + 0] << 0) >>> 0) |\n        ((source[offset + 1] << 8) >>> 0));\n}\nexport function writeUInt16LE(destination, value, offset) {\n    destination[offset + 0] = (value & 0b11111111);\n    value = value >>> 8;\n    destination[offset + 1] = (value & 0b11111111);\n}\nexport function readUInt32BE(source, offset) {\n    return (source[offset] * 2 ** 24\n        + source[offset + 1] * 2 ** 16\n        + source[offset + 2] * 2 ** 8\n        + source[offset + 3]);\n}\nexport function writeUInt32BE(destination, value, offset) {\n    destination[offset + 3] = value;\n    value = value >>> 8;\n    destination[offset + 2] = value;\n    value = value >>> 8;\n    destination[offset + 1] = value;\n    value = value >>> 8;\n    destination[offset] = value;\n}\nexport function readUInt8(source, offset) {\n    return source[offset];\n}\nexport function writeUInt8(destination, value, offset) {\n    destination[offset] = value;\n}\n","export function identity(t) {\n    return t;\n}\n/**\n * Uses a LRU cache to make a given parametrized function cached.\n * Caches just the last key/value.\n*/\nexport class LRUCachedFunction {\n    constructor(arg1, arg2) {\n        this.lastCache = undefined;\n        this.lastArgKey = undefined;\n        if (typeof arg1 === 'function') {\n            this._fn = arg1;\n            this._computeKey = identity;\n        }\n        else {\n            this._fn = arg2;\n            this._computeKey = arg1.getCacheKey;\n        }\n    }\n    get(arg) {\n        const key = this._computeKey(arg);\n        if (this.lastArgKey !== key) {\n            this.lastArgKey = key;\n            this.lastCache = this._fn(arg);\n        }\n        return this.lastCache;\n    }\n}\n/**\n * Uses an unbounded cache to memoize the results of the given function.\n*/\nexport class CachedFunction {\n    get cachedValues() {\n        return this._map;\n    }\n    constructor(arg1, arg2) {\n        this._map = new Map();\n        this._map2 = new Map();\n        if (typeof arg1 === 'function') {\n            this._fn = arg1;\n            this._computeKey = identity;\n        }\n        else {\n            this._fn = arg2;\n            this._computeKey = arg1.getCacheKey;\n        }\n    }\n    get(arg) {\n        const key = this._computeKey(arg);\n        if (this._map2.has(key)) {\n            return this._map2.get(key);\n        }\n        const value = this._fn(arg);\n        this._map.set(arg, value);\n        this._map2.set(key, value);\n        return value;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class Lazy {\n    constructor(executor) {\n        this.executor = executor;\n        this._didRun = false;\n    }\n    /**\n     * Get the wrapped value.\n     *\n     * This will force evaluation of the lazy value if it has not been resolved yet. Lazy values are only\n     * resolved once. `getValue` will re-throw exceptions that are hit while resolving the value\n     */\n    get value() {\n        if (!this._didRun) {\n            try {\n                this._value = this.executor();\n            }\n            catch (err) {\n                this._error = err;\n            }\n            finally {\n                this._didRun = true;\n            }\n        }\n        if (this._error) {\n            throw this._error;\n        }\n        return this._value;\n    }\n    /**\n     * Get the wrapped value without forcing evaluation.\n     */\n    get rawValue() { return this._value; }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\n/**\n * A column in a position is the gap between two adjacent characters. The methods here\n * work with a concept called \"visible column\". A visible column is a very rough approximation\n * of the horizontal screen position of a column. For example, using a tab size of 4:\n * ```txt\n * |<TAB>|<TAB>|T|ext\n * |     |     | \\---- column = 4, visible column = 9\n * |     |     \\------ column = 3, visible column = 8\n * |     \\------------ column = 2, visible column = 4\n * \\------------------ column = 1, visible column = 0\n * ```\n *\n * **NOTE**: Visual columns do not work well for RTL text or variable-width fonts or characters.\n *\n * **NOTE**: These methods work and make sense both on the model and on the view model.\n */\nexport class CursorColumns {\n    static _nextVisibleColumn(codePoint, visibleColumn, tabSize) {\n        if (codePoint === 9 /* CharCode.Tab */) {\n            return CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n        }\n        if (strings.isFullWidthCharacter(codePoint) || strings.isEmojiImprecise(codePoint)) {\n            return visibleColumn + 2;\n        }\n        return visibleColumn + 1;\n    }\n    /**\n     * Returns a visible column from a column.\n     * @see {@link CursorColumns}\n     */\n    static visibleColumnFromColumn(lineContent, column, tabSize) {\n        const textLen = Math.min(column - 1, lineContent.length);\n        const text = lineContent.substring(0, textLen);\n        const iterator = new strings.GraphemeIterator(text);\n        let result = 0;\n        while (!iterator.eol()) {\n            const codePoint = strings.getNextCodePoint(text, textLen, iterator.offset);\n            iterator.nextGraphemeLength();\n            result = this._nextVisibleColumn(codePoint, result, tabSize);\n        }\n        return result;\n    }\n    /**\n     * Returns a column from a visible column.\n     * @see {@link CursorColumns}\n     */\n    static columnFromVisibleColumn(lineContent, visibleColumn, tabSize) {\n        if (visibleColumn <= 0) {\n            return 1;\n        }\n        const lineContentLength = lineContent.length;\n        const iterator = new strings.GraphemeIterator(lineContent);\n        let beforeVisibleColumn = 0;\n        let beforeColumn = 1;\n        while (!iterator.eol()) {\n            const codePoint = strings.getNextCodePoint(lineContent, lineContentLength, iterator.offset);\n            iterator.nextGraphemeLength();\n            const afterVisibleColumn = this._nextVisibleColumn(codePoint, beforeVisibleColumn, tabSize);\n            const afterColumn = iterator.offset + 1;\n            if (afterVisibleColumn >= visibleColumn) {\n                const beforeDelta = visibleColumn - beforeVisibleColumn;\n                const afterDelta = afterVisibleColumn - visibleColumn;\n                if (afterDelta < beforeDelta) {\n                    return afterColumn;\n                }\n                else {\n                    return beforeColumn;\n                }\n            }\n            beforeVisibleColumn = afterVisibleColumn;\n            beforeColumn = afterColumn;\n        }\n        // walked the entire string\n        return lineContentLength + 1;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static nextRenderTabStop(visibleColumn, tabSize) {\n        return visibleColumn + tabSize - visibleColumn % tabSize;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static nextIndentTabStop(visibleColumn, indentSize) {\n        return visibleColumn + indentSize - visibleColumn % indentSize;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static prevRenderTabStop(column, tabSize) {\n        return Math.max(0, column - 1 - (column - 1) % tabSize);\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static prevIndentTabStop(column, indentSize) {\n        return Math.max(0, column - 1 - (column - 1) % indentSize);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as buffer from '../../../base/common/buffer.js';\nlet _utf16LE_TextDecoder;\nfunction getUTF16LE_TextDecoder() {\n    if (!_utf16LE_TextDecoder) {\n        _utf16LE_TextDecoder = new TextDecoder('UTF-16LE');\n    }\n    return _utf16LE_TextDecoder;\n}\nlet _utf16BE_TextDecoder;\nfunction getUTF16BE_TextDecoder() {\n    if (!_utf16BE_TextDecoder) {\n        _utf16BE_TextDecoder = new TextDecoder('UTF-16BE');\n    }\n    return _utf16BE_TextDecoder;\n}\nlet _platformTextDecoder;\nexport function getPlatformTextDecoder() {\n    if (!_platformTextDecoder) {\n        _platformTextDecoder = platform.isLittleEndian() ? getUTF16LE_TextDecoder() : getUTF16BE_TextDecoder();\n    }\n    return _platformTextDecoder;\n}\nexport function decodeUTF16LE(source, offset, len) {\n    const view = new Uint16Array(source.buffer, offset, len);\n    if (len > 0 && (view[0] === 0xFEFF || view[0] === 0xFFFE)) {\n        // UTF16 sometimes starts with a BOM https://de.wikipedia.org/wiki/Byte_Order_Mark\n        // It looks like TextDecoder.decode will eat up a leading BOM (0xFEFF or 0xFFFE)\n        // We don't want that behavior because we know the string is UTF16LE and the BOM should be maintained\n        // So we use the manual decoder\n        return compatDecodeUTF16LE(source, offset, len);\n    }\n    return getUTF16LE_TextDecoder().decode(view);\n}\nfunction compatDecodeUTF16LE(source, offset, len) {\n    const result = [];\n    let resultLen = 0;\n    for (let i = 0; i < len; i++) {\n        const charCode = buffer.readUInt16LE(source, offset);\n        offset += 2;\n        result[resultLen++] = String.fromCharCode(charCode);\n    }\n    return result.join('');\n}\nexport class StringBuilder {\n    constructor(capacity) {\n        this._capacity = capacity | 0;\n        this._buffer = new Uint16Array(this._capacity);\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    reset() {\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    build() {\n        if (this._completedStrings !== null) {\n            this._flushBuffer();\n            return this._completedStrings.join('');\n        }\n        return this._buildBuffer();\n    }\n    _buildBuffer() {\n        if (this._bufferLength === 0) {\n            return '';\n        }\n        const view = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);\n        return getPlatformTextDecoder().decode(view);\n    }\n    _flushBuffer() {\n        const bufferString = this._buildBuffer();\n        this._bufferLength = 0;\n        if (this._completedStrings === null) {\n            this._completedStrings = [bufferString];\n        }\n        else {\n            this._completedStrings[this._completedStrings.length] = bufferString;\n        }\n    }\n    /**\n     * Append a char code (<2^16)\n     */\n    appendCharCode(charCode) {\n        const remainingSpace = this._capacity - this._bufferLength;\n        if (remainingSpace <= 1) {\n            if (remainingSpace === 0 || strings.isHighSurrogate(charCode)) {\n                this._flushBuffer();\n            }\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    /**\n     * Append an ASCII char code (<2^8)\n     */\n    appendASCIICharCode(charCode) {\n        if (this._bufferLength === this._capacity) {\n            // buffer is full\n            this._flushBuffer();\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    appendString(str) {\n        const strLen = str.length;\n        if (this._bufferLength + strLen >= this._capacity) {\n            // This string does not fit in the remaining buffer space\n            this._flushBuffer();\n            this._completedStrings[this._completedStrings.length] = str;\n            return;\n        }\n        for (let i = 0; i < strLen; i++) {\n            this._buffer[this._bufferLength++] = str.charCodeAt(i);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport const EDITOR_MODEL_DEFAULTS = {\n    tabSize: 4,\n    indentSize: 4,\n    insertSpaces: true,\n    detectIndentation: true,\n    trimAutoWhitespace: true,\n    largeFileOptimizations: true,\n    bracketPairColorizationOptions: {\n        enabled: true,\n        independentColorPoolPerBracketType: false,\n    },\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../base/common/event.js';\nimport * as platform from '../../registry/common/platform.js';\nexport const Extensions = {\n    JSONContribution: 'base.contributions.json'\n};\nfunction normalizeId(id) {\n    if (id.length > 0 && id.charAt(id.length - 1) === '#') {\n        return id.substring(0, id.length - 1);\n    }\n    return id;\n}\nclass JSONContributionRegistry {\n    constructor() {\n        this._onDidChangeSchema = new Emitter();\n        this.schemasById = {};\n    }\n    registerSchema(uri, unresolvedSchemaContent) {\n        this.schemasById[normalizeId(uri)] = unresolvedSchemaContent;\n        this._onDidChangeSchema.fire(uri);\n    }\n    notifySchemaChanged(uri) {\n        this._onDidChangeSchema.fire(uri);\n    }\n}\nconst jsonContributionRegistry = new JSONContributionRegistry();\nplatform.Registry.add(Extensions.JSONContribution, jsonContributionRegistry);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as Assert from '../../../base/common/assert.js';\nimport * as Types from '../../../base/common/types.js';\nclass RegistryImpl {\n    constructor() {\n        this.data = new Map();\n    }\n    add(id, data) {\n        Assert.ok(Types.isString(id));\n        Assert.ok(Types.isObject(data));\n        Assert.ok(!this.data.has(id), 'There is already an extension with this id');\n        this.data.set(id, data);\n    }\n    as(id) {\n        return this.data.get(id) || null;\n    }\n}\nexport const Registry = new RegistryImpl();\n"],"names":["hasBuffer","Buffer","Lazy","Uint8Array","textDecoder","VSBuffer","wrap","actual","isBuffer","from","buffer","byteOffset","byteLength","constructor","this","toString","TextDecoder","decode","readUInt16LE","source","offset","writeUInt16LE","destination","value","readUInt32BE","writeUInt32BE","readUInt8","writeUInt8","identity","t","LRUCachedFunction","arg1","arg2","lastCache","undefined","lastArgKey","_fn","_computeKey","getCacheKey","get","arg","key","CachedFunction","cachedValues","_map","Map","_map2","has","set","executor","_didRun","_value","err","_error","rawValue","CursorColumns","_nextVisibleColumn","codePoint","visibleColumn","tabSize","nextRenderTabStop","strings","visibleColumnFromColumn","lineContent","column","textLen","Math","min","length","text","substring","iterator","result","eol","nextGraphemeLength","columnFromVisibleColumn","lineContentLength","beforeVisibleColumn","beforeColumn","afterVisibleColumn","afterColumn","nextIndentTabStop","indentSize","prevRenderTabStop","max","prevIndentTabStop","_utf16LE_TextDecoder","_utf16BE_TextDecoder","_platformTextDecoder","getUTF16LE_TextDecoder","getPlatformTextDecoder","platform","decodeUTF16LE","len","view","Uint16Array","resultLen","i","charCode","String","fromCharCode","join","compatDecodeUTF16LE","StringBuilder","capacity","_capacity","_buffer","_completedStrings","_bufferLength","reset","build","_flushBuffer","_buildBuffer","bufferString","appendCharCode","remainingSpace","appendASCIICharCode","appendString","str","strLen","charCodeAt","EDITOR_MODEL_DEFAULTS","insertSpaces","detectIndentation","trimAutoWhitespace","largeFileOptimizations","bracketPairColorizationOptions","enabled","independentColorPoolPerBracketType","Extensions","JSONContribution","jsonContributionRegistry","_onDidChangeSchema","Emitter","schemasById","registerSchema","uri","unresolvedSchemaContent","id","charAt","fire","notifySchemaChanged","add","Registry","data","Assert","Types","as"],"sourceRoot":""}