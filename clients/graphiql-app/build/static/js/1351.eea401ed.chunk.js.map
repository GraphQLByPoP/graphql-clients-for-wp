{"version":3,"file":"static/js/1351.eea401ed.chunk.js","mappings":"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","sources":["../node_modules/monaco-editor/esm/vs/base/common/buffer.js","../node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensDto.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Lazy } from './lazy.js';\nconst hasBuffer = (typeof Buffer !== 'undefined');\nconst indexOfTable = new Lazy(() => new Uint8Array(256));\nlet textDecoder;\nexport class VSBuffer {\n    /**\n     * When running in a nodejs context, if `actual` is not a nodejs Buffer, the backing store for\n     * the returned `VSBuffer` instance might use a nodejs Buffer allocated from node's Buffer pool,\n     * which is not transferrable.\n     */\n    static wrap(actual) {\n        if (hasBuffer && !(Buffer.isBuffer(actual))) {\n            // https://nodejs.org/dist/latest-v10.x/docs/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\n            // Create a zero-copy Buffer wrapper around the ArrayBuffer pointed to by the Uint8Array\n            actual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);\n        }\n        return new VSBuffer(actual);\n    }\n    constructor(buffer) {\n        this.buffer = buffer;\n        this.byteLength = this.buffer.byteLength;\n    }\n    toString() {\n        if (hasBuffer) {\n            return this.buffer.toString();\n        }\n        else {\n            if (!textDecoder) {\n                textDecoder = new TextDecoder();\n            }\n            return textDecoder.decode(this.buffer);\n        }\n    }\n}\nexport function readUInt16LE(source, offset) {\n    return (((source[offset + 0] << 0) >>> 0) |\n        ((source[offset + 1] << 8) >>> 0));\n}\nexport function writeUInt16LE(destination, value, offset) {\n    destination[offset + 0] = (value & 0b11111111);\n    value = value >>> 8;\n    destination[offset + 1] = (value & 0b11111111);\n}\nexport function readUInt32BE(source, offset) {\n    return (source[offset] * 2 ** 24\n        + source[offset + 1] * 2 ** 16\n        + source[offset + 2] * 2 ** 8\n        + source[offset + 3]);\n}\nexport function writeUInt32BE(destination, value, offset) {\n    destination[offset + 3] = value;\n    value = value >>> 8;\n    destination[offset + 2] = value;\n    value = value >>> 8;\n    destination[offset + 1] = value;\n    value = value >>> 8;\n    destination[offset] = value;\n}\nexport function readUInt8(source, offset) {\n    return source[offset];\n}\nexport function writeUInt8(destination, value, offset) {\n    destination[offset] = value;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { VSBuffer } from '../../../base/common/buffer.js';\nimport * as platform from '../../../base/common/platform.js';\nfunction reverseEndianness(arr) {\n    for (let i = 0, len = arr.length; i < len; i += 4) {\n        // flip bytes 0<->3 and 1<->2\n        const b0 = arr[i + 0];\n        const b1 = arr[i + 1];\n        const b2 = arr[i + 2];\n        const b3 = arr[i + 3];\n        arr[i + 0] = b3;\n        arr[i + 1] = b2;\n        arr[i + 2] = b1;\n        arr[i + 3] = b0;\n    }\n}\nfunction toLittleEndianBuffer(arr) {\n    const uint8Arr = new Uint8Array(arr.buffer, arr.byteOffset, arr.length * 4);\n    if (!platform.isLittleEndian()) {\n        // the byte order must be changed\n        reverseEndianness(uint8Arr);\n    }\n    return VSBuffer.wrap(uint8Arr);\n}\nexport function encodeSemanticTokensDto(semanticTokens) {\n    const dest = new Uint32Array(encodeSemanticTokensDtoSize(semanticTokens));\n    let offset = 0;\n    dest[offset++] = semanticTokens.id;\n    if (semanticTokens.type === 'full') {\n        dest[offset++] = 1 /* EncodedSemanticTokensType.Full */;\n        dest[offset++] = semanticTokens.data.length;\n        dest.set(semanticTokens.data, offset);\n        offset += semanticTokens.data.length;\n    }\n    else {\n        dest[offset++] = 2 /* EncodedSemanticTokensType.Delta */;\n        dest[offset++] = semanticTokens.deltas.length;\n        for (const delta of semanticTokens.deltas) {\n            dest[offset++] = delta.start;\n            dest[offset++] = delta.deleteCount;\n            if (delta.data) {\n                dest[offset++] = delta.data.length;\n                dest.set(delta.data, offset);\n                offset += delta.data.length;\n            }\n            else {\n                dest[offset++] = 0;\n            }\n        }\n    }\n    return toLittleEndianBuffer(dest);\n}\nfunction encodeSemanticTokensDtoSize(semanticTokens) {\n    let result = 0;\n    result += (+1 // id\n        + 1 // type\n    );\n    if (semanticTokens.type === 'full') {\n        result += (+1 // data length\n            + semanticTokens.data.length);\n    }\n    else {\n        result += (+1 // delta count\n        );\n        result += (+1 // start\n            + 1 // deleteCount\n            + 1 // data length\n        ) * semanticTokens.deltas.length;\n        for (const delta of semanticTokens.deltas) {\n            if (delta.data) {\n                result += delta.data.length;\n            }\n        }\n    }\n    return result;\n}\n"],"names":["hasBuffer","Buffer","Lazy","Uint8Array","textDecoder","VSBuffer","wrap","actual","isBuffer","from","buffer","byteOffset","byteLength","constructor","this","toString","TextDecoder","decode","readUInt16LE","source","offset","writeUInt16LE","destination","value","readUInt32BE","writeUInt32BE","readUInt8","writeUInt8","encodeSemanticTokensDto","semanticTokens","dest","Uint32Array","result","type","data","length","deltas","delta","encodeSemanticTokensDtoSize","id","set","start","deleteCount","arr","uint8Arr","platform","i","len","b0","b1","b2","b3","reverseEndianness","toLittleEndianBuffer"],"sourceRoot":""}