{"version":3,"file":"static/js/3538.01be25a8.chunk.js","mappings":"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","sources":["../node_modules/monaco-editor/esm/vs/base/common/buffer.js","../node_modules/monaco-editor/esm/vs/editor/common/core/cursorColumns.js","../node_modules/monaco-editor/esm/vs/editor/common/core/editorColorRegistry.js","../node_modules/monaco-editor/esm/vs/editor/common/core/indentation.js","../node_modules/monaco-editor/esm/vs/editor/common/core/stringBuilder.js","../node_modules/monaco-editor/esm/vs/editor/common/core/textChange.js","../node_modules/monaco-editor/esm/vs/editor/common/core/textModelDefaults.js","../node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfiguration.js","../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/characterPair.js","../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/electricCharacter.js","../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/indentRules.js","../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/onEnter.js","../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/languageBracketsConfiguration.js","../node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfigurationRegistry.js","../node_modules/monaco-editor/esm/vs/editor/common/languages/nullTokenize.js","../node_modules/monaco-editor/esm/vs/editor/common/languages/supports.js","../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/richEditBrackets.js","../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/ast.js","../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/beforeEditPositionMapper.js","../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/brackets.js","../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/combineTextEditInfos.js","../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/length.js","../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/concat23Trees.js","../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/nodeReader.js","../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/parser.js","../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/smallImmutableSet.js","../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.js","../node_modules/monaco-editor/esm/vs/editor/common/model/editStack.js","../node_modules/monaco-editor/esm/vs/editor/common/model/guidesTextModelPart.js","../node_modules/monaco-editor/esm/vs/editor/common/textModelBracketPairs.js","../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/bracketPairsTree.js","../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsImpl.js","../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js","../node_modules/monaco-editor/esm/vs/editor/common/model/indentationGuesser.js","../node_modules/monaco-editor/esm/vs/editor/common/model/intervalTree.js","../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/rbTreeBase.js","../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.js","../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.js","../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js","../node_modules/monaco-editor/esm/vs/editor/common/model/fixedArray.js","../node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousMultilineTokens.js","../node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousMultilineTokensBuilder.js","../node_modules/monaco-editor/esm/vs/editor/common/model/textModelTokens.js","../node_modules/monaco-editor/esm/vs/editor/common/model/tokens.js","../node_modules/monaco-editor/esm/vs/editor/common/model/treeSitterTokens.js","../node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousTokensEditing.js","../node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousTokensStore.js","../node_modules/monaco-editor/esm/vs/editor/common/tokens/sparseTokensStore.js","../node_modules/monaco-editor/esm/vs/editor/common/model/tokenizationTextModelPart.js","../node_modules/monaco-editor/esm/vs/editor/common/model/textModel.js","../node_modules/monaco-editor/esm/vs/editor/common/model/textModelPart.js","../node_modules/monaco-editor/esm/vs/editor/common/model/utils.js","../node_modules/monaco-editor/esm/vs/editor/common/services/modelService.js","../node_modules/monaco-editor/esm/vs/editor/common/services/textResourceConfiguration.js","../node_modules/monaco-editor/esm/vs/editor/common/services/treeSitterParserService.js","../node_modules/monaco-editor/esm/vs/editor/common/textModelEvents.js","../node_modules/monaco-editor/esm/vs/editor/common/textModelGuides.js","../node_modules/monaco-editor/esm/vs/editor/common/tokens/lineTokens.js","../node_modules/monaco-editor/esm/vs/platform/instantiation/common/descriptors.js","../node_modules/monaco-editor/esm/vs/platform/instantiation/common/extensions.js","../node_modules/monaco-editor/esm/vs/platform/undoRedo/common/undoRedo.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Lazy } from './lazy.js';\nconst hasBuffer = (typeof Buffer !== 'undefined');\nconst indexOfTable = new Lazy(() => new Uint8Array(256));\nlet textDecoder;\nexport class VSBuffer {\n    /**\n     * When running in a nodejs context, if `actual` is not a nodejs Buffer, the backing store for\n     * the returned `VSBuffer` instance might use a nodejs Buffer allocated from node's Buffer pool,\n     * which is not transferrable.\n     */\n    static wrap(actual) {\n        if (hasBuffer && !(Buffer.isBuffer(actual))) {\n            // https://nodejs.org/dist/latest-v10.x/docs/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\n            // Create a zero-copy Buffer wrapper around the ArrayBuffer pointed to by the Uint8Array\n            actual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);\n        }\n        return new VSBuffer(actual);\n    }\n    constructor(buffer) {\n        this.buffer = buffer;\n        this.byteLength = this.buffer.byteLength;\n    }\n    toString() {\n        if (hasBuffer) {\n            return this.buffer.toString();\n        }\n        else {\n            if (!textDecoder) {\n                textDecoder = new TextDecoder();\n            }\n            return textDecoder.decode(this.buffer);\n        }\n    }\n}\nexport function readUInt16LE(source, offset) {\n    return (((source[offset + 0] << 0) >>> 0) |\n        ((source[offset + 1] << 8) >>> 0));\n}\nexport function writeUInt16LE(destination, value, offset) {\n    destination[offset + 0] = (value & 0b11111111);\n    value = value >>> 8;\n    destination[offset + 1] = (value & 0b11111111);\n}\nexport function readUInt32BE(source, offset) {\n    return (source[offset] * 2 ** 24\n        + source[offset + 1] * 2 ** 16\n        + source[offset + 2] * 2 ** 8\n        + source[offset + 3]);\n}\nexport function writeUInt32BE(destination, value, offset) {\n    destination[offset + 3] = value;\n    value = value >>> 8;\n    destination[offset + 2] = value;\n    value = value >>> 8;\n    destination[offset + 1] = value;\n    value = value >>> 8;\n    destination[offset] = value;\n}\nexport function readUInt8(source, offset) {\n    return source[offset];\n}\nexport function writeUInt8(destination, value, offset) {\n    destination[offset] = value;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\n/**\n * A column in a position is the gap between two adjacent characters. The methods here\n * work with a concept called \"visible column\". A visible column is a very rough approximation\n * of the horizontal screen position of a column. For example, using a tab size of 4:\n * ```txt\n * |<TAB>|<TAB>|T|ext\n * |     |     | \\---- column = 4, visible column = 9\n * |     |     \\------ column = 3, visible column = 8\n * |     \\------------ column = 2, visible column = 4\n * \\------------------ column = 1, visible column = 0\n * ```\n *\n * **NOTE**: Visual columns do not work well for RTL text or variable-width fonts or characters.\n *\n * **NOTE**: These methods work and make sense both on the model and on the view model.\n */\nexport class CursorColumns {\n    static _nextVisibleColumn(codePoint, visibleColumn, tabSize) {\n        if (codePoint === 9 /* CharCode.Tab */) {\n            return CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n        }\n        if (strings.isFullWidthCharacter(codePoint) || strings.isEmojiImprecise(codePoint)) {\n            return visibleColumn + 2;\n        }\n        return visibleColumn + 1;\n    }\n    /**\n     * Returns a visible column from a column.\n     * @see {@link CursorColumns}\n     */\n    static visibleColumnFromColumn(lineContent, column, tabSize) {\n        const textLen = Math.min(column - 1, lineContent.length);\n        const text = lineContent.substring(0, textLen);\n        const iterator = new strings.GraphemeIterator(text);\n        let result = 0;\n        while (!iterator.eol()) {\n            const codePoint = strings.getNextCodePoint(text, textLen, iterator.offset);\n            iterator.nextGraphemeLength();\n            result = this._nextVisibleColumn(codePoint, result, tabSize);\n        }\n        return result;\n    }\n    /**\n     * Returns a column from a visible column.\n     * @see {@link CursorColumns}\n     */\n    static columnFromVisibleColumn(lineContent, visibleColumn, tabSize) {\n        if (visibleColumn <= 0) {\n            return 1;\n        }\n        const lineContentLength = lineContent.length;\n        const iterator = new strings.GraphemeIterator(lineContent);\n        let beforeVisibleColumn = 0;\n        let beforeColumn = 1;\n        while (!iterator.eol()) {\n            const codePoint = strings.getNextCodePoint(lineContent, lineContentLength, iterator.offset);\n            iterator.nextGraphemeLength();\n            const afterVisibleColumn = this._nextVisibleColumn(codePoint, beforeVisibleColumn, tabSize);\n            const afterColumn = iterator.offset + 1;\n            if (afterVisibleColumn >= visibleColumn) {\n                const beforeDelta = visibleColumn - beforeVisibleColumn;\n                const afterDelta = afterVisibleColumn - visibleColumn;\n                if (afterDelta < beforeDelta) {\n                    return afterColumn;\n                }\n                else {\n                    return beforeColumn;\n                }\n            }\n            beforeVisibleColumn = afterVisibleColumn;\n            beforeColumn = afterColumn;\n        }\n        // walked the entire string\n        return lineContentLength + 1;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static nextRenderTabStop(visibleColumn, tabSize) {\n        return visibleColumn + tabSize - visibleColumn % tabSize;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static nextIndentTabStop(visibleColumn, indentSize) {\n        return visibleColumn + indentSize - visibleColumn % indentSize;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static prevRenderTabStop(column, tabSize) {\n        return Math.max(0, column - 1 - (column - 1) % tabSize);\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static prevIndentTabStop(column, indentSize) {\n        return Math.max(0, column - 1 - (column - 1) % indentSize);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport { Color, RGBA } from '../../../base/common/color.js';\nimport { activeContrastBorder, editorBackground, registerColor, editorWarningForeground, editorInfoForeground, editorWarningBorder, editorInfoBorder, contrastBorder, editorFindMatchHighlight, editorWarningBackground } from '../../../platform/theme/common/colorRegistry.js';\nimport { registerThemingParticipant } from '../../../platform/theme/common/themeService.js';\n/**\n * Definition of the editor colors\n */\nexport const editorLineHighlight = registerColor('editor.lineHighlightBackground', null, nls.localize('lineHighlight', 'Background color for the highlight of line at the cursor position.'));\nexport const editorLineHighlightBorder = registerColor('editor.lineHighlightBorder', { dark: '#282828', light: '#eeeeee', hcDark: '#f38518', hcLight: contrastBorder }, nls.localize('lineHighlightBorderBox', 'Background color for the border around the line at the cursor position.'));\nexport const editorRangeHighlight = registerColor('editor.rangeHighlightBackground', { dark: '#ffffff0b', light: '#fdff0033', hcDark: null, hcLight: null }, nls.localize('rangeHighlight', 'Background color of highlighted ranges, like by quick open and find features. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const editorRangeHighlightBorder = registerColor('editor.rangeHighlightBorder', { dark: null, light: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('rangeHighlightBorder', 'Background color of the border around highlighted ranges.'));\nexport const editorSymbolHighlight = registerColor('editor.symbolHighlightBackground', { dark: editorFindMatchHighlight, light: editorFindMatchHighlight, hcDark: null, hcLight: null }, nls.localize('symbolHighlight', 'Background color of highlighted symbol, like for go to definition or go next/previous symbol. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const editorSymbolHighlightBorder = registerColor('editor.symbolHighlightBorder', { dark: null, light: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('symbolHighlightBorder', 'Background color of the border around highlighted symbols.'));\nexport const editorCursorForeground = registerColor('editorCursor.foreground', { dark: '#AEAFAD', light: Color.black, hcDark: Color.white, hcLight: '#0F4A85' }, nls.localize('caret', 'Color of the editor cursor.'));\nexport const editorCursorBackground = registerColor('editorCursor.background', null, nls.localize('editorCursorBackground', 'The background color of the editor cursor. Allows customizing the color of a character overlapped by a block cursor.'));\nexport const editorMultiCursorPrimaryForeground = registerColor('editorMultiCursor.primary.foreground', editorCursorForeground, nls.localize('editorMultiCursorPrimaryForeground', 'Color of the primary editor cursor when multiple cursors are present.'));\nexport const editorMultiCursorPrimaryBackground = registerColor('editorMultiCursor.primary.background', editorCursorBackground, nls.localize('editorMultiCursorPrimaryBackground', 'The background color of the primary editor cursor when multiple cursors are present. Allows customizing the color of a character overlapped by a block cursor.'));\nexport const editorMultiCursorSecondaryForeground = registerColor('editorMultiCursor.secondary.foreground', editorCursorForeground, nls.localize('editorMultiCursorSecondaryForeground', 'Color of secondary editor cursors when multiple cursors are present.'));\nexport const editorMultiCursorSecondaryBackground = registerColor('editorMultiCursor.secondary.background', editorCursorBackground, nls.localize('editorMultiCursorSecondaryBackground', 'The background color of secondary editor cursors when multiple cursors are present. Allows customizing the color of a character overlapped by a block cursor.'));\nexport const editorWhitespaces = registerColor('editorWhitespace.foreground', { dark: '#e3e4e229', light: '#33333333', hcDark: '#e3e4e229', hcLight: '#CCCCCC' }, nls.localize('editorWhitespaces', 'Color of whitespace characters in the editor.'));\nexport const editorLineNumbers = registerColor('editorLineNumber.foreground', { dark: '#858585', light: '#237893', hcDark: Color.white, hcLight: '#292929' }, nls.localize('editorLineNumbers', 'Color of editor line numbers.'));\nexport const deprecatedEditorIndentGuides = registerColor('editorIndentGuide.background', editorWhitespaces, nls.localize('editorIndentGuides', 'Color of the editor indentation guides.'), false, nls.localize('deprecatedEditorIndentGuides', '\\'editorIndentGuide.background\\' is deprecated. Use \\'editorIndentGuide.background1\\' instead.'));\nexport const deprecatedEditorActiveIndentGuides = registerColor('editorIndentGuide.activeBackground', editorWhitespaces, nls.localize('editorActiveIndentGuide', 'Color of the active editor indentation guides.'), false, nls.localize('deprecatedEditorActiveIndentGuide', '\\'editorIndentGuide.activeBackground\\' is deprecated. Use \\'editorIndentGuide.activeBackground1\\' instead.'));\nexport const editorIndentGuide1 = registerColor('editorIndentGuide.background1', deprecatedEditorIndentGuides, nls.localize('editorIndentGuides1', 'Color of the editor indentation guides (1).'));\nexport const editorIndentGuide2 = registerColor('editorIndentGuide.background2', '#00000000', nls.localize('editorIndentGuides2', 'Color of the editor indentation guides (2).'));\nexport const editorIndentGuide3 = registerColor('editorIndentGuide.background3', '#00000000', nls.localize('editorIndentGuides3', 'Color of the editor indentation guides (3).'));\nexport const editorIndentGuide4 = registerColor('editorIndentGuide.background4', '#00000000', nls.localize('editorIndentGuides4', 'Color of the editor indentation guides (4).'));\nexport const editorIndentGuide5 = registerColor('editorIndentGuide.background5', '#00000000', nls.localize('editorIndentGuides5', 'Color of the editor indentation guides (5).'));\nexport const editorIndentGuide6 = registerColor('editorIndentGuide.background6', '#00000000', nls.localize('editorIndentGuides6', 'Color of the editor indentation guides (6).'));\nexport const editorActiveIndentGuide1 = registerColor('editorIndentGuide.activeBackground1', deprecatedEditorActiveIndentGuides, nls.localize('editorActiveIndentGuide1', 'Color of the active editor indentation guides (1).'));\nexport const editorActiveIndentGuide2 = registerColor('editorIndentGuide.activeBackground2', '#00000000', nls.localize('editorActiveIndentGuide2', 'Color of the active editor indentation guides (2).'));\nexport const editorActiveIndentGuide3 = registerColor('editorIndentGuide.activeBackground3', '#00000000', nls.localize('editorActiveIndentGuide3', 'Color of the active editor indentation guides (3).'));\nexport const editorActiveIndentGuide4 = registerColor('editorIndentGuide.activeBackground4', '#00000000', nls.localize('editorActiveIndentGuide4', 'Color of the active editor indentation guides (4).'));\nexport const editorActiveIndentGuide5 = registerColor('editorIndentGuide.activeBackground5', '#00000000', nls.localize('editorActiveIndentGuide5', 'Color of the active editor indentation guides (5).'));\nexport const editorActiveIndentGuide6 = registerColor('editorIndentGuide.activeBackground6', '#00000000', nls.localize('editorActiveIndentGuide6', 'Color of the active editor indentation guides (6).'));\nconst deprecatedEditorActiveLineNumber = registerColor('editorActiveLineNumber.foreground', { dark: '#c6c6c6', light: '#0B216F', hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('editorActiveLineNumber', 'Color of editor active line number'), false, nls.localize('deprecatedEditorActiveLineNumber', 'Id is deprecated. Use \\'editorLineNumber.activeForeground\\' instead.'));\nexport const editorActiveLineNumber = registerColor('editorLineNumber.activeForeground', deprecatedEditorActiveLineNumber, nls.localize('editorActiveLineNumber', 'Color of editor active line number'));\nexport const editorDimmedLineNumber = registerColor('editorLineNumber.dimmedForeground', null, nls.localize('editorDimmedLineNumber', 'Color of the final editor line when editor.renderFinalNewline is set to dimmed.'));\nexport const editorRuler = registerColor('editorRuler.foreground', { dark: '#5A5A5A', light: Color.lightgrey, hcDark: Color.white, hcLight: '#292929' }, nls.localize('editorRuler', 'Color of the editor rulers.'));\nexport const editorCodeLensForeground = registerColor('editorCodeLens.foreground', { dark: '#999999', light: '#919191', hcDark: '#999999', hcLight: '#292929' }, nls.localize('editorCodeLensForeground', 'Foreground color of editor CodeLens'));\nexport const editorBracketMatchBackground = registerColor('editorBracketMatch.background', { dark: '#0064001a', light: '#0064001a', hcDark: '#0064001a', hcLight: '#0000' }, nls.localize('editorBracketMatchBackground', 'Background color behind matching brackets'));\nexport const editorBracketMatchBorder = registerColor('editorBracketMatch.border', { dark: '#888', light: '#B9B9B9', hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('editorBracketMatchBorder', 'Color for matching brackets boxes'));\nexport const editorOverviewRulerBorder = registerColor('editorOverviewRuler.border', { dark: '#7f7f7f4d', light: '#7f7f7f4d', hcDark: '#7f7f7f4d', hcLight: '#666666' }, nls.localize('editorOverviewRulerBorder', 'Color of the overview ruler border.'));\nexport const editorOverviewRulerBackground = registerColor('editorOverviewRuler.background', null, nls.localize('editorOverviewRulerBackground', 'Background color of the editor overview ruler.'));\nexport const editorGutter = registerColor('editorGutter.background', editorBackground, nls.localize('editorGutter', 'Background color of the editor gutter. The gutter contains the glyph margins and the line numbers.'));\nexport const editorUnnecessaryCodeBorder = registerColor('editorUnnecessaryCode.border', { dark: null, light: null, hcDark: Color.fromHex('#fff').transparent(0.8), hcLight: contrastBorder }, nls.localize('unnecessaryCodeBorder', 'Border color of unnecessary (unused) source code in the editor.'));\nexport const editorUnnecessaryCodeOpacity = registerColor('editorUnnecessaryCode.opacity', { dark: Color.fromHex('#000a'), light: Color.fromHex('#0007'), hcDark: null, hcLight: null }, nls.localize('unnecessaryCodeOpacity', 'Opacity of unnecessary (unused) source code in the editor. For example, \"#000000c0\" will render the code with 75% opacity. For high contrast themes, use the  \\'editorUnnecessaryCode.border\\' theme color to underline unnecessary code instead of fading it out.'));\nexport const ghostTextBorder = registerColor('editorGhostText.border', { dark: null, light: null, hcDark: Color.fromHex('#fff').transparent(0.8), hcLight: Color.fromHex('#292929').transparent(0.8) }, nls.localize('editorGhostTextBorder', 'Border color of ghost text in the editor.'));\nexport const ghostTextForeground = registerColor('editorGhostText.foreground', { dark: Color.fromHex('#ffffff56'), light: Color.fromHex('#0007'), hcDark: null, hcLight: null }, nls.localize('editorGhostTextForeground', 'Foreground color of the ghost text in the editor.'));\nexport const ghostTextBackground = registerColor('editorGhostText.background', null, nls.localize('editorGhostTextBackground', 'Background color of the ghost text in the editor.'));\nconst rulerRangeDefault = new Color(new RGBA(0, 122, 204, 0.6));\nexport const overviewRulerRangeHighlight = registerColor('editorOverviewRuler.rangeHighlightForeground', rulerRangeDefault, nls.localize('overviewRulerRangeHighlight', 'Overview ruler marker color for range highlights. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const overviewRulerError = registerColor('editorOverviewRuler.errorForeground', { dark: new Color(new RGBA(255, 18, 18, 0.7)), light: new Color(new RGBA(255, 18, 18, 0.7)), hcDark: new Color(new RGBA(255, 50, 50, 1)), hcLight: '#B5200D' }, nls.localize('overviewRuleError', 'Overview ruler marker color for errors.'));\nexport const overviewRulerWarning = registerColor('editorOverviewRuler.warningForeground', { dark: editorWarningForeground, light: editorWarningForeground, hcDark: editorWarningBorder, hcLight: editorWarningBorder }, nls.localize('overviewRuleWarning', 'Overview ruler marker color for warnings.'));\nexport const overviewRulerInfo = registerColor('editorOverviewRuler.infoForeground', { dark: editorInfoForeground, light: editorInfoForeground, hcDark: editorInfoBorder, hcLight: editorInfoBorder }, nls.localize('overviewRuleInfo', 'Overview ruler marker color for infos.'));\nexport const editorBracketHighlightingForeground1 = registerColor('editorBracketHighlight.foreground1', { dark: '#FFD700', light: '#0431FAFF', hcDark: '#FFD700', hcLight: '#0431FAFF' }, nls.localize('editorBracketHighlightForeground1', 'Foreground color of brackets (1). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground2 = registerColor('editorBracketHighlight.foreground2', { dark: '#DA70D6', light: '#319331FF', hcDark: '#DA70D6', hcLight: '#319331FF' }, nls.localize('editorBracketHighlightForeground2', 'Foreground color of brackets (2). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground3 = registerColor('editorBracketHighlight.foreground3', { dark: '#179FFF', light: '#7B3814FF', hcDark: '#87CEFA', hcLight: '#7B3814FF' }, nls.localize('editorBracketHighlightForeground3', 'Foreground color of brackets (3). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground4 = registerColor('editorBracketHighlight.foreground4', '#00000000', nls.localize('editorBracketHighlightForeground4', 'Foreground color of brackets (4). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground5 = registerColor('editorBracketHighlight.foreground5', '#00000000', nls.localize('editorBracketHighlightForeground5', 'Foreground color of brackets (5). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground6 = registerColor('editorBracketHighlight.foreground6', '#00000000', nls.localize('editorBracketHighlightForeground6', 'Foreground color of brackets (6). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingUnexpectedBracketForeground = registerColor('editorBracketHighlight.unexpectedBracket.foreground', { dark: new Color(new RGBA(255, 18, 18, 0.8)), light: new Color(new RGBA(255, 18, 18, 0.8)), hcDark: 'new Color(new RGBA(255, 50, 50, 1))', hcLight: '#B5200D' }, nls.localize('editorBracketHighlightUnexpectedBracketForeground', 'Foreground color of unexpected brackets.'));\nexport const editorBracketPairGuideBackground1 = registerColor('editorBracketPairGuide.background1', '#00000000', nls.localize('editorBracketPairGuide.background1', 'Background color of inactive bracket pair guides (1). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground2 = registerColor('editorBracketPairGuide.background2', '#00000000', nls.localize('editorBracketPairGuide.background2', 'Background color of inactive bracket pair guides (2). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground3 = registerColor('editorBracketPairGuide.background3', '#00000000', nls.localize('editorBracketPairGuide.background3', 'Background color of inactive bracket pair guides (3). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground4 = registerColor('editorBracketPairGuide.background4', '#00000000', nls.localize('editorBracketPairGuide.background4', 'Background color of inactive bracket pair guides (4). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground5 = registerColor('editorBracketPairGuide.background5', '#00000000', nls.localize('editorBracketPairGuide.background5', 'Background color of inactive bracket pair guides (5). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground6 = registerColor('editorBracketPairGuide.background6', '#00000000', nls.localize('editorBracketPairGuide.background6', 'Background color of inactive bracket pair guides (6). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground1 = registerColor('editorBracketPairGuide.activeBackground1', '#00000000', nls.localize('editorBracketPairGuide.activeBackground1', 'Background color of active bracket pair guides (1). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground2 = registerColor('editorBracketPairGuide.activeBackground2', '#00000000', nls.localize('editorBracketPairGuide.activeBackground2', 'Background color of active bracket pair guides (2). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground3 = registerColor('editorBracketPairGuide.activeBackground3', '#00000000', nls.localize('editorBracketPairGuide.activeBackground3', 'Background color of active bracket pair guides (3). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground4 = registerColor('editorBracketPairGuide.activeBackground4', '#00000000', nls.localize('editorBracketPairGuide.activeBackground4', 'Background color of active bracket pair guides (4). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground5 = registerColor('editorBracketPairGuide.activeBackground5', '#00000000', nls.localize('editorBracketPairGuide.activeBackground5', 'Background color of active bracket pair guides (5). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground6 = registerColor('editorBracketPairGuide.activeBackground6', '#00000000', nls.localize('editorBracketPairGuide.activeBackground6', 'Background color of active bracket pair guides (6). Requires enabling bracket pair guides.'));\nexport const editorUnicodeHighlightBorder = registerColor('editorUnicodeHighlight.border', editorWarningForeground, nls.localize('editorUnicodeHighlight.border', 'Border color used to highlight unicode characters.'));\nexport const editorUnicodeHighlightBackground = registerColor('editorUnicodeHighlight.background', editorWarningBackground, nls.localize('editorUnicodeHighlight.background', 'Background color used to highlight unicode characters.'));\n// contains all color rules that used to defined in editor/browser/widget/editor.css\nregisterThemingParticipant((theme, collector) => {\n    const background = theme.getColor(editorBackground);\n    const lineHighlight = theme.getColor(editorLineHighlight);\n    const imeBackground = (lineHighlight && !lineHighlight.isTransparent() ? lineHighlight : background);\n    if (imeBackground) {\n        collector.addRule(`.monaco-editor .inputarea.ime-input { background-color: ${imeBackground}; }`);\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from './cursorColumns.js';\nfunction _normalizeIndentationFromWhitespace(str, indentSize, insertSpaces) {\n    let spacesCnt = 0;\n    for (let i = 0; i < str.length; i++) {\n        if (str.charAt(i) === '\\t') {\n            spacesCnt = CursorColumns.nextIndentTabStop(spacesCnt, indentSize);\n        }\n        else {\n            spacesCnt++;\n        }\n    }\n    let result = '';\n    if (!insertSpaces) {\n        const tabsCnt = Math.floor(spacesCnt / indentSize);\n        spacesCnt = spacesCnt % indentSize;\n        for (let i = 0; i < tabsCnt; i++) {\n            result += '\\t';\n        }\n    }\n    for (let i = 0; i < spacesCnt; i++) {\n        result += ' ';\n    }\n    return result;\n}\nexport function normalizeIndentation(str, indentSize, insertSpaces) {\n    let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(str);\n    if (firstNonWhitespaceIndex === -1) {\n        firstNonWhitespaceIndex = str.length;\n    }\n    return _normalizeIndentationFromWhitespace(str.substring(0, firstNonWhitespaceIndex), indentSize, insertSpaces) + str.substring(firstNonWhitespaceIndex);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as buffer from '../../../base/common/buffer.js';\nlet _utf16LE_TextDecoder;\nfunction getUTF16LE_TextDecoder() {\n    if (!_utf16LE_TextDecoder) {\n        _utf16LE_TextDecoder = new TextDecoder('UTF-16LE');\n    }\n    return _utf16LE_TextDecoder;\n}\nlet _utf16BE_TextDecoder;\nfunction getUTF16BE_TextDecoder() {\n    if (!_utf16BE_TextDecoder) {\n        _utf16BE_TextDecoder = new TextDecoder('UTF-16BE');\n    }\n    return _utf16BE_TextDecoder;\n}\nlet _platformTextDecoder;\nexport function getPlatformTextDecoder() {\n    if (!_platformTextDecoder) {\n        _platformTextDecoder = platform.isLittleEndian() ? getUTF16LE_TextDecoder() : getUTF16BE_TextDecoder();\n    }\n    return _platformTextDecoder;\n}\nexport function decodeUTF16LE(source, offset, len) {\n    const view = new Uint16Array(source.buffer, offset, len);\n    if (len > 0 && (view[0] === 0xFEFF || view[0] === 0xFFFE)) {\n        // UTF16 sometimes starts with a BOM https://de.wikipedia.org/wiki/Byte_Order_Mark\n        // It looks like TextDecoder.decode will eat up a leading BOM (0xFEFF or 0xFFFE)\n        // We don't want that behavior because we know the string is UTF16LE and the BOM should be maintained\n        // So we use the manual decoder\n        return compatDecodeUTF16LE(source, offset, len);\n    }\n    return getUTF16LE_TextDecoder().decode(view);\n}\nfunction compatDecodeUTF16LE(source, offset, len) {\n    const result = [];\n    let resultLen = 0;\n    for (let i = 0; i < len; i++) {\n        const charCode = buffer.readUInt16LE(source, offset);\n        offset += 2;\n        result[resultLen++] = String.fromCharCode(charCode);\n    }\n    return result.join('');\n}\nexport class StringBuilder {\n    constructor(capacity) {\n        this._capacity = capacity | 0;\n        this._buffer = new Uint16Array(this._capacity);\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    reset() {\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    build() {\n        if (this._completedStrings !== null) {\n            this._flushBuffer();\n            return this._completedStrings.join('');\n        }\n        return this._buildBuffer();\n    }\n    _buildBuffer() {\n        if (this._bufferLength === 0) {\n            return '';\n        }\n        const view = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);\n        return getPlatformTextDecoder().decode(view);\n    }\n    _flushBuffer() {\n        const bufferString = this._buildBuffer();\n        this._bufferLength = 0;\n        if (this._completedStrings === null) {\n            this._completedStrings = [bufferString];\n        }\n        else {\n            this._completedStrings[this._completedStrings.length] = bufferString;\n        }\n    }\n    /**\n     * Append a char code (<2^16)\n     */\n    appendCharCode(charCode) {\n        const remainingSpace = this._capacity - this._bufferLength;\n        if (remainingSpace <= 1) {\n            if (remainingSpace === 0 || strings.isHighSurrogate(charCode)) {\n                this._flushBuffer();\n            }\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    /**\n     * Append an ASCII char code (<2^8)\n     */\n    appendASCIICharCode(charCode) {\n        if (this._bufferLength === this._capacity) {\n            // buffer is full\n            this._flushBuffer();\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    appendString(str) {\n        const strLen = str.length;\n        if (this._bufferLength + strLen >= this._capacity) {\n            // This string does not fit in the remaining buffer space\n            this._flushBuffer();\n            this._completedStrings[this._completedStrings.length] = str;\n            return;\n        }\n        for (let i = 0; i < strLen; i++) {\n            this._buffer[this._bufferLength++] = str.charCodeAt(i);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as buffer from '../../../base/common/buffer.js';\nimport { decodeUTF16LE } from './stringBuilder.js';\nfunction escapeNewLine(str) {\n    return (str\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r'));\n}\nexport class TextChange {\n    get oldLength() {\n        return this.oldText.length;\n    }\n    get oldEnd() {\n        return this.oldPosition + this.oldText.length;\n    }\n    get newLength() {\n        return this.newText.length;\n    }\n    get newEnd() {\n        return this.newPosition + this.newText.length;\n    }\n    constructor(oldPosition, oldText, newPosition, newText) {\n        this.oldPosition = oldPosition;\n        this.oldText = oldText;\n        this.newPosition = newPosition;\n        this.newText = newText;\n    }\n    toString() {\n        if (this.oldText.length === 0) {\n            return `(insert@${this.oldPosition} \"${escapeNewLine(this.newText)}\")`;\n        }\n        if (this.newText.length === 0) {\n            return `(delete@${this.oldPosition} \"${escapeNewLine(this.oldText)}\")`;\n        }\n        return `(replace@${this.oldPosition} \"${escapeNewLine(this.oldText)}\" with \"${escapeNewLine(this.newText)}\")`;\n    }\n    static _writeStringSize(str) {\n        return (4 + 2 * str.length);\n    }\n    static _writeString(b, str, offset) {\n        const len = str.length;\n        buffer.writeUInt32BE(b, len, offset);\n        offset += 4;\n        for (let i = 0; i < len; i++) {\n            buffer.writeUInt16LE(b, str.charCodeAt(i), offset);\n            offset += 2;\n        }\n        return offset;\n    }\n    static _readString(b, offset) {\n        const len = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        return decodeUTF16LE(b, offset, len);\n    }\n    writeSize() {\n        return (+4 // oldPosition\n            + 4 // newPosition\n            + TextChange._writeStringSize(this.oldText)\n            + TextChange._writeStringSize(this.newText));\n    }\n    write(b, offset) {\n        buffer.writeUInt32BE(b, this.oldPosition, offset);\n        offset += 4;\n        buffer.writeUInt32BE(b, this.newPosition, offset);\n        offset += 4;\n        offset = TextChange._writeString(b, this.oldText, offset);\n        offset = TextChange._writeString(b, this.newText, offset);\n        return offset;\n    }\n    static read(b, offset, dest) {\n        const oldPosition = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const newPosition = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const oldText = TextChange._readString(b, offset);\n        offset += TextChange._writeStringSize(oldText);\n        const newText = TextChange._readString(b, offset);\n        offset += TextChange._writeStringSize(newText);\n        dest.push(new TextChange(oldPosition, oldText, newPosition, newText));\n        return offset;\n    }\n}\nexport function compressConsecutiveTextChanges(prevEdits, currEdits) {\n    if (prevEdits === null || prevEdits.length === 0) {\n        return currEdits;\n    }\n    const compressor = new TextChangeCompressor(prevEdits, currEdits);\n    return compressor.compress();\n}\nclass TextChangeCompressor {\n    constructor(prevEdits, currEdits) {\n        this._prevEdits = prevEdits;\n        this._currEdits = currEdits;\n        this._result = [];\n        this._resultLen = 0;\n        this._prevLen = this._prevEdits.length;\n        this._prevDeltaOffset = 0;\n        this._currLen = this._currEdits.length;\n        this._currDeltaOffset = 0;\n    }\n    compress() {\n        let prevIndex = 0;\n        let currIndex = 0;\n        let prevEdit = this._getPrev(prevIndex);\n        let currEdit = this._getCurr(currIndex);\n        while (prevIndex < this._prevLen || currIndex < this._currLen) {\n            if (prevEdit === null) {\n                this._acceptCurr(currEdit);\n                currEdit = this._getCurr(++currIndex);\n                continue;\n            }\n            if (currEdit === null) {\n                this._acceptPrev(prevEdit);\n                prevEdit = this._getPrev(++prevIndex);\n                continue;\n            }\n            if (currEdit.oldEnd <= prevEdit.newPosition) {\n                this._acceptCurr(currEdit);\n                currEdit = this._getCurr(++currIndex);\n                continue;\n            }\n            if (prevEdit.newEnd <= currEdit.oldPosition) {\n                this._acceptPrev(prevEdit);\n                prevEdit = this._getPrev(++prevIndex);\n                continue;\n            }\n            if (currEdit.oldPosition < prevEdit.newPosition) {\n                const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newPosition - currEdit.oldPosition);\n                this._acceptCurr(e1);\n                currEdit = e2;\n                continue;\n            }\n            if (prevEdit.newPosition < currEdit.oldPosition) {\n                const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldPosition - prevEdit.newPosition);\n                this._acceptPrev(e1);\n                prevEdit = e2;\n                continue;\n            }\n            // At this point, currEdit.oldPosition === prevEdit.newPosition\n            let mergePrev;\n            let mergeCurr;\n            if (currEdit.oldEnd === prevEdit.newEnd) {\n                mergePrev = prevEdit;\n                mergeCurr = currEdit;\n                prevEdit = this._getPrev(++prevIndex);\n                currEdit = this._getCurr(++currIndex);\n            }\n            else if (currEdit.oldEnd < prevEdit.newEnd) {\n                const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldLength);\n                mergePrev = e1;\n                mergeCurr = currEdit;\n                prevEdit = e2;\n                currEdit = this._getCurr(++currIndex);\n            }\n            else {\n                const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newLength);\n                mergePrev = prevEdit;\n                mergeCurr = e1;\n                prevEdit = this._getPrev(++prevIndex);\n                currEdit = e2;\n            }\n            this._result[this._resultLen++] = new TextChange(mergePrev.oldPosition, mergePrev.oldText, mergeCurr.newPosition, mergeCurr.newText);\n            this._prevDeltaOffset += mergePrev.newLength - mergePrev.oldLength;\n            this._currDeltaOffset += mergeCurr.newLength - mergeCurr.oldLength;\n        }\n        const merged = TextChangeCompressor._merge(this._result);\n        const cleaned = TextChangeCompressor._removeNoOps(merged);\n        return cleaned;\n    }\n    _acceptCurr(currEdit) {\n        this._result[this._resultLen++] = TextChangeCompressor._rebaseCurr(this._prevDeltaOffset, currEdit);\n        this._currDeltaOffset += currEdit.newLength - currEdit.oldLength;\n    }\n    _getCurr(currIndex) {\n        return (currIndex < this._currLen ? this._currEdits[currIndex] : null);\n    }\n    _acceptPrev(prevEdit) {\n        this._result[this._resultLen++] = TextChangeCompressor._rebasePrev(this._currDeltaOffset, prevEdit);\n        this._prevDeltaOffset += prevEdit.newLength - prevEdit.oldLength;\n    }\n    _getPrev(prevIndex) {\n        return (prevIndex < this._prevLen ? this._prevEdits[prevIndex] : null);\n    }\n    static _rebaseCurr(prevDeltaOffset, currEdit) {\n        return new TextChange(currEdit.oldPosition - prevDeltaOffset, currEdit.oldText, currEdit.newPosition, currEdit.newText);\n    }\n    static _rebasePrev(currDeltaOffset, prevEdit) {\n        return new TextChange(prevEdit.oldPosition, prevEdit.oldText, prevEdit.newPosition + currDeltaOffset, prevEdit.newText);\n    }\n    static _splitPrev(edit, offset) {\n        const preText = edit.newText.substr(0, offset);\n        const postText = edit.newText.substr(offset);\n        return [\n            new TextChange(edit.oldPosition, edit.oldText, edit.newPosition, preText),\n            new TextChange(edit.oldEnd, '', edit.newPosition + offset, postText)\n        ];\n    }\n    static _splitCurr(edit, offset) {\n        const preText = edit.oldText.substr(0, offset);\n        const postText = edit.oldText.substr(offset);\n        return [\n            new TextChange(edit.oldPosition, preText, edit.newPosition, edit.newText),\n            new TextChange(edit.oldPosition + offset, postText, edit.newEnd, '')\n        ];\n    }\n    static _merge(edits) {\n        if (edits.length === 0) {\n            return edits;\n        }\n        const result = [];\n        let resultLen = 0;\n        let prev = edits[0];\n        for (let i = 1; i < edits.length; i++) {\n            const curr = edits[i];\n            if (prev.oldEnd === curr.oldPosition) {\n                // Merge into `prev`\n                prev = new TextChange(prev.oldPosition, prev.oldText + curr.oldText, prev.newPosition, prev.newText + curr.newText);\n            }\n            else {\n                result[resultLen++] = prev;\n                prev = curr;\n            }\n        }\n        result[resultLen++] = prev;\n        return result;\n    }\n    static _removeNoOps(edits) {\n        if (edits.length === 0) {\n            return edits;\n        }\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0; i < edits.length; i++) {\n            const edit = edits[i];\n            if (edit.oldText === edit.newText) {\n                continue;\n            }\n            result[resultLen++] = edit;\n        }\n        return result;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport const EDITOR_MODEL_DEFAULTS = {\n    tabSize: 4,\n    indentSize: 4,\n    insertSpaces: true,\n    detectIndentation: true,\n    trimAutoWhitespace: true,\n    largeFileOptimizations: true,\n    bracketPairColorizationOptions: {\n        enabled: true,\n        independentColorPoolPerBracketType: false,\n    },\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Describes what to do with the indentation when pressing Enter.\n */\nexport var IndentAction;\n(function (IndentAction) {\n    /**\n     * Insert new line and copy the previous line's indentation.\n     */\n    IndentAction[IndentAction[\"None\"] = 0] = \"None\";\n    /**\n     * Insert new line and indent once (relative to the previous line's indentation).\n     */\n    IndentAction[IndentAction[\"Indent\"] = 1] = \"Indent\";\n    /**\n     * Insert two new lines:\n     *  - the first one indented which will hold the cursor\n     *  - the second one at the same indentation level\n     */\n    IndentAction[IndentAction[\"IndentOutdent\"] = 2] = \"IndentOutdent\";\n    /**\n     * Insert new line and outdent once (relative to the previous line's indentation).\n     */\n    IndentAction[IndentAction[\"Outdent\"] = 3] = \"Outdent\";\n})(IndentAction || (IndentAction = {}));\n/**\n * @internal\n */\nexport class StandardAutoClosingPairConditional {\n    constructor(source) {\n        this._neutralCharacter = null;\n        this._neutralCharacterSearched = false;\n        this.open = source.open;\n        this.close = source.close;\n        // initially allowed in all tokens\n        this._inString = true;\n        this._inComment = true;\n        this._inRegEx = true;\n        if (Array.isArray(source.notIn)) {\n            for (let i = 0, len = source.notIn.length; i < len; i++) {\n                const notIn = source.notIn[i];\n                switch (notIn) {\n                    case 'string':\n                        this._inString = false;\n                        break;\n                    case 'comment':\n                        this._inComment = false;\n                        break;\n                    case 'regex':\n                        this._inRegEx = false;\n                        break;\n                }\n            }\n        }\n    }\n    isOK(standardToken) {\n        switch (standardToken) {\n            case 0 /* StandardTokenType.Other */:\n                return true;\n            case 1 /* StandardTokenType.Comment */:\n                return this._inComment;\n            case 2 /* StandardTokenType.String */:\n                return this._inString;\n            case 3 /* StandardTokenType.RegEx */:\n                return this._inRegEx;\n        }\n    }\n    shouldAutoClose(context, column) {\n        // Always complete on empty line\n        if (context.getTokenCount() === 0) {\n            return true;\n        }\n        const tokenIndex = context.findTokenIndexAtOffset(column - 2);\n        const standardTokenType = context.getStandardTokenType(tokenIndex);\n        return this.isOK(standardTokenType);\n    }\n    _findNeutralCharacterInRange(fromCharCode, toCharCode) {\n        for (let charCode = fromCharCode; charCode <= toCharCode; charCode++) {\n            const character = String.fromCharCode(charCode);\n            if (!this.open.includes(character) && !this.close.includes(character)) {\n                return character;\n            }\n        }\n        return null;\n    }\n    /**\n     * Find a character in the range [0-9a-zA-Z] that does not appear in the open or close\n     */\n    findNeutralCharacter() {\n        if (!this._neutralCharacterSearched) {\n            this._neutralCharacterSearched = true;\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(48 /* CharCode.Digit0 */, 57 /* CharCode.Digit9 */);\n            }\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(97 /* CharCode.a */, 122 /* CharCode.z */);\n            }\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(65 /* CharCode.A */, 90 /* CharCode.Z */);\n            }\n        }\n        return this._neutralCharacter;\n    }\n}\n/**\n * @internal\n */\nexport class AutoClosingPairs {\n    constructor(autoClosingPairs) {\n        this.autoClosingPairsOpenByStart = new Map();\n        this.autoClosingPairsOpenByEnd = new Map();\n        this.autoClosingPairsCloseByStart = new Map();\n        this.autoClosingPairsCloseByEnd = new Map();\n        this.autoClosingPairsCloseSingleChar = new Map();\n        for (const pair of autoClosingPairs) {\n            appendEntry(this.autoClosingPairsOpenByStart, pair.open.charAt(0), pair);\n            appendEntry(this.autoClosingPairsOpenByEnd, pair.open.charAt(pair.open.length - 1), pair);\n            appendEntry(this.autoClosingPairsCloseByStart, pair.close.charAt(0), pair);\n            appendEntry(this.autoClosingPairsCloseByEnd, pair.close.charAt(pair.close.length - 1), pair);\n            if (pair.close.length === 1 && pair.open.length === 1) {\n                appendEntry(this.autoClosingPairsCloseSingleChar, pair.close, pair);\n            }\n        }\n    }\n}\nfunction appendEntry(target, key, value) {\n    if (target.has(key)) {\n        target.get(key).push(value);\n    }\n    else {\n        target.set(key, [value]);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { StandardAutoClosingPairConditional } from '../languageConfiguration.js';\nexport class CharacterPairSupport {\n    static { this.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES = ';:.,=}])> \\n\\t'; }\n    static { this.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS = '\\'\"`;:.,=}])> \\n\\t'; }\n    constructor(config) {\n        if (config.autoClosingPairs) {\n            this._autoClosingPairs = config.autoClosingPairs.map(el => new StandardAutoClosingPairConditional(el));\n        }\n        else if (config.brackets) {\n            this._autoClosingPairs = config.brackets.map(b => new StandardAutoClosingPairConditional({ open: b[0], close: b[1] }));\n        }\n        else {\n            this._autoClosingPairs = [];\n        }\n        if (config.__electricCharacterSupport && config.__electricCharacterSupport.docComment) {\n            const docComment = config.__electricCharacterSupport.docComment;\n            // IDocComment is legacy, only partially supported\n            this._autoClosingPairs.push(new StandardAutoClosingPairConditional({ open: docComment.open, close: docComment.close || '' }));\n        }\n        this._autoCloseBeforeForQuotes = typeof config.autoCloseBefore === 'string' ? config.autoCloseBefore : CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES;\n        this._autoCloseBeforeForBrackets = typeof config.autoCloseBefore === 'string' ? config.autoCloseBefore : CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS;\n        this._surroundingPairs = config.surroundingPairs || this._autoClosingPairs;\n    }\n    getAutoClosingPairs() {\n        return this._autoClosingPairs;\n    }\n    getAutoCloseBeforeSet(forQuotes) {\n        return (forQuotes ? this._autoCloseBeforeForQuotes : this._autoCloseBeforeForBrackets);\n    }\n    getSurroundingPairs() {\n        return this._surroundingPairs;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { distinct } from '../../../../base/common/arrays.js';\nimport { ignoreBracketsInToken } from '../supports.js';\nimport { BracketsUtils } from './richEditBrackets.js';\nexport class BracketElectricCharacterSupport {\n    constructor(richEditBrackets) {\n        this._richEditBrackets = richEditBrackets;\n    }\n    getElectricCharacters() {\n        const result = [];\n        if (this._richEditBrackets) {\n            for (const bracket of this._richEditBrackets.brackets) {\n                for (const close of bracket.close) {\n                    const lastChar = close.charAt(close.length - 1);\n                    result.push(lastChar);\n                }\n            }\n        }\n        return distinct(result);\n    }\n    onElectricCharacter(character, context, column) {\n        if (!this._richEditBrackets || this._richEditBrackets.brackets.length === 0) {\n            return null;\n        }\n        const tokenIndex = context.findTokenIndexAtOffset(column - 1);\n        if (ignoreBracketsInToken(context.getStandardTokenType(tokenIndex))) {\n            return null;\n        }\n        const reversedBracketRegex = this._richEditBrackets.reversedRegex;\n        const text = context.getLineContent().substring(0, column - 1) + character;\n        const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, 1, text, 0, text.length);\n        if (!r) {\n            return null;\n        }\n        const bracketText = text.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n        const isOpen = this._richEditBrackets.textIsOpenBracket[bracketText];\n        if (isOpen) {\n            return null;\n        }\n        const textBeforeBracket = context.getActualLineContentBefore(r.startColumn - 1);\n        if (!/^\\s*$/.test(textBeforeBracket)) {\n            // There is other text on the line before the bracket\n            return null;\n        }\n        return {\n            matchOpenBracket: bracketText\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction resetGlobalRegex(reg) {\n    if (reg.global) {\n        reg.lastIndex = 0;\n    }\n    return true;\n}\nexport class IndentRulesSupport {\n    constructor(indentationRules) {\n        this._indentationRules = indentationRules;\n    }\n    shouldIncrease(text) {\n        if (this._indentationRules) {\n            if (this._indentationRules.increaseIndentPattern && resetGlobalRegex(this._indentationRules.increaseIndentPattern) && this._indentationRules.increaseIndentPattern.test(text)) {\n                return true;\n            }\n            // if (this._indentationRules.indentNextLinePattern && this._indentationRules.indentNextLinePattern.test(text)) {\n            // \treturn true;\n            // }\n        }\n        return false;\n    }\n    shouldDecrease(text) {\n        if (this._indentationRules && this._indentationRules.decreaseIndentPattern && resetGlobalRegex(this._indentationRules.decreaseIndentPattern) && this._indentationRules.decreaseIndentPattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    shouldIndentNextLine(text) {\n        if (this._indentationRules && this._indentationRules.indentNextLinePattern && resetGlobalRegex(this._indentationRules.indentNextLinePattern) && this._indentationRules.indentNextLinePattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    shouldIgnore(text) {\n        // the text matches `unIndentedLinePattern`\n        if (this._indentationRules && this._indentationRules.unIndentedLinePattern && resetGlobalRegex(this._indentationRules.unIndentedLinePattern) && this._indentationRules.unIndentedLinePattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    getIndentMetadata(text) {\n        let ret = 0;\n        if (this.shouldIncrease(text)) {\n            ret += 1 /* IndentConsts.INCREASE_MASK */;\n        }\n        if (this.shouldDecrease(text)) {\n            ret += 2 /* IndentConsts.DECREASE_MASK */;\n        }\n        if (this.shouldIndentNextLine(text)) {\n            ret += 4 /* IndentConsts.INDENT_NEXTLINE_MASK */;\n        }\n        if (this.shouldIgnore(text)) {\n            ret += 8 /* IndentConsts.UNINDENT_MASK */;\n        }\n        return ret;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../../base/common/errors.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { IndentAction } from '../languageConfiguration.js';\nexport class OnEnterSupport {\n    constructor(opts) {\n        opts = opts || {};\n        opts.brackets = opts.brackets || [\n            ['(', ')'],\n            ['{', '}'],\n            ['[', ']']\n        ];\n        this._brackets = [];\n        opts.brackets.forEach((bracket) => {\n            const openRegExp = OnEnterSupport._createOpenBracketRegExp(bracket[0]);\n            const closeRegExp = OnEnterSupport._createCloseBracketRegExp(bracket[1]);\n            if (openRegExp && closeRegExp) {\n                this._brackets.push({\n                    open: bracket[0],\n                    openRegExp: openRegExp,\n                    close: bracket[1],\n                    closeRegExp: closeRegExp,\n                });\n            }\n        });\n        this._regExpRules = opts.onEnterRules || [];\n    }\n    onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {\n        // (1): `regExpRules`\n        if (autoIndent >= 3 /* EditorAutoIndentStrategy.Advanced */) {\n            for (let i = 0, len = this._regExpRules.length; i < len; i++) {\n                const rule = this._regExpRules[i];\n                const regResult = [{\n                        reg: rule.beforeText,\n                        text: beforeEnterText\n                    }, {\n                        reg: rule.afterText,\n                        text: afterEnterText\n                    }, {\n                        reg: rule.previousLineText,\n                        text: previousLineText\n                    }].every((obj) => {\n                    if (!obj.reg) {\n                        return true;\n                    }\n                    obj.reg.lastIndex = 0; // To disable the effect of the \"g\" flag.\n                    return obj.reg.test(obj.text);\n                });\n                if (regResult) {\n                    return rule.action;\n                }\n            }\n        }\n        // (2): Special indent-outdent\n        if (autoIndent >= 2 /* EditorAutoIndentStrategy.Brackets */) {\n            if (beforeEnterText.length > 0 && afterEnterText.length > 0) {\n                for (let i = 0, len = this._brackets.length; i < len; i++) {\n                    const bracket = this._brackets[i];\n                    if (bracket.openRegExp.test(beforeEnterText) && bracket.closeRegExp.test(afterEnterText)) {\n                        return { indentAction: IndentAction.IndentOutdent };\n                    }\n                }\n            }\n        }\n        // (4): Open bracket based logic\n        if (autoIndent >= 2 /* EditorAutoIndentStrategy.Brackets */) {\n            if (beforeEnterText.length > 0) {\n                for (let i = 0, len = this._brackets.length; i < len; i++) {\n                    const bracket = this._brackets[i];\n                    if (bracket.openRegExp.test(beforeEnterText)) {\n                        return { indentAction: IndentAction.Indent };\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    static _createOpenBracketRegExp(bracket) {\n        let str = strings.escapeRegExpCharacters(bracket);\n        if (!/\\B/.test(str.charAt(0))) {\n            str = '\\\\b' + str;\n        }\n        str += '\\\\s*$';\n        return OnEnterSupport._safeRegExp(str);\n    }\n    static _createCloseBracketRegExp(bracket) {\n        let str = strings.escapeRegExpCharacters(bracket);\n        if (!/\\B/.test(str.charAt(str.length - 1))) {\n            str = str + '\\\\b';\n        }\n        str = '^\\\\s*' + str;\n        return OnEnterSupport._safeRegExp(str);\n    }\n    static _safeRegExp(def) {\n        try {\n            return new RegExp(def);\n        }\n        catch (err) {\n            onUnexpectedError(err);\n            return null;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CachedFunction } from '../../../../base/common/cache.js';\nimport { createBracketOrRegExp } from './richEditBrackets.js';\n/**\n * Captures all bracket related configurations for a single language.\n * Immutable.\n*/\nexport class LanguageBracketsConfiguration {\n    constructor(languageId, config) {\n        this.languageId = languageId;\n        const bracketPairs = config.brackets ? filterValidBrackets(config.brackets) : [];\n        const openingBracketInfos = new CachedFunction((bracket) => {\n            const closing = new Set();\n            return {\n                info: new OpeningBracketKind(this, bracket, closing),\n                closing,\n            };\n        });\n        const closingBracketInfos = new CachedFunction((bracket) => {\n            const opening = new Set();\n            const openingColorized = new Set();\n            return {\n                info: new ClosingBracketKind(this, bracket, opening, openingColorized),\n                opening,\n                openingColorized,\n            };\n        });\n        for (const [open, close] of bracketPairs) {\n            const opening = openingBracketInfos.get(open);\n            const closing = closingBracketInfos.get(close);\n            opening.closing.add(closing.info);\n            closing.opening.add(opening.info);\n        }\n        // Treat colorized brackets as brackets, and mark them as colorized.\n        const colorizedBracketPairs = config.colorizedBracketPairs\n            ? filterValidBrackets(config.colorizedBracketPairs)\n            // If not configured: Take all brackets except `<` ... `>`\n            // Many languages set < ... > as bracket pair, even though they also use it as comparison operator.\n            // This leads to problems when colorizing this bracket, so we exclude it if not explicitly configured otherwise.\n            // https://github.com/microsoft/vscode/issues/132476\n            : bracketPairs.filter((p) => !(p[0] === '<' && p[1] === '>'));\n        for (const [open, close] of colorizedBracketPairs) {\n            const opening = openingBracketInfos.get(open);\n            const closing = closingBracketInfos.get(close);\n            opening.closing.add(closing.info);\n            closing.openingColorized.add(opening.info);\n            closing.opening.add(opening.info);\n        }\n        this._openingBrackets = new Map([...openingBracketInfos.cachedValues].map(([k, v]) => [k, v.info]));\n        this._closingBrackets = new Map([...closingBracketInfos.cachedValues].map(([k, v]) => [k, v.info]));\n    }\n    /**\n     * No two brackets have the same bracket text.\n    */\n    get openingBrackets() {\n        return [...this._openingBrackets.values()];\n    }\n    /**\n     * No two brackets have the same bracket text.\n    */\n    get closingBrackets() {\n        return [...this._closingBrackets.values()];\n    }\n    getOpeningBracketInfo(bracketText) {\n        return this._openingBrackets.get(bracketText);\n    }\n    getClosingBracketInfo(bracketText) {\n        return this._closingBrackets.get(bracketText);\n    }\n    getBracketInfo(bracketText) {\n        return this.getOpeningBracketInfo(bracketText) || this.getClosingBracketInfo(bracketText);\n    }\n    getBracketRegExp(options) {\n        const brackets = Array.from([...this._openingBrackets.keys(), ...this._closingBrackets.keys()]);\n        return createBracketOrRegExp(brackets, options);\n    }\n}\nfunction filterValidBrackets(bracketPairs) {\n    return bracketPairs.filter(([open, close]) => open !== '' && close !== '');\n}\nexport class BracketKindBase {\n    constructor(config, bracketText) {\n        this.config = config;\n        this.bracketText = bracketText;\n    }\n    get languageId() {\n        return this.config.languageId;\n    }\n}\nexport class OpeningBracketKind extends BracketKindBase {\n    constructor(config, bracketText, openedBrackets) {\n        super(config, bracketText);\n        this.openedBrackets = openedBrackets;\n        this.isOpeningBracket = true;\n    }\n}\nexport class ClosingBracketKind extends BracketKindBase {\n    constructor(config, bracketText, \n    /**\n     * Non empty array of all opening brackets this bracket closes.\n    */\n    openingBrackets, openingColorizedBrackets) {\n        super(config, bracketText);\n        this.openingBrackets = openingBrackets;\n        this.openingColorizedBrackets = openingColorizedBrackets;\n        this.isOpeningBracket = false;\n    }\n    /**\n     * Checks if this bracket closes the given other bracket.\n     * If the bracket infos come from different configurations, this method will return false.\n    */\n    closes(other) {\n        if (other['config'] !== this.config) {\n            return false;\n        }\n        return this.openingBrackets.has(other);\n    }\n    closesColorized(other) {\n        if (other['config'] !== this.config) {\n            return false;\n        }\n        return this.openingColorizedBrackets.has(other);\n    }\n    getOpeningBrackets() {\n        return [...this.openingBrackets];\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { DEFAULT_WORD_REGEXP, ensureValidWordDefinition } from '../core/wordHelper.js';\nimport { AutoClosingPairs } from './languageConfiguration.js';\nimport { CharacterPairSupport } from './supports/characterPair.js';\nimport { BracketElectricCharacterSupport } from './supports/electricCharacter.js';\nimport { IndentRulesSupport } from './supports/indentRules.js';\nimport { OnEnterSupport } from './supports/onEnter.js';\nimport { RichEditBrackets } from './supports/richEditBrackets.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { ILanguageService } from './language.js';\nimport { registerSingleton } from '../../../platform/instantiation/common/extensions.js';\nimport { PLAINTEXT_LANGUAGE_ID } from './modesRegistry.js';\nimport { LanguageBracketsConfiguration } from './supports/languageBracketsConfiguration.js';\nexport class LanguageConfigurationServiceChangeEvent {\n    constructor(languageId) {\n        this.languageId = languageId;\n    }\n    affects(languageId) {\n        return !this.languageId ? true : this.languageId === languageId;\n    }\n}\nexport const ILanguageConfigurationService = createDecorator('languageConfigurationService');\nlet LanguageConfigurationService = class LanguageConfigurationService extends Disposable {\n    constructor(configurationService, languageService) {\n        super();\n        this.configurationService = configurationService;\n        this.languageService = languageService;\n        this._registry = this._register(new LanguageConfigurationRegistry());\n        this.onDidChangeEmitter = this._register(new Emitter());\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.configurations = new Map();\n        const languageConfigKeys = new Set(Object.values(customizedLanguageConfigKeys));\n        this._register(this.configurationService.onDidChangeConfiguration((e) => {\n            const globalConfigChanged = e.change.keys.some((k) => languageConfigKeys.has(k));\n            const localConfigChanged = e.change.overrides\n                .filter(([overrideLangName, keys]) => keys.some((k) => languageConfigKeys.has(k)))\n                .map(([overrideLangName]) => overrideLangName);\n            if (globalConfigChanged) {\n                this.configurations.clear();\n                this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(undefined));\n            }\n            else {\n                for (const languageId of localConfigChanged) {\n                    if (this.languageService.isRegisteredLanguageId(languageId)) {\n                        this.configurations.delete(languageId);\n                        this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(languageId));\n                    }\n                }\n            }\n        }));\n        this._register(this._registry.onDidChange((e) => {\n            this.configurations.delete(e.languageId);\n            this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(e.languageId));\n        }));\n    }\n    register(languageId, configuration, priority) {\n        return this._registry.register(languageId, configuration, priority);\n    }\n    getLanguageConfiguration(languageId) {\n        let result = this.configurations.get(languageId);\n        if (!result) {\n            result = computeConfig(languageId, this._registry, this.configurationService, this.languageService);\n            this.configurations.set(languageId, result);\n        }\n        return result;\n    }\n};\nLanguageConfigurationService = __decorate([\n    __param(0, IConfigurationService),\n    __param(1, ILanguageService)\n], LanguageConfigurationService);\nexport { LanguageConfigurationService };\nfunction computeConfig(languageId, registry, configurationService, languageService) {\n    let languageConfig = registry.getLanguageConfiguration(languageId);\n    if (!languageConfig) {\n        if (!languageService.isRegisteredLanguageId(languageId)) {\n            // this happens for the null language, which can be returned by monarch.\n            // Instead of throwing an error, we just return a default config.\n            return new ResolvedLanguageConfiguration(languageId, {});\n        }\n        languageConfig = new ResolvedLanguageConfiguration(languageId, {});\n    }\n    const customizedConfig = getCustomizedLanguageConfig(languageConfig.languageId, configurationService);\n    const data = combineLanguageConfigurations([languageConfig.underlyingConfig, customizedConfig]);\n    const config = new ResolvedLanguageConfiguration(languageConfig.languageId, data);\n    return config;\n}\nconst customizedLanguageConfigKeys = {\n    brackets: 'editor.language.brackets',\n    colorizedBracketPairs: 'editor.language.colorizedBracketPairs'\n};\nfunction getCustomizedLanguageConfig(languageId, configurationService) {\n    const brackets = configurationService.getValue(customizedLanguageConfigKeys.brackets, {\n        overrideIdentifier: languageId,\n    });\n    const colorizedBracketPairs = configurationService.getValue(customizedLanguageConfigKeys.colorizedBracketPairs, {\n        overrideIdentifier: languageId,\n    });\n    return {\n        brackets: validateBracketPairs(brackets),\n        colorizedBracketPairs: validateBracketPairs(colorizedBracketPairs),\n    };\n}\nfunction validateBracketPairs(data) {\n    if (!Array.isArray(data)) {\n        return undefined;\n    }\n    return data.map(pair => {\n        if (!Array.isArray(pair) || pair.length !== 2) {\n            return undefined;\n        }\n        return [pair[0], pair[1]];\n    }).filter((p) => !!p);\n}\nexport function getIndentationAtPosition(model, lineNumber, column) {\n    const lineText = model.getLineContent(lineNumber);\n    let indentation = strings.getLeadingWhitespace(lineText);\n    if (indentation.length > column - 1) {\n        indentation = indentation.substring(0, column - 1);\n    }\n    return indentation;\n}\nclass ComposedLanguageConfiguration {\n    constructor(languageId) {\n        this.languageId = languageId;\n        this._resolved = null;\n        this._entries = [];\n        this._order = 0;\n        this._resolved = null;\n    }\n    register(configuration, priority) {\n        const entry = new LanguageConfigurationContribution(configuration, priority, ++this._order);\n        this._entries.push(entry);\n        this._resolved = null;\n        return toDisposable(() => {\n            for (let i = 0; i < this._entries.length; i++) {\n                if (this._entries[i] === entry) {\n                    this._entries.splice(i, 1);\n                    this._resolved = null;\n                    break;\n                }\n            }\n        });\n    }\n    getResolvedConfiguration() {\n        if (!this._resolved) {\n            const config = this._resolve();\n            if (config) {\n                this._resolved = new ResolvedLanguageConfiguration(this.languageId, config);\n            }\n        }\n        return this._resolved;\n    }\n    _resolve() {\n        if (this._entries.length === 0) {\n            return null;\n        }\n        this._entries.sort(LanguageConfigurationContribution.cmp);\n        return combineLanguageConfigurations(this._entries.map(e => e.configuration));\n    }\n}\nfunction combineLanguageConfigurations(configs) {\n    let result = {\n        comments: undefined,\n        brackets: undefined,\n        wordPattern: undefined,\n        indentationRules: undefined,\n        onEnterRules: undefined,\n        autoClosingPairs: undefined,\n        surroundingPairs: undefined,\n        autoCloseBefore: undefined,\n        folding: undefined,\n        colorizedBracketPairs: undefined,\n        __electricCharacterSupport: undefined,\n    };\n    for (const entry of configs) {\n        result = {\n            comments: entry.comments || result.comments,\n            brackets: entry.brackets || result.brackets,\n            wordPattern: entry.wordPattern || result.wordPattern,\n            indentationRules: entry.indentationRules || result.indentationRules,\n            onEnterRules: entry.onEnterRules || result.onEnterRules,\n            autoClosingPairs: entry.autoClosingPairs || result.autoClosingPairs,\n            surroundingPairs: entry.surroundingPairs || result.surroundingPairs,\n            autoCloseBefore: entry.autoCloseBefore || result.autoCloseBefore,\n            folding: entry.folding || result.folding,\n            colorizedBracketPairs: entry.colorizedBracketPairs || result.colorizedBracketPairs,\n            __electricCharacterSupport: entry.__electricCharacterSupport || result.__electricCharacterSupport,\n        };\n    }\n    return result;\n}\nclass LanguageConfigurationContribution {\n    constructor(configuration, priority, order) {\n        this.configuration = configuration;\n        this.priority = priority;\n        this.order = order;\n    }\n    static cmp(a, b) {\n        if (a.priority === b.priority) {\n            // higher order last\n            return a.order - b.order;\n        }\n        // higher priority last\n        return a.priority - b.priority;\n    }\n}\nexport class LanguageConfigurationChangeEvent {\n    constructor(languageId) {\n        this.languageId = languageId;\n    }\n}\nexport class LanguageConfigurationRegistry extends Disposable {\n    constructor() {\n        super();\n        this._entries = new Map();\n        this._onDidChange = this._register(new Emitter());\n        this.onDidChange = this._onDidChange.event;\n        this._register(this.register(PLAINTEXT_LANGUAGE_ID, {\n            brackets: [\n                ['(', ')'],\n                ['[', ']'],\n                ['{', '}'],\n            ],\n            surroundingPairs: [\n                { open: '{', close: '}' },\n                { open: '[', close: ']' },\n                { open: '(', close: ')' },\n                { open: '<', close: '>' },\n                { open: '\\\"', close: '\\\"' },\n                { open: '\\'', close: '\\'' },\n                { open: '`', close: '`' },\n            ],\n            colorizedBracketPairs: [],\n            folding: {\n                offSide: true\n            }\n        }, 0));\n    }\n    /**\n     * @param priority Use a higher number for higher priority\n     */\n    register(languageId, configuration, priority = 0) {\n        let entries = this._entries.get(languageId);\n        if (!entries) {\n            entries = new ComposedLanguageConfiguration(languageId);\n            this._entries.set(languageId, entries);\n        }\n        const disposable = entries.register(configuration, priority);\n        this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageId));\n        return toDisposable(() => {\n            disposable.dispose();\n            this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageId));\n        });\n    }\n    getLanguageConfiguration(languageId) {\n        const entries = this._entries.get(languageId);\n        return entries?.getResolvedConfiguration() || null;\n    }\n}\n/**\n * Immutable.\n*/\nexport class ResolvedLanguageConfiguration {\n    constructor(languageId, underlyingConfig) {\n        this.languageId = languageId;\n        this.underlyingConfig = underlyingConfig;\n        this._brackets = null;\n        this._electricCharacter = null;\n        this._onEnterSupport =\n            this.underlyingConfig.brackets ||\n                this.underlyingConfig.indentationRules ||\n                this.underlyingConfig.onEnterRules\n                ? new OnEnterSupport(this.underlyingConfig)\n                : null;\n        this.comments = ResolvedLanguageConfiguration._handleComments(this.underlyingConfig);\n        this.characterPair = new CharacterPairSupport(this.underlyingConfig);\n        this.wordDefinition = this.underlyingConfig.wordPattern || DEFAULT_WORD_REGEXP;\n        this.indentationRules = this.underlyingConfig.indentationRules;\n        if (this.underlyingConfig.indentationRules) {\n            this.indentRulesSupport = new IndentRulesSupport(this.underlyingConfig.indentationRules);\n        }\n        else {\n            this.indentRulesSupport = null;\n        }\n        this.foldingRules = this.underlyingConfig.folding || {};\n        this.bracketsNew = new LanguageBracketsConfiguration(languageId, this.underlyingConfig);\n    }\n    getWordDefinition() {\n        return ensureValidWordDefinition(this.wordDefinition);\n    }\n    get brackets() {\n        if (!this._brackets && this.underlyingConfig.brackets) {\n            this._brackets = new RichEditBrackets(this.languageId, this.underlyingConfig.brackets);\n        }\n        return this._brackets;\n    }\n    get electricCharacter() {\n        if (!this._electricCharacter) {\n            this._electricCharacter = new BracketElectricCharacterSupport(this.brackets);\n        }\n        return this._electricCharacter;\n    }\n    onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {\n        if (!this._onEnterSupport) {\n            return null;\n        }\n        return this._onEnterSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);\n    }\n    getAutoClosingPairs() {\n        return new AutoClosingPairs(this.characterPair.getAutoClosingPairs());\n    }\n    getAutoCloseBeforeSet(forQuotes) {\n        return this.characterPair.getAutoCloseBeforeSet(forQuotes);\n    }\n    getSurroundingPairs() {\n        return this.characterPair.getSurroundingPairs();\n    }\n    static _handleComments(conf) {\n        const commentRule = conf.comments;\n        if (!commentRule) {\n            return null;\n        }\n        // comment configuration\n        const comments = {};\n        if (commentRule.lineComment) {\n            comments.lineCommentToken = commentRule.lineComment;\n        }\n        if (commentRule.blockComment) {\n            const [blockStart, blockEnd] = commentRule.blockComment;\n            comments.blockCommentStartToken = blockStart;\n            comments.blockCommentEndToken = blockEnd;\n        }\n        return comments;\n    }\n}\nregisterSingleton(ILanguageConfigurationService, LanguageConfigurationService, 1 /* InstantiationType.Delayed */);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Token, TokenizationResult, EncodedTokenizationResult } from '../languages.js';\nexport const NullState = new class {\n    clone() {\n        return this;\n    }\n    equals(other) {\n        return (this === other);\n    }\n};\nexport function nullTokenize(languageId, state) {\n    return new TokenizationResult([new Token(0, '', languageId)], state);\n}\nexport function nullTokenizeEncoded(languageId, state) {\n    const tokens = new Uint32Array(2);\n    tokens[0] = 0;\n    tokens[1] = ((languageId << 0 /* MetadataConsts.LANGUAGEID_OFFSET */)\n        | (0 /* StandardTokenType.Other */ << 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */)\n        | (0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n        | (1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n        | (2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0;\n    return new EncodedTokenizationResult(tokens, state === null ? NullState : state);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function createScopedLineTokens(context, offset) {\n    const tokenCount = context.getCount();\n    const tokenIndex = context.findTokenIndexAtOffset(offset);\n    const desiredLanguageId = context.getLanguageId(tokenIndex);\n    let lastTokenIndex = tokenIndex;\n    while (lastTokenIndex + 1 < tokenCount && context.getLanguageId(lastTokenIndex + 1) === desiredLanguageId) {\n        lastTokenIndex++;\n    }\n    let firstTokenIndex = tokenIndex;\n    while (firstTokenIndex > 0 && context.getLanguageId(firstTokenIndex - 1) === desiredLanguageId) {\n        firstTokenIndex--;\n    }\n    return new ScopedLineTokens(context, desiredLanguageId, firstTokenIndex, lastTokenIndex + 1, context.getStartOffset(firstTokenIndex), context.getEndOffset(lastTokenIndex));\n}\nexport class ScopedLineTokens {\n    constructor(actual, languageId, firstTokenIndex, lastTokenIndex, firstCharOffset, lastCharOffset) {\n        this._scopedLineTokensBrand = undefined;\n        this._actual = actual;\n        this.languageId = languageId;\n        this._firstTokenIndex = firstTokenIndex;\n        this._lastTokenIndex = lastTokenIndex;\n        this.firstCharOffset = firstCharOffset;\n        this._lastCharOffset = lastCharOffset;\n        this.languageIdCodec = actual.languageIdCodec;\n    }\n    getLineContent() {\n        const actualLineContent = this._actual.getLineContent();\n        return actualLineContent.substring(this.firstCharOffset, this._lastCharOffset);\n    }\n    getLineLength() {\n        return this._lastCharOffset - this.firstCharOffset;\n    }\n    getActualLineContentBefore(offset) {\n        const actualLineContent = this._actual.getLineContent();\n        return actualLineContent.substring(0, this.firstCharOffset + offset);\n    }\n    getTokenCount() {\n        return this._lastTokenIndex - this._firstTokenIndex;\n    }\n    findTokenIndexAtOffset(offset) {\n        return this._actual.findTokenIndexAtOffset(offset + this.firstCharOffset) - this._firstTokenIndex;\n    }\n    getStandardTokenType(tokenIndex) {\n        return this._actual.getStandardTokenType(tokenIndex + this._firstTokenIndex);\n    }\n    toIViewLineTokens() {\n        return this._actual.sliceAndInflate(this.firstCharOffset, this._lastCharOffset, 0);\n    }\n}\nexport function ignoreBracketsInToken(standardTokenType) {\n    return (standardTokenType & 3 /* IgnoreBracketsInTokens.value */) !== 0;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport * as stringBuilder from '../../core/stringBuilder.js';\nimport { Range } from '../../core/range.js';\n/**\n * Represents a grouping of colliding bracket pairs.\n *\n * Most of the times this contains a single bracket pair,\n * but sometimes this contains multiple bracket pairs in cases\n * where the same string appears as a closing bracket for multiple\n * bracket pairs, or the same string appears an opening bracket for\n * multiple bracket pairs.\n *\n * e.g. of a group containing a single pair:\n *   open: ['{'], close: ['}']\n *\n * e.g. of a group containing multiple pairs:\n *   open: ['if', 'for'], close: ['end', 'end']\n */\nexport class RichEditBracket {\n    constructor(languageId, index, open, close, forwardRegex, reversedRegex) {\n        this._richEditBracketBrand = undefined;\n        this.languageId = languageId;\n        this.index = index;\n        this.open = open;\n        this.close = close;\n        this.forwardRegex = forwardRegex;\n        this.reversedRegex = reversedRegex;\n        this._openSet = RichEditBracket._toSet(this.open);\n        this._closeSet = RichEditBracket._toSet(this.close);\n    }\n    /**\n     * Check if the provided `text` is an open bracket in this group.\n     */\n    isOpen(text) {\n        return this._openSet.has(text);\n    }\n    /**\n     * Check if the provided `text` is a close bracket in this group.\n     */\n    isClose(text) {\n        return this._closeSet.has(text);\n    }\n    static _toSet(arr) {\n        const result = new Set();\n        for (const element of arr) {\n            result.add(element);\n        }\n        return result;\n    }\n}\n/**\n * Groups together brackets that have equal open or close sequences.\n *\n * For example, if the following brackets are defined:\n *   ['IF','END']\n *   ['for','end']\n *   ['{','}']\n *\n * Then the grouped brackets would be:\n *   { open: ['if', 'for'], close: ['end', 'end'] }\n *   { open: ['{'], close: ['}'] }\n *\n */\nfunction groupFuzzyBrackets(brackets) {\n    const N = brackets.length;\n    brackets = brackets.map(b => [b[0].toLowerCase(), b[1].toLowerCase()]);\n    const group = [];\n    for (let i = 0; i < N; i++) {\n        group[i] = i;\n    }\n    const areOverlapping = (a, b) => {\n        const [aOpen, aClose] = a;\n        const [bOpen, bClose] = b;\n        return (aOpen === bOpen || aOpen === bClose || aClose === bOpen || aClose === bClose);\n    };\n    const mergeGroups = (g1, g2) => {\n        const newG = Math.min(g1, g2);\n        const oldG = Math.max(g1, g2);\n        for (let i = 0; i < N; i++) {\n            if (group[i] === oldG) {\n                group[i] = newG;\n            }\n        }\n    };\n    // group together brackets that have the same open or the same close sequence\n    for (let i = 0; i < N; i++) {\n        const a = brackets[i];\n        for (let j = i + 1; j < N; j++) {\n            const b = brackets[j];\n            if (areOverlapping(a, b)) {\n                mergeGroups(group[i], group[j]);\n            }\n        }\n    }\n    const result = [];\n    for (let g = 0; g < N; g++) {\n        const currentOpen = [];\n        const currentClose = [];\n        for (let i = 0; i < N; i++) {\n            if (group[i] === g) {\n                const [open, close] = brackets[i];\n                currentOpen.push(open);\n                currentClose.push(close);\n            }\n        }\n        if (currentOpen.length > 0) {\n            result.push({\n                open: currentOpen,\n                close: currentClose\n            });\n        }\n    }\n    return result;\n}\nexport class RichEditBrackets {\n    constructor(languageId, _brackets) {\n        this._richEditBracketsBrand = undefined;\n        const brackets = groupFuzzyBrackets(_brackets);\n        this.brackets = brackets.map((b, index) => {\n            return new RichEditBracket(languageId, index, b.open, b.close, getRegexForBracketPair(b.open, b.close, brackets, index), getReversedRegexForBracketPair(b.open, b.close, brackets, index));\n        });\n        this.forwardRegex = getRegexForBrackets(this.brackets);\n        this.reversedRegex = getReversedRegexForBrackets(this.brackets);\n        this.textIsBracket = {};\n        this.textIsOpenBracket = {};\n        this.maxBracketLength = 0;\n        for (const bracket of this.brackets) {\n            for (const open of bracket.open) {\n                this.textIsBracket[open] = bracket;\n                this.textIsOpenBracket[open] = true;\n                this.maxBracketLength = Math.max(this.maxBracketLength, open.length);\n            }\n            for (const close of bracket.close) {\n                this.textIsBracket[close] = bracket;\n                this.textIsOpenBracket[close] = false;\n                this.maxBracketLength = Math.max(this.maxBracketLength, close.length);\n            }\n        }\n    }\n}\nfunction collectSuperstrings(str, brackets, currentIndex, dest) {\n    for (let i = 0, len = brackets.length; i < len; i++) {\n        if (i === currentIndex) {\n            continue;\n        }\n        const bracket = brackets[i];\n        for (const open of bracket.open) {\n            if (open.indexOf(str) >= 0) {\n                dest.push(open);\n            }\n        }\n        for (const close of bracket.close) {\n            if (close.indexOf(str) >= 0) {\n                dest.push(close);\n            }\n        }\n    }\n}\nfunction lengthcmp(a, b) {\n    return a.length - b.length;\n}\nfunction unique(arr) {\n    if (arr.length <= 1) {\n        return arr;\n    }\n    const result = [];\n    const seen = new Set();\n    for (const element of arr) {\n        if (seen.has(element)) {\n            continue;\n        }\n        result.push(element);\n        seen.add(element);\n    }\n    return result;\n}\n/**\n * Create a regular expression that can be used to search forward in a piece of text\n * for a group of bracket pairs. But this regex must be built in a way in which\n * it is aware of the other bracket pairs defined for the language.\n *\n * For example, if a language contains the following bracket pairs:\n *   ['begin', 'end']\n *   ['if', 'end if']\n * The two bracket pairs do not collide because no open or close brackets are equal.\n * So the function getRegexForBracketPair is called twice, once with\n * the ['begin'], ['end'] group consisting of one bracket pair, and once with\n * the ['if'], ['end if'] group consiting of the other bracket pair.\n *\n * But there could be a situation where an occurrence of 'end if' is mistaken\n * for an occurrence of 'end'.\n *\n * Therefore, for the bracket pair ['begin', 'end'], the regex will also\n * target 'end if'. The regex will be something like:\n *   /(\\bend if\\b)|(\\bend\\b)|(\\bif\\b)/\n *\n * The regex also searches for \"superstrings\" (other brackets that might be mistaken with the current bracket).\n *\n */\nfunction getRegexForBracketPair(open, close, brackets, currentIndex) {\n    // search in all brackets for other brackets that are a superstring of these brackets\n    let pieces = [];\n    pieces = pieces.concat(open);\n    pieces = pieces.concat(close);\n    for (let i = 0, len = pieces.length; i < len; i++) {\n        collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n    }\n    pieces = unique(pieces);\n    pieces.sort(lengthcmp);\n    pieces.reverse();\n    return createBracketOrRegExp(pieces);\n}\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * This function also has the fine details of `getRegexForBracketPair`. For the same example\n * given above, the regex produced here would look like:\n *   /(\\bfi dne\\b)|(\\bdne\\b)|(\\bfi\\b)/\n */\nfunction getReversedRegexForBracketPair(open, close, brackets, currentIndex) {\n    // search in all brackets for other brackets that are a superstring of these brackets\n    let pieces = [];\n    pieces = pieces.concat(open);\n    pieces = pieces.concat(close);\n    for (let i = 0, len = pieces.length; i < len; i++) {\n        collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n    }\n    pieces = unique(pieces);\n    pieces.sort(lengthcmp);\n    pieces.reverse();\n    return createBracketOrRegExp(pieces.map(toReversedString));\n}\n/**\n * Creates a regular expression that targets all bracket pairs.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bbegin\\b)|(\\bend\\b)|(\\bfor\\b)/\n */\nfunction getRegexForBrackets(brackets) {\n    let pieces = [];\n    for (const bracket of brackets) {\n        for (const open of bracket.open) {\n            pieces.push(open);\n        }\n        for (const close of bracket.close) {\n            pieces.push(close);\n        }\n    }\n    pieces = unique(pieces);\n    return createBracketOrRegExp(pieces);\n}\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bnigeb\\b)|(\\bdne\\b)|(\\brof\\b)/\n */\nfunction getReversedRegexForBrackets(brackets) {\n    let pieces = [];\n    for (const bracket of brackets) {\n        for (const open of bracket.open) {\n            pieces.push(open);\n        }\n        for (const close of bracket.close) {\n            pieces.push(close);\n        }\n    }\n    pieces = unique(pieces);\n    return createBracketOrRegExp(pieces.map(toReversedString));\n}\nfunction prepareBracketForRegExp(str) {\n    // This bracket pair uses letters like e.g. \"begin\" - \"end\"\n    const insertWordBoundaries = (/^[\\w ]+$/.test(str));\n    str = strings.escapeRegExpCharacters(str);\n    return (insertWordBoundaries ? `\\\\b${str}\\\\b` : str);\n}\nexport function createBracketOrRegExp(pieces, options) {\n    const regexStr = `(${pieces.map(prepareBracketForRegExp).join(')|(')})`;\n    return strings.createRegExp(regexStr, true, options);\n}\nconst toReversedString = (function () {\n    function reverse(str) {\n        // create a Uint16Array and then use a TextDecoder to create a string\n        const arr = new Uint16Array(str.length);\n        let offset = 0;\n        for (let i = str.length - 1; i >= 0; i--) {\n            arr[offset++] = str.charCodeAt(i);\n        }\n        return stringBuilder.getPlatformTextDecoder().decode(arr);\n    }\n    let lastInput = null;\n    let lastOutput = null;\n    return function toReversedString(str) {\n        if (lastInput !== str) {\n            lastInput = str;\n            lastOutput = reverse(lastInput);\n        }\n        return lastOutput;\n    };\n})();\nexport class BracketsUtils {\n    static _findPrevBracketInText(reversedBracketRegex, lineNumber, reversedText, offset) {\n        const m = reversedText.match(reversedBracketRegex);\n        if (!m) {\n            return null;\n        }\n        const matchOffset = reversedText.length - (m.index || 0);\n        const matchLength = m[0].length;\n        const absoluteMatchOffset = offset + matchOffset;\n        return new Range(lineNumber, absoluteMatchOffset - matchLength + 1, lineNumber, absoluteMatchOffset + 1);\n    }\n    static findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, startOffset, endOffset) {\n        // Because JS does not support backwards regex search, we search forwards in a reversed string with a reversed regex ;)\n        const reversedLineText = toReversedString(lineText);\n        const reversedSubstr = reversedLineText.substring(lineText.length - endOffset, lineText.length - startOffset);\n        return this._findPrevBracketInText(reversedBracketRegex, lineNumber, reversedSubstr, startOffset);\n    }\n    static findNextBracketInText(bracketRegex, lineNumber, text, offset) {\n        const m = text.match(bracketRegex);\n        if (!m) {\n            return null;\n        }\n        const matchOffset = m.index || 0;\n        const matchLength = m[0].length;\n        if (matchLength === 0) {\n            return null;\n        }\n        const absoluteMatchOffset = offset + matchOffset;\n        return new Range(lineNumber, absoluteMatchOffset + 1, lineNumber, absoluteMatchOffset + 1 + matchLength);\n    }\n    static findNextBracketInRange(bracketRegex, lineNumber, lineText, startOffset, endOffset) {\n        const substr = lineText.substring(startOffset, endOffset);\n        return this.findNextBracketInText(bracketRegex, lineNumber, substr, startOffset);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../../../base/common/errors.js';\nimport { CursorColumns } from '../../../core/cursorColumns.js';\nimport { lengthAdd, lengthGetLineCount, lengthToObj, lengthZero } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\n/**\n * The base implementation for all AST nodes.\n*/\nclass BaseAstNode {\n    /**\n     * The length of the entire node, which should equal the sum of lengths of all children.\n    */\n    get length() {\n        return this._length;\n    }\n    constructor(length) {\n        this._length = length;\n    }\n}\n/**\n * Represents a bracket pair including its child (e.g. `{ ... }`).\n * Might be unclosed.\n * Immutable, if all children are immutable.\n*/\nexport class PairAstNode extends BaseAstNode {\n    static create(openingBracket, child, closingBracket) {\n        let length = openingBracket.length;\n        if (child) {\n            length = lengthAdd(length, child.length);\n        }\n        if (closingBracket) {\n            length = lengthAdd(length, closingBracket.length);\n        }\n        return new PairAstNode(length, openingBracket, child, closingBracket, child ? child.missingOpeningBracketIds : SmallImmutableSet.getEmpty());\n    }\n    get kind() {\n        return 2 /* AstNodeKind.Pair */;\n    }\n    get listHeight() {\n        return 0;\n    }\n    get childrenLength() {\n        return 3;\n    }\n    getChild(idx) {\n        switch (idx) {\n            case 0: return this.openingBracket;\n            case 1: return this.child;\n            case 2: return this.closingBracket;\n        }\n        throw new Error('Invalid child index');\n    }\n    /**\n     * Avoid using this property, it allocates an array!\n    */\n    get children() {\n        const result = [];\n        result.push(this.openingBracket);\n        if (this.child) {\n            result.push(this.child);\n        }\n        if (this.closingBracket) {\n            result.push(this.closingBracket);\n        }\n        return result;\n    }\n    constructor(length, openingBracket, child, closingBracket, missingOpeningBracketIds) {\n        super(length);\n        this.openingBracket = openingBracket;\n        this.child = child;\n        this.closingBracket = closingBracket;\n        this.missingOpeningBracketIds = missingOpeningBracketIds;\n    }\n    canBeReused(openBracketIds) {\n        if (this.closingBracket === null) {\n            // Unclosed pair ast nodes only\n            // end at the end of the document\n            // or when a parent node is closed.\n            // This could be improved:\n            // Only return false if some next token is neither \"undefined\" nor a bracket that closes a parent.\n            return false;\n        }\n        if (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n            return false;\n        }\n        return true;\n    }\n    deepClone() {\n        return new PairAstNode(this.length, this.openingBracket.deepClone(), this.child && this.child.deepClone(), this.closingBracket && this.closingBracket.deepClone(), this.missingOpeningBracketIds);\n    }\n    computeMinIndentation(offset, textModel) {\n        return this.child ? this.child.computeMinIndentation(lengthAdd(offset, this.openingBracket.length), textModel) : Number.MAX_SAFE_INTEGER;\n    }\n}\nexport class ListAstNode extends BaseAstNode {\n    /**\n     * This method uses more memory-efficient list nodes that can only store 2 or 3 children.\n    */\n    static create23(item1, item2, item3, immutable = false) {\n        let length = item1.length;\n        let missingBracketIds = item1.missingOpeningBracketIds;\n        if (item1.listHeight !== item2.listHeight) {\n            throw new Error('Invalid list heights');\n        }\n        length = lengthAdd(length, item2.length);\n        missingBracketIds = missingBracketIds.merge(item2.missingOpeningBracketIds);\n        if (item3) {\n            if (item1.listHeight !== item3.listHeight) {\n                throw new Error('Invalid list heights');\n            }\n            length = lengthAdd(length, item3.length);\n            missingBracketIds = missingBracketIds.merge(item3.missingOpeningBracketIds);\n        }\n        return immutable\n            ? new Immutable23ListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds)\n            : new TwoThreeListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds);\n    }\n    static getEmpty() {\n        return new ImmutableArrayListAstNode(lengthZero, 0, [], SmallImmutableSet.getEmpty());\n    }\n    get kind() {\n        return 4 /* AstNodeKind.List */;\n    }\n    get missingOpeningBracketIds() {\n        return this._missingOpeningBracketIds;\n    }\n    /**\n     * Use ListAstNode.create.\n    */\n    constructor(length, listHeight, _missingOpeningBracketIds) {\n        super(length);\n        this.listHeight = listHeight;\n        this._missingOpeningBracketIds = _missingOpeningBracketIds;\n        this.cachedMinIndentation = -1;\n    }\n    throwIfImmutable() {\n        // NOOP\n    }\n    makeLastElementMutable() {\n        this.throwIfImmutable();\n        const childCount = this.childrenLength;\n        if (childCount === 0) {\n            return undefined;\n        }\n        const lastChild = this.getChild(childCount - 1);\n        const mutable = lastChild.kind === 4 /* AstNodeKind.List */ ? lastChild.toMutable() : lastChild;\n        if (lastChild !== mutable) {\n            this.setChild(childCount - 1, mutable);\n        }\n        return mutable;\n    }\n    makeFirstElementMutable() {\n        this.throwIfImmutable();\n        const childCount = this.childrenLength;\n        if (childCount === 0) {\n            return undefined;\n        }\n        const firstChild = this.getChild(0);\n        const mutable = firstChild.kind === 4 /* AstNodeKind.List */ ? firstChild.toMutable() : firstChild;\n        if (firstChild !== mutable) {\n            this.setChild(0, mutable);\n        }\n        return mutable;\n    }\n    canBeReused(openBracketIds) {\n        if (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n            return false;\n        }\n        if (this.childrenLength === 0) {\n            // Don't reuse empty lists.\n            return false;\n        }\n        let lastChild = this;\n        while (lastChild.kind === 4 /* AstNodeKind.List */) {\n            const lastLength = lastChild.childrenLength;\n            if (lastLength === 0) {\n                // Empty lists should never be contained in other lists.\n                throw new BugIndicatingError();\n            }\n            lastChild = lastChild.getChild(lastLength - 1);\n        }\n        return lastChild.canBeReused(openBracketIds);\n    }\n    handleChildrenChanged() {\n        this.throwIfImmutable();\n        const count = this.childrenLength;\n        let length = this.getChild(0).length;\n        let unopenedBrackets = this.getChild(0).missingOpeningBracketIds;\n        for (let i = 1; i < count; i++) {\n            const child = this.getChild(i);\n            length = lengthAdd(length, child.length);\n            unopenedBrackets = unopenedBrackets.merge(child.missingOpeningBracketIds);\n        }\n        this._length = length;\n        this._missingOpeningBracketIds = unopenedBrackets;\n        this.cachedMinIndentation = -1;\n    }\n    computeMinIndentation(offset, textModel) {\n        if (this.cachedMinIndentation !== -1) {\n            return this.cachedMinIndentation;\n        }\n        let minIndentation = Number.MAX_SAFE_INTEGER;\n        let childOffset = offset;\n        for (let i = 0; i < this.childrenLength; i++) {\n            const child = this.getChild(i);\n            if (child) {\n                minIndentation = Math.min(minIndentation, child.computeMinIndentation(childOffset, textModel));\n                childOffset = lengthAdd(childOffset, child.length);\n            }\n        }\n        this.cachedMinIndentation = minIndentation;\n        return minIndentation;\n    }\n}\nclass TwoThreeListAstNode extends ListAstNode {\n    get childrenLength() {\n        return this._item3 !== null ? 3 : 2;\n    }\n    getChild(idx) {\n        switch (idx) {\n            case 0: return this._item1;\n            case 1: return this._item2;\n            case 2: return this._item3;\n        }\n        throw new Error('Invalid child index');\n    }\n    setChild(idx, node) {\n        switch (idx) {\n            case 0:\n                this._item1 = node;\n                return;\n            case 1:\n                this._item2 = node;\n                return;\n            case 2:\n                this._item3 = node;\n                return;\n        }\n        throw new Error('Invalid child index');\n    }\n    get children() {\n        return this._item3 ? [this._item1, this._item2, this._item3] : [this._item1, this._item2];\n    }\n    get item1() {\n        return this._item1;\n    }\n    get item2() {\n        return this._item2;\n    }\n    get item3() {\n        return this._item3;\n    }\n    constructor(length, listHeight, _item1, _item2, _item3, missingOpeningBracketIds) {\n        super(length, listHeight, missingOpeningBracketIds);\n        this._item1 = _item1;\n        this._item2 = _item2;\n        this._item3 = _item3;\n    }\n    deepClone() {\n        return new TwoThreeListAstNode(this.length, this.listHeight, this._item1.deepClone(), this._item2.deepClone(), this._item3 ? this._item3.deepClone() : null, this.missingOpeningBracketIds);\n    }\n    appendChildOfSameHeight(node) {\n        if (this._item3) {\n            throw new Error('Cannot append to a full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        this._item3 = node;\n        this.handleChildrenChanged();\n    }\n    unappendChild() {\n        if (!this._item3) {\n            throw new Error('Cannot remove from a non-full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        const result = this._item3;\n        this._item3 = null;\n        this.handleChildrenChanged();\n        return result;\n    }\n    prependChildOfSameHeight(node) {\n        if (this._item3) {\n            throw new Error('Cannot prepend to a full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        this._item3 = this._item2;\n        this._item2 = this._item1;\n        this._item1 = node;\n        this.handleChildrenChanged();\n    }\n    unprependChild() {\n        if (!this._item3) {\n            throw new Error('Cannot remove from a non-full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        const result = this._item1;\n        this._item1 = this._item2;\n        this._item2 = this._item3;\n        this._item3 = null;\n        this.handleChildrenChanged();\n        return result;\n    }\n    toMutable() {\n        return this;\n    }\n}\n/**\n * Immutable, if all children are immutable.\n*/\nclass Immutable23ListAstNode extends TwoThreeListAstNode {\n    toMutable() {\n        return new TwoThreeListAstNode(this.length, this.listHeight, this.item1, this.item2, this.item3, this.missingOpeningBracketIds);\n    }\n    throwIfImmutable() {\n        throw new Error('this instance is immutable');\n    }\n}\n/**\n * For debugging.\n*/\nclass ArrayListAstNode extends ListAstNode {\n    get childrenLength() {\n        return this._children.length;\n    }\n    getChild(idx) {\n        return this._children[idx];\n    }\n    setChild(idx, child) {\n        this._children[idx] = child;\n    }\n    get children() {\n        return this._children;\n    }\n    constructor(length, listHeight, _children, missingOpeningBracketIds) {\n        super(length, listHeight, missingOpeningBracketIds);\n        this._children = _children;\n    }\n    deepClone() {\n        const children = new Array(this._children.length);\n        for (let i = 0; i < this._children.length; i++) {\n            children[i] = this._children[i].deepClone();\n        }\n        return new ArrayListAstNode(this.length, this.listHeight, children, this.missingOpeningBracketIds);\n    }\n    appendChildOfSameHeight(node) {\n        this.throwIfImmutable();\n        this._children.push(node);\n        this.handleChildrenChanged();\n    }\n    unappendChild() {\n        this.throwIfImmutable();\n        const item = this._children.pop();\n        this.handleChildrenChanged();\n        return item;\n    }\n    prependChildOfSameHeight(node) {\n        this.throwIfImmutable();\n        this._children.unshift(node);\n        this.handleChildrenChanged();\n    }\n    unprependChild() {\n        this.throwIfImmutable();\n        const item = this._children.shift();\n        this.handleChildrenChanged();\n        return item;\n    }\n    toMutable() {\n        return this;\n    }\n}\n/**\n * Immutable, if all children are immutable.\n*/\nclass ImmutableArrayListAstNode extends ArrayListAstNode {\n    toMutable() {\n        return new ArrayListAstNode(this.length, this.listHeight, [...this.children], this.missingOpeningBracketIds);\n    }\n    throwIfImmutable() {\n        throw new Error('this instance is immutable');\n    }\n}\nconst emptyArray = [];\nclass ImmutableLeafAstNode extends BaseAstNode {\n    get listHeight() {\n        return 0;\n    }\n    get childrenLength() {\n        return 0;\n    }\n    getChild(idx) {\n        return null;\n    }\n    get children() {\n        return emptyArray;\n    }\n    deepClone() {\n        return this;\n    }\n}\nexport class TextAstNode extends ImmutableLeafAstNode {\n    get kind() {\n        return 0 /* AstNodeKind.Text */;\n    }\n    get missingOpeningBracketIds() {\n        return SmallImmutableSet.getEmpty();\n    }\n    canBeReused(_openedBracketIds) {\n        return true;\n    }\n    computeMinIndentation(offset, textModel) {\n        const start = lengthToObj(offset);\n        // Text ast nodes don't have partial indentation (ensured by the tokenizer).\n        // Thus, if this text node does not start at column 0, the first line cannot have any indentation at all.\n        const startLineNumber = (start.columnCount === 0 ? start.lineCount : start.lineCount + 1) + 1;\n        const endLineNumber = lengthGetLineCount(lengthAdd(offset, this.length)) + 1;\n        let result = Number.MAX_SAFE_INTEGER;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const firstNonWsColumn = textModel.getLineFirstNonWhitespaceColumn(lineNumber);\n            const lineContent = textModel.getLineContent(lineNumber);\n            if (firstNonWsColumn === 0) {\n                continue;\n            }\n            const visibleColumn = CursorColumns.visibleColumnFromColumn(lineContent, firstNonWsColumn, textModel.getOptions().tabSize);\n            result = Math.min(result, visibleColumn);\n        }\n        return result;\n    }\n}\nexport class BracketAstNode extends ImmutableLeafAstNode {\n    static create(length, bracketInfo, bracketIds) {\n        const node = new BracketAstNode(length, bracketInfo, bracketIds);\n        return node;\n    }\n    get kind() {\n        return 1 /* AstNodeKind.Bracket */;\n    }\n    get missingOpeningBracketIds() {\n        return SmallImmutableSet.getEmpty();\n    }\n    constructor(length, bracketInfo, \n    /**\n     * In case of a opening bracket, this is the id of the opening bracket.\n     * In case of a closing bracket, this contains the ids of all opening brackets it can close.\n    */\n    bracketIds) {\n        super(length);\n        this.bracketInfo = bracketInfo;\n        this.bracketIds = bracketIds;\n    }\n    get text() {\n        return this.bracketInfo.bracketText;\n    }\n    get languageId() {\n        return this.bracketInfo.languageId;\n    }\n    canBeReused(_openedBracketIds) {\n        // These nodes could be reused,\n        // but not in a general way.\n        // Their parent may be reused.\n        return false;\n    }\n    computeMinIndentation(offset, textModel) {\n        return Number.MAX_SAFE_INTEGER;\n    }\n}\nexport class InvalidBracketAstNode extends ImmutableLeafAstNode {\n    get kind() {\n        return 3 /* AstNodeKind.UnexpectedClosingBracket */;\n    }\n    constructor(closingBrackets, length) {\n        super(length);\n        this.missingOpeningBracketIds = closingBrackets;\n    }\n    canBeReused(openedBracketIds) {\n        return !openedBracketIds.intersects(this.missingOpeningBracketIds);\n    }\n    computeMinIndentation(offset, textModel) {\n        return Number.MAX_SAFE_INTEGER;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../../../core/range.js';\nimport { lengthAdd, lengthDiffNonNegative, lengthLessThanEqual, lengthOfString, lengthToObj, positionToLength, toLength } from './length.js';\nexport class TextEditInfo {\n    static fromModelContentChanges(changes) {\n        // Must be sorted in ascending order\n        const edits = changes.map(c => {\n            const range = Range.lift(c.range);\n            return new TextEditInfo(positionToLength(range.getStartPosition()), positionToLength(range.getEndPosition()), lengthOfString(c.text));\n        }).reverse();\n        return edits;\n    }\n    constructor(startOffset, endOffset, newLength) {\n        this.startOffset = startOffset;\n        this.endOffset = endOffset;\n        this.newLength = newLength;\n    }\n    toString() {\n        return `[${lengthToObj(this.startOffset)}...${lengthToObj(this.endOffset)}) -> ${lengthToObj(this.newLength)}`;\n    }\n}\nexport class BeforeEditPositionMapper {\n    /**\n     * @param edits Must be sorted by offset in ascending order.\n    */\n    constructor(edits) {\n        this.nextEditIdx = 0;\n        this.deltaOldToNewLineCount = 0;\n        this.deltaOldToNewColumnCount = 0;\n        this.deltaLineIdxInOld = -1;\n        this.edits = edits.map(edit => TextEditInfoCache.from(edit));\n    }\n    /**\n     * @param offset Must be equal to or greater than the last offset this method has been called with.\n    */\n    getOffsetBeforeChange(offset) {\n        this.adjustNextEdit(offset);\n        return this.translateCurToOld(offset);\n    }\n    /**\n     * @param offset Must be equal to or greater than the last offset this method has been called with.\n     * Returns null if there is no edit anymore.\n    */\n    getDistanceToNextChange(offset) {\n        this.adjustNextEdit(offset);\n        const nextEdit = this.edits[this.nextEditIdx];\n        const nextChangeOffset = nextEdit ? this.translateOldToCur(nextEdit.offsetObj) : null;\n        if (nextChangeOffset === null) {\n            return null;\n        }\n        return lengthDiffNonNegative(offset, nextChangeOffset);\n    }\n    translateOldToCur(oldOffsetObj) {\n        if (oldOffsetObj.lineCount === this.deltaLineIdxInOld) {\n            return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount + this.deltaOldToNewColumnCount);\n        }\n        else {\n            return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount);\n        }\n    }\n    translateCurToOld(newOffset) {\n        const offsetObj = lengthToObj(newOffset);\n        if (offsetObj.lineCount - this.deltaOldToNewLineCount === this.deltaLineIdxInOld) {\n            return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount - this.deltaOldToNewColumnCount);\n        }\n        else {\n            return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount);\n        }\n    }\n    adjustNextEdit(offset) {\n        while (this.nextEditIdx < this.edits.length) {\n            const nextEdit = this.edits[this.nextEditIdx];\n            // After applying the edit, what is its end offset (considering all previous edits)?\n            const nextEditEndOffsetInCur = this.translateOldToCur(nextEdit.endOffsetAfterObj);\n            if (lengthLessThanEqual(nextEditEndOffsetInCur, offset)) {\n                // We are after the edit, skip it\n                this.nextEditIdx++;\n                const nextEditEndOffsetInCurObj = lengthToObj(nextEditEndOffsetInCur);\n                // Before applying the edit, what is its end offset (considering all previous edits)?\n                const nextEditEndOffsetBeforeInCurObj = lengthToObj(this.translateOldToCur(nextEdit.endOffsetBeforeObj));\n                const lineDelta = nextEditEndOffsetInCurObj.lineCount - nextEditEndOffsetBeforeInCurObj.lineCount;\n                this.deltaOldToNewLineCount += lineDelta;\n                const previousColumnDelta = this.deltaLineIdxInOld === nextEdit.endOffsetBeforeObj.lineCount ? this.deltaOldToNewColumnCount : 0;\n                const columnDelta = nextEditEndOffsetInCurObj.columnCount - nextEditEndOffsetBeforeInCurObj.columnCount;\n                this.deltaOldToNewColumnCount = previousColumnDelta + columnDelta;\n                this.deltaLineIdxInOld = nextEdit.endOffsetBeforeObj.lineCount;\n            }\n            else {\n                // We are in or before the edit.\n                break;\n            }\n        }\n    }\n}\nclass TextEditInfoCache {\n    static from(edit) {\n        return new TextEditInfoCache(edit.startOffset, edit.endOffset, edit.newLength);\n    }\n    constructor(startOffset, endOffset, textLength) {\n        this.endOffsetBeforeObj = lengthToObj(endOffset);\n        this.endOffsetAfterObj = lengthToObj(lengthAdd(startOffset, textLength));\n        this.offsetObj = lengthToObj(startOffset);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { escapeRegExpCharacters } from '../../../../../base/common/strings.js';\nimport { BracketAstNode } from './ast.js';\nimport { toLength } from './length.js';\nimport { identityKeyProvider, SmallImmutableSet } from './smallImmutableSet.js';\nimport { Token } from './tokenizer.js';\nexport class BracketTokens {\n    static createFromLanguage(configuration, denseKeyProvider) {\n        function getId(bracketInfo) {\n            return denseKeyProvider.getKey(`${bracketInfo.languageId}:::${bracketInfo.bracketText}`);\n        }\n        const map = new Map();\n        for (const openingBracket of configuration.bracketsNew.openingBrackets) {\n            const length = toLength(0, openingBracket.bracketText.length);\n            const openingTextId = getId(openingBracket);\n            const bracketIds = SmallImmutableSet.getEmpty().add(openingTextId, identityKeyProvider);\n            map.set(openingBracket.bracketText, new Token(length, 1 /* TokenKind.OpeningBracket */, openingTextId, bracketIds, BracketAstNode.create(length, openingBracket, bracketIds)));\n        }\n        for (const closingBracket of configuration.bracketsNew.closingBrackets) {\n            const length = toLength(0, closingBracket.bracketText.length);\n            let bracketIds = SmallImmutableSet.getEmpty();\n            const closingBrackets = closingBracket.getOpeningBrackets();\n            for (const bracket of closingBrackets) {\n                bracketIds = bracketIds.add(getId(bracket), identityKeyProvider);\n            }\n            map.set(closingBracket.bracketText, new Token(length, 2 /* TokenKind.ClosingBracket */, getId(closingBrackets[0]), bracketIds, BracketAstNode.create(length, closingBracket, bracketIds)));\n        }\n        return new BracketTokens(map);\n    }\n    constructor(map) {\n        this.map = map;\n        this.hasRegExp = false;\n        this._regExpGlobal = null;\n    }\n    getRegExpStr() {\n        if (this.isEmpty) {\n            return null;\n        }\n        else {\n            const keys = [...this.map.keys()];\n            keys.sort();\n            keys.reverse();\n            return keys.map(k => prepareBracketForRegExp(k)).join('|');\n        }\n    }\n    /**\n     * Returns null if there is no such regexp (because there are no brackets).\n    */\n    get regExpGlobal() {\n        if (!this.hasRegExp) {\n            const regExpStr = this.getRegExpStr();\n            this._regExpGlobal = regExpStr ? new RegExp(regExpStr, 'gi') : null;\n            this.hasRegExp = true;\n        }\n        return this._regExpGlobal;\n    }\n    getToken(value) {\n        return this.map.get(value.toLowerCase());\n    }\n    findClosingTokenText(openingBracketIds) {\n        for (const [closingText, info] of this.map) {\n            if (info.kind === 2 /* TokenKind.ClosingBracket */ && info.bracketIds.intersects(openingBracketIds)) {\n                return closingText;\n            }\n        }\n        return undefined;\n    }\n    get isEmpty() {\n        return this.map.size === 0;\n    }\n}\nfunction prepareBracketForRegExp(str) {\n    let escaped = escapeRegExpCharacters(str);\n    // These bracket pair delimiters start or end with letters\n    // see https://github.com/microsoft/vscode/issues/132162 https://github.com/microsoft/vscode/issues/150440\n    if (/^[\\w ]+/.test(str)) {\n        escaped = `\\\\b${escaped}`;\n    }\n    if (/[\\w ]+$/.test(str)) {\n        escaped = `${escaped}\\\\b`;\n    }\n    return escaped;\n}\nexport class LanguageAgnosticBracketTokens {\n    constructor(denseKeyProvider, getLanguageConfiguration) {\n        this.denseKeyProvider = denseKeyProvider;\n        this.getLanguageConfiguration = getLanguageConfiguration;\n        this.languageIdToBracketTokens = new Map();\n    }\n    didLanguageChange(languageId) {\n        // Report a change whenever the language configuration updates.\n        return this.languageIdToBracketTokens.has(languageId);\n    }\n    getSingleLanguageBracketTokens(languageId) {\n        let singleLanguageBracketTokens = this.languageIdToBracketTokens.get(languageId);\n        if (!singleLanguageBracketTokens) {\n            singleLanguageBracketTokens = BracketTokens.createFromLanguage(this.getLanguageConfiguration(languageId), this.denseKeyProvider);\n            this.languageIdToBracketTokens.set(languageId, singleLanguageBracketTokens);\n        }\n        return singleLanguageBracketTokens;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ArrayQueue } from '../../../../../base/common/arrays.js';\nimport { TextEditInfo } from './beforeEditPositionMapper.js';\nimport { lengthAdd, lengthDiffNonNegative, lengthEquals, lengthIsZero, lengthToObj, lengthZero, sumLengths } from './length.js';\nexport function combineTextEditInfos(textEditInfoFirst, textEditInfoSecond) {\n    if (textEditInfoFirst.length === 0) {\n        return textEditInfoSecond;\n    }\n    if (textEditInfoSecond.length === 0) {\n        return textEditInfoFirst;\n    }\n    // s0: State before any edits\n    const s0ToS1Map = new ArrayQueue(toLengthMapping(textEditInfoFirst));\n    // s1: State after first edit, but before second edit\n    const s1ToS2Map = toLengthMapping(textEditInfoSecond);\n    s1ToS2Map.push({ modified: false, lengthBefore: undefined, lengthAfter: undefined }); // Copy everything from old to new\n    // s2: State after both edits\n    let curItem = s0ToS1Map.dequeue();\n    /**\n     * @param s1Length Use undefined for length \"infinity\"\n     */\n    function nextS0ToS1MapWithS1LengthOf(s1Length) {\n        if (s1Length === undefined) {\n            const arr = s0ToS1Map.takeWhile(v => true) || [];\n            if (curItem) {\n                arr.unshift(curItem);\n            }\n            return arr;\n        }\n        const result = [];\n        while (curItem && !lengthIsZero(s1Length)) {\n            const [item, remainingItem] = curItem.splitAt(s1Length);\n            result.push(item);\n            s1Length = lengthDiffNonNegative(item.lengthAfter, s1Length);\n            curItem = remainingItem ?? s0ToS1Map.dequeue();\n        }\n        if (!lengthIsZero(s1Length)) {\n            result.push(new LengthMapping(false, s1Length, s1Length));\n        }\n        return result;\n    }\n    const result = [];\n    function pushEdit(startOffset, endOffset, newLength) {\n        if (result.length > 0 && lengthEquals(result[result.length - 1].endOffset, startOffset)) {\n            const lastResult = result[result.length - 1];\n            result[result.length - 1] = new TextEditInfo(lastResult.startOffset, endOffset, lengthAdd(lastResult.newLength, newLength));\n        }\n        else {\n            result.push({ startOffset, endOffset, newLength });\n        }\n    }\n    let s0offset = lengthZero;\n    for (const s1ToS2 of s1ToS2Map) {\n        const s0ToS1Map = nextS0ToS1MapWithS1LengthOf(s1ToS2.lengthBefore);\n        if (s1ToS2.modified) {\n            const s0Length = sumLengths(s0ToS1Map, s => s.lengthBefore);\n            const s0EndOffset = lengthAdd(s0offset, s0Length);\n            pushEdit(s0offset, s0EndOffset, s1ToS2.lengthAfter);\n            s0offset = s0EndOffset;\n        }\n        else {\n            for (const s1 of s0ToS1Map) {\n                const s0startOffset = s0offset;\n                s0offset = lengthAdd(s0offset, s1.lengthBefore);\n                if (s1.modified) {\n                    pushEdit(s0startOffset, s0offset, s1.lengthAfter);\n                }\n            }\n        }\n    }\n    return result;\n}\nclass LengthMapping {\n    constructor(\n    /**\n     * If false, length before and length after equal.\n     */\n    modified, lengthBefore, lengthAfter) {\n        this.modified = modified;\n        this.lengthBefore = lengthBefore;\n        this.lengthAfter = lengthAfter;\n    }\n    splitAt(lengthAfter) {\n        const remainingLengthAfter = lengthDiffNonNegative(lengthAfter, this.lengthAfter);\n        if (lengthEquals(remainingLengthAfter, lengthZero)) {\n            return [this, undefined];\n        }\n        else if (this.modified) {\n            return [\n                new LengthMapping(this.modified, this.lengthBefore, lengthAfter),\n                new LengthMapping(this.modified, lengthZero, remainingLengthAfter)\n            ];\n        }\n        else {\n            return [\n                new LengthMapping(this.modified, lengthAfter, lengthAfter),\n                new LengthMapping(this.modified, remainingLengthAfter, remainingLengthAfter)\n            ];\n        }\n    }\n    toString() {\n        return `${this.modified ? 'M' : 'U'}:${lengthToObj(this.lengthBefore)} -> ${lengthToObj(this.lengthAfter)}`;\n    }\n}\nfunction toLengthMapping(textEditInfos) {\n    const result = [];\n    let lastOffset = lengthZero;\n    for (const textEditInfo of textEditInfos) {\n        const spaceLength = lengthDiffNonNegative(lastOffset, textEditInfo.startOffset);\n        if (!lengthIsZero(spaceLength)) {\n            result.push(new LengthMapping(false, spaceLength, spaceLength));\n        }\n        const lengthBefore = lengthDiffNonNegative(textEditInfo.startOffset, textEditInfo.endOffset);\n        result.push(new LengthMapping(true, lengthBefore, textEditInfo.newLength));\n        lastOffset = textEditInfo.endOffset;\n    }\n    return result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { splitLines } from '../../../../../base/common/strings.js';\nimport { Range } from '../../../core/range.js';\nimport { TextLength } from '../../../core/textLength.js';\n/**\n * The end must be greater than or equal to the start.\n*/\nexport function lengthDiff(startLineCount, startColumnCount, endLineCount, endColumnCount) {\n    return (startLineCount !== endLineCount)\n        ? toLength(endLineCount - startLineCount, endColumnCount)\n        : toLength(0, endColumnCount - startColumnCount);\n}\nexport const lengthZero = 0;\nexport function lengthIsZero(length) {\n    return length === 0;\n}\n/*\n * We have 52 bits available in a JS number.\n * We use the upper 26 bits to store the line and the lower 26 bits to store the column.\n */\n///*\nconst factor = 2 ** 26;\n/*/\nconst factor = 1000000;\n// */\nexport function toLength(lineCount, columnCount) {\n    // llllllllllllllllllllllllllcccccccccccccccccccccccccc (52 bits)\n    //       line count (26 bits)    column count (26 bits)\n    // If there is no overflow (all values/sums below 2^26 = 67108864),\n    // we have `toLength(lns1, cols1) + toLength(lns2, cols2) = toLength(lns1 + lns2, cols1 + cols2)`.\n    return (lineCount * factor + columnCount);\n}\nexport function lengthToObj(length) {\n    const l = length;\n    const lineCount = Math.floor(l / factor);\n    const columnCount = l - lineCount * factor;\n    return new TextLength(lineCount, columnCount);\n}\nexport function lengthGetLineCount(length) {\n    return Math.floor(length / factor);\n}\n/**\n * Returns the amount of columns of the given length, assuming that it does not span any line.\n*/\nexport function lengthGetColumnCountIfZeroLineCount(length) {\n    return length;\n}\nexport function lengthAdd(l1, l2) {\n    let r = l1 + l2;\n    if (l2 >= factor) {\n        r = r - (l1 % factor);\n    }\n    return r;\n}\nexport function sumLengths(items, lengthFn) {\n    return items.reduce((a, b) => lengthAdd(a, lengthFn(b)), lengthZero);\n}\nexport function lengthEquals(length1, length2) {\n    return length1 === length2;\n}\n/**\n * Returns a non negative length `result` such that `lengthAdd(length1, result) = length2`, or zero if such length does not exist.\n */\nexport function lengthDiffNonNegative(length1, length2) {\n    const l1 = length1;\n    const l2 = length2;\n    const diff = l2 - l1;\n    if (diff <= 0) {\n        // line-count of length1 is higher than line-count of length2\n        // or they are equal and column-count of length1 is higher than column-count of length2\n        return lengthZero;\n    }\n    const lineCount1 = Math.floor(l1 / factor);\n    const lineCount2 = Math.floor(l2 / factor);\n    const colCount2 = l2 - lineCount2 * factor;\n    if (lineCount1 === lineCount2) {\n        const colCount1 = l1 - lineCount1 * factor;\n        return toLength(0, colCount2 - colCount1);\n    }\n    else {\n        return toLength(lineCount2 - lineCount1, colCount2);\n    }\n}\nexport function lengthLessThan(length1, length2) {\n    // First, compare line counts, then column counts.\n    return length1 < length2;\n}\nexport function lengthLessThanEqual(length1, length2) {\n    return length1 <= length2;\n}\nexport function lengthGreaterThanEqual(length1, length2) {\n    return length1 >= length2;\n}\nexport function positionToLength(position) {\n    return toLength(position.lineNumber - 1, position.column - 1);\n}\nexport function lengthsToRange(lengthStart, lengthEnd) {\n    const l = lengthStart;\n    const lineCount = Math.floor(l / factor);\n    const colCount = l - lineCount * factor;\n    const l2 = lengthEnd;\n    const lineCount2 = Math.floor(l2 / factor);\n    const colCount2 = l2 - lineCount2 * factor;\n    return new Range(lineCount + 1, colCount + 1, lineCount2 + 1, colCount2 + 1);\n}\nexport function lengthOfString(str) {\n    const lines = splitLines(str);\n    return toLength(lines.length - 1, lines[lines.length - 1].length);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ListAstNode } from './ast.js';\n/**\n * Concatenates a list of (2,3) AstNode's into a single (2,3) AstNode.\n * This mutates the items of the input array!\n * If all items have the same height, this method has runtime O(items.length).\n * Otherwise, it has runtime O(items.length * max(log(items.length), items.max(i => i.height))).\n*/\nexport function concat23Trees(items) {\n    if (items.length === 0) {\n        return null;\n    }\n    if (items.length === 1) {\n        return items[0];\n    }\n    let i = 0;\n    /**\n     * Reads nodes of same height and concatenates them to a single node.\n    */\n    function readNode() {\n        if (i >= items.length) {\n            return null;\n        }\n        const start = i;\n        const height = items[start].listHeight;\n        i++;\n        while (i < items.length && items[i].listHeight === height) {\n            i++;\n        }\n        if (i - start >= 2) {\n            return concat23TreesOfSameHeight(start === 0 && i === items.length ? items : items.slice(start, i), false);\n        }\n        else {\n            return items[start];\n        }\n    }\n    // The items might not have the same height.\n    // We merge all items by using a binary concat operator.\n    let first = readNode(); // There must be a first item\n    let second = readNode();\n    if (!second) {\n        return first;\n    }\n    for (let item = readNode(); item; item = readNode()) {\n        // Prefer concatenating smaller trees, as the runtime of concat depends on the tree height.\n        if (heightDiff(first, second) <= heightDiff(second, item)) {\n            first = concat(first, second);\n            second = item;\n        }\n        else {\n            second = concat(second, item);\n        }\n    }\n    const result = concat(first, second);\n    return result;\n}\nexport function concat23TreesOfSameHeight(items, createImmutableLists = false) {\n    if (items.length === 0) {\n        return null;\n    }\n    if (items.length === 1) {\n        return items[0];\n    }\n    let length = items.length;\n    // All trees have same height, just create parent nodes.\n    while (length > 3) {\n        const newLength = length >> 1;\n        for (let i = 0; i < newLength; i++) {\n            const j = i << 1;\n            items[i] = ListAstNode.create23(items[j], items[j + 1], j + 3 === length ? items[j + 2] : null, createImmutableLists);\n        }\n        length = newLength;\n    }\n    return ListAstNode.create23(items[0], items[1], length >= 3 ? items[2] : null, createImmutableLists);\n}\nfunction heightDiff(node1, node2) {\n    return Math.abs(node1.listHeight - node2.listHeight);\n}\nfunction concat(node1, node2) {\n    if (node1.listHeight === node2.listHeight) {\n        return ListAstNode.create23(node1, node2, null, false);\n    }\n    else if (node1.listHeight > node2.listHeight) {\n        // node1 is the tree we want to insert into\n        return append(node1, node2);\n    }\n    else {\n        return prepend(node2, node1);\n    }\n}\n/**\n * Appends the given node to the end of this (2,3) tree.\n * Returns the new root.\n*/\nfunction append(list, nodeToAppend) {\n    list = list.toMutable();\n    let curNode = list;\n    const parents = [];\n    let nodeToAppendOfCorrectHeight;\n    while (true) {\n        // assert nodeToInsert.listHeight <= curNode.listHeight\n        if (nodeToAppend.listHeight === curNode.listHeight) {\n            nodeToAppendOfCorrectHeight = nodeToAppend;\n            break;\n        }\n        // assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n        if (curNode.kind !== 4 /* AstNodeKind.List */) {\n            throw new Error('unexpected');\n        }\n        parents.push(curNode);\n        // assert 2 <= curNode.childrenLength <= 3\n        curNode = curNode.makeLastElementMutable();\n    }\n    // assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n    for (let i = parents.length - 1; i >= 0; i--) {\n        const parent = parents[i];\n        if (nodeToAppendOfCorrectHeight) {\n            // Can we take the element?\n            if (parent.childrenLength >= 3) {\n                // assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n                // we need to split to maintain (2,3)-tree property.\n                // Send the third element + the new element to the parent.\n                nodeToAppendOfCorrectHeight = ListAstNode.create23(parent.unappendChild(), nodeToAppendOfCorrectHeight, null, false);\n            }\n            else {\n                parent.appendChildOfSameHeight(nodeToAppendOfCorrectHeight);\n                nodeToAppendOfCorrectHeight = undefined;\n            }\n        }\n        else {\n            parent.handleChildrenChanged();\n        }\n    }\n    if (nodeToAppendOfCorrectHeight) {\n        return ListAstNode.create23(list, nodeToAppendOfCorrectHeight, null, false);\n    }\n    else {\n        return list;\n    }\n}\n/**\n * Prepends the given node to the end of this (2,3) tree.\n * Returns the new root.\n*/\nfunction prepend(list, nodeToAppend) {\n    list = list.toMutable();\n    let curNode = list;\n    const parents = [];\n    // assert nodeToInsert.listHeight <= curNode.listHeight\n    while (nodeToAppend.listHeight !== curNode.listHeight) {\n        // assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n        if (curNode.kind !== 4 /* AstNodeKind.List */) {\n            throw new Error('unexpected');\n        }\n        parents.push(curNode);\n        // assert 2 <= curNode.childrenFast.length <= 3\n        curNode = curNode.makeFirstElementMutable();\n    }\n    let nodeToPrependOfCorrectHeight = nodeToAppend;\n    // assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n    for (let i = parents.length - 1; i >= 0; i--) {\n        const parent = parents[i];\n        if (nodeToPrependOfCorrectHeight) {\n            // Can we take the element?\n            if (parent.childrenLength >= 3) {\n                // assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n                // we need to split to maintain (2,3)-tree property.\n                // Send the third element + the new element to the parent.\n                nodeToPrependOfCorrectHeight = ListAstNode.create23(nodeToPrependOfCorrectHeight, parent.unprependChild(), null, false);\n            }\n            else {\n                parent.prependChildOfSameHeight(nodeToPrependOfCorrectHeight);\n                nodeToPrependOfCorrectHeight = undefined;\n            }\n        }\n        else {\n            parent.handleChildrenChanged();\n        }\n    }\n    if (nodeToPrependOfCorrectHeight) {\n        return ListAstNode.create23(nodeToPrependOfCorrectHeight, list, null, false);\n    }\n    else {\n        return list;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { lengthAdd, lengthZero, lengthLessThan } from './length.js';\n/**\n * Allows to efficiently find a longest child at a given offset in a fixed node.\n * The requested offsets must increase monotonously.\n*/\nexport class NodeReader {\n    constructor(node) {\n        this.lastOffset = lengthZero;\n        this.nextNodes = [node];\n        this.offsets = [lengthZero];\n        this.idxs = [];\n    }\n    /**\n     * Returns the longest node at `offset` that satisfies the predicate.\n     * @param offset must be greater than or equal to the last offset this method has been called with!\n    */\n    readLongestNodeAt(offset, predicate) {\n        if (lengthLessThan(offset, this.lastOffset)) {\n            throw new Error('Invalid offset');\n        }\n        this.lastOffset = offset;\n        // Find the longest node of all those that are closest to the current offset.\n        while (true) {\n            const curNode = lastOrUndefined(this.nextNodes);\n            if (!curNode) {\n                return undefined;\n            }\n            const curNodeOffset = lastOrUndefined(this.offsets);\n            if (lengthLessThan(offset, curNodeOffset)) {\n                // The next best node is not here yet.\n                // The reader must advance before a cached node is hit.\n                return undefined;\n            }\n            if (lengthLessThan(curNodeOffset, offset)) {\n                // The reader is ahead of the current node.\n                if (lengthAdd(curNodeOffset, curNode.length) <= offset) {\n                    // The reader is after the end of the current node.\n                    this.nextNodeAfterCurrent();\n                }\n                else {\n                    // The reader is somewhere in the current node.\n                    const nextChildIdx = getNextChildIdx(curNode);\n                    if (nextChildIdx !== -1) {\n                        // Go to the first child and repeat.\n                        this.nextNodes.push(curNode.getChild(nextChildIdx));\n                        this.offsets.push(curNodeOffset);\n                        this.idxs.push(nextChildIdx);\n                    }\n                    else {\n                        // We don't have children\n                        this.nextNodeAfterCurrent();\n                    }\n                }\n            }\n            else {\n                // readerOffsetBeforeChange === curNodeOffset\n                if (predicate(curNode)) {\n                    this.nextNodeAfterCurrent();\n                    return curNode;\n                }\n                else {\n                    const nextChildIdx = getNextChildIdx(curNode);\n                    // look for shorter node\n                    if (nextChildIdx === -1) {\n                        // There is no shorter node.\n                        this.nextNodeAfterCurrent();\n                        return undefined;\n                    }\n                    else {\n                        // Descend into first child & repeat.\n                        this.nextNodes.push(curNode.getChild(nextChildIdx));\n                        this.offsets.push(curNodeOffset);\n                        this.idxs.push(nextChildIdx);\n                    }\n                }\n            }\n        }\n    }\n    // Navigates to the longest node that continues after the current node.\n    nextNodeAfterCurrent() {\n        while (true) {\n            const currentOffset = lastOrUndefined(this.offsets);\n            const currentNode = lastOrUndefined(this.nextNodes);\n            this.nextNodes.pop();\n            this.offsets.pop();\n            if (this.idxs.length === 0) {\n                // We just popped the root node, there is no next node.\n                break;\n            }\n            // Parent is not undefined, because idxs is not empty\n            const parent = lastOrUndefined(this.nextNodes);\n            const nextChildIdx = getNextChildIdx(parent, this.idxs[this.idxs.length - 1]);\n            if (nextChildIdx !== -1) {\n                this.nextNodes.push(parent.getChild(nextChildIdx));\n                this.offsets.push(lengthAdd(currentOffset, currentNode.length));\n                this.idxs[this.idxs.length - 1] = nextChildIdx;\n                break;\n            }\n            else {\n                this.idxs.pop();\n            }\n            // We fully consumed the parent.\n            // Current node is now parent, so call nextNodeAfterCurrent again\n        }\n    }\n}\nfunction getNextChildIdx(node, curIdx = -1) {\n    while (true) {\n        curIdx++;\n        if (curIdx >= node.childrenLength) {\n            return -1;\n        }\n        if (node.getChild(curIdx)) {\n            return curIdx;\n        }\n    }\n}\nfunction lastOrUndefined(arr) {\n    return arr.length > 0 ? arr[arr.length - 1] : undefined;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { InvalidBracketAstNode, ListAstNode, PairAstNode, TextAstNode } from './ast.js';\nimport { BeforeEditPositionMapper } from './beforeEditPositionMapper.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nimport { lengthIsZero, lengthLessThan } from './length.js';\nimport { concat23Trees, concat23TreesOfSameHeight } from './concat23Trees.js';\nimport { NodeReader } from './nodeReader.js';\n/**\n * Non incrementally built ASTs are immutable.\n*/\nexport function parseDocument(tokenizer, edits, oldNode, createImmutableLists) {\n    const parser = new Parser(tokenizer, edits, oldNode, createImmutableLists);\n    return parser.parseDocument();\n}\n/**\n * Non incrementally built ASTs are immutable.\n*/\nclass Parser {\n    constructor(tokenizer, edits, oldNode, createImmutableLists) {\n        this.tokenizer = tokenizer;\n        this.createImmutableLists = createImmutableLists;\n        this._itemsConstructed = 0;\n        this._itemsFromCache = 0;\n        if (oldNode && createImmutableLists) {\n            throw new Error('Not supported');\n        }\n        this.oldNodeReader = oldNode ? new NodeReader(oldNode) : undefined;\n        this.positionMapper = new BeforeEditPositionMapper(edits);\n    }\n    parseDocument() {\n        this._itemsConstructed = 0;\n        this._itemsFromCache = 0;\n        let result = this.parseList(SmallImmutableSet.getEmpty(), 0);\n        if (!result) {\n            result = ListAstNode.getEmpty();\n        }\n        return result;\n    }\n    parseList(openedBracketIds, level) {\n        const items = [];\n        while (true) {\n            let child = this.tryReadChildFromCache(openedBracketIds);\n            if (!child) {\n                const token = this.tokenizer.peek();\n                if (!token ||\n                    (token.kind === 2 /* TokenKind.ClosingBracket */ &&\n                        token.bracketIds.intersects(openedBracketIds))) {\n                    break;\n                }\n                child = this.parseChild(openedBracketIds, level + 1);\n            }\n            if (child.kind === 4 /* AstNodeKind.List */ && child.childrenLength === 0) {\n                continue;\n            }\n            items.push(child);\n        }\n        // When there is no oldNodeReader, all items are created from scratch and must have the same height.\n        const result = this.oldNodeReader ? concat23Trees(items) : concat23TreesOfSameHeight(items, this.createImmutableLists);\n        return result;\n    }\n    tryReadChildFromCache(openedBracketIds) {\n        if (this.oldNodeReader) {\n            const maxCacheableLength = this.positionMapper.getDistanceToNextChange(this.tokenizer.offset);\n            if (maxCacheableLength === null || !lengthIsZero(maxCacheableLength)) {\n                const cachedNode = this.oldNodeReader.readLongestNodeAt(this.positionMapper.getOffsetBeforeChange(this.tokenizer.offset), curNode => {\n                    // The edit could extend the ending token, thus we cannot re-use nodes that touch the edit.\n                    // If there is no edit anymore, we can re-use the node in any case.\n                    if (maxCacheableLength !== null && !lengthLessThan(curNode.length, maxCacheableLength)) {\n                        // Either the node contains edited text or touches edited text.\n                        // In the latter case, brackets might have been extended (`end` -> `ending`), so even touching nodes cannot be reused.\n                        return false;\n                    }\n                    const canBeReused = curNode.canBeReused(openedBracketIds);\n                    return canBeReused;\n                });\n                if (cachedNode) {\n                    this._itemsFromCache++;\n                    this.tokenizer.skip(cachedNode.length);\n                    return cachedNode;\n                }\n            }\n        }\n        return undefined;\n    }\n    parseChild(openedBracketIds, level) {\n        this._itemsConstructed++;\n        const token = this.tokenizer.read();\n        switch (token.kind) {\n            case 2 /* TokenKind.ClosingBracket */:\n                return new InvalidBracketAstNode(token.bracketIds, token.length);\n            case 0 /* TokenKind.Text */:\n                return token.astNode;\n            case 1 /* TokenKind.OpeningBracket */: {\n                if (level > 300) {\n                    // To prevent stack overflows\n                    return new TextAstNode(token.length);\n                }\n                const set = openedBracketIds.merge(token.bracketIds);\n                const child = this.parseList(set, level + 1);\n                const nextToken = this.tokenizer.peek();\n                if (nextToken &&\n                    nextToken.kind === 2 /* TokenKind.ClosingBracket */ &&\n                    (nextToken.bracketId === token.bracketId || nextToken.bracketIds.intersects(token.bracketIds))) {\n                    this.tokenizer.read();\n                    return PairAstNode.create(token.astNode, child, nextToken.astNode);\n                }\n                else {\n                    return PairAstNode.create(token.astNode, child, null);\n                }\n            }\n            default:\n                throw new Error('unexpected');\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst emptyArr = [];\n/**\n * Represents an immutable set that works best for a small number of elements (less than 32).\n * It uses bits to encode element membership efficiently.\n*/\nexport class SmallImmutableSet {\n    static { this.cache = new Array(129); }\n    static create(items, additionalItems) {\n        if (items <= 128 && additionalItems.length === 0) {\n            // We create a cache of 128=2^7 elements to cover all sets with up to 7 (dense) elements.\n            let cached = SmallImmutableSet.cache[items];\n            if (!cached) {\n                cached = new SmallImmutableSet(items, additionalItems);\n                SmallImmutableSet.cache[items] = cached;\n            }\n            return cached;\n        }\n        return new SmallImmutableSet(items, additionalItems);\n    }\n    static { this.empty = SmallImmutableSet.create(0, emptyArr); }\n    static getEmpty() {\n        return this.empty;\n    }\n    constructor(items, additionalItems) {\n        this.items = items;\n        this.additionalItems = additionalItems;\n    }\n    add(value, keyProvider) {\n        const key = keyProvider.getKey(value);\n        let idx = key >> 5; // divided by 32\n        if (idx === 0) {\n            // fast path\n            const newItem = (1 << key) | this.items;\n            if (newItem === this.items) {\n                return this;\n            }\n            return SmallImmutableSet.create(newItem, this.additionalItems);\n        }\n        idx--;\n        const newItems = this.additionalItems.slice(0);\n        while (newItems.length < idx) {\n            newItems.push(0);\n        }\n        newItems[idx] |= 1 << (key & 31);\n        return SmallImmutableSet.create(this.items, newItems);\n    }\n    merge(other) {\n        const merged = this.items | other.items;\n        if (this.additionalItems === emptyArr && other.additionalItems === emptyArr) {\n            // fast path\n            if (merged === this.items) {\n                return this;\n            }\n            if (merged === other.items) {\n                return other;\n            }\n            return SmallImmutableSet.create(merged, emptyArr);\n        }\n        // This can be optimized, but it's not a common case\n        const newItems = [];\n        for (let i = 0; i < Math.max(this.additionalItems.length, other.additionalItems.length); i++) {\n            const item1 = this.additionalItems[i] || 0;\n            const item2 = other.additionalItems[i] || 0;\n            newItems.push(item1 | item2);\n        }\n        return SmallImmutableSet.create(merged, newItems);\n    }\n    intersects(other) {\n        if ((this.items & other.items) !== 0) {\n            return true;\n        }\n        for (let i = 0; i < Math.min(this.additionalItems.length, other.additionalItems.length); i++) {\n            if ((this.additionalItems[i] & other.additionalItems[i]) !== 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nexport const identityKeyProvider = {\n    getKey(value) {\n        return value;\n    }\n};\n/**\n * Assigns values a unique incrementing key.\n*/\nexport class DenseKeyProvider {\n    constructor() {\n        this.items = new Map();\n    }\n    getKey(value) {\n        let existing = this.items.get(value);\n        if (existing === undefined) {\n            existing = this.items.size;\n            this.items.set(value, existing);\n        }\n        return existing;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { NotSupportedError } from '../../../../../base/common/errors.js';\nimport { TokenMetadata } from '../../../encodedTokenAttributes.js';\nimport { TextAstNode } from './ast.js';\nimport { lengthAdd, lengthDiff, lengthGetColumnCountIfZeroLineCount, lengthToObj, lengthZero, toLength } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nexport class Token {\n    constructor(length, kind, \n    /**\n     * If this token is an opening bracket, this is the id of the opening bracket.\n     * If this token is a closing bracket, this is the id of the first opening bracket that is closed by this bracket.\n     * Otherwise, it is -1.\n     */\n    bracketId, \n    /**\n     * If this token is an opening bracket, this just contains `bracketId`.\n     * If this token is a closing bracket, this lists all opening bracket ids, that it closes.\n     * Otherwise, it is empty.\n     */\n    bracketIds, astNode) {\n        this.length = length;\n        this.kind = kind;\n        this.bracketId = bracketId;\n        this.bracketIds = bracketIds;\n        this.astNode = astNode;\n    }\n}\nexport class TextBufferTokenizer {\n    constructor(textModel, bracketTokens) {\n        this.textModel = textModel;\n        this.bracketTokens = bracketTokens;\n        this.reader = new NonPeekableTextBufferTokenizer(this.textModel, this.bracketTokens);\n        this._offset = lengthZero;\n        this.didPeek = false;\n        this.peeked = null;\n        this.textBufferLineCount = textModel.getLineCount();\n        this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n    }\n    get offset() {\n        return this._offset;\n    }\n    get length() {\n        return toLength(this.textBufferLineCount - 1, this.textBufferLastLineLength);\n    }\n    skip(length) {\n        this.didPeek = false;\n        this._offset = lengthAdd(this._offset, length);\n        const obj = lengthToObj(this._offset);\n        this.reader.setPosition(obj.lineCount, obj.columnCount);\n    }\n    read() {\n        let token;\n        if (this.peeked) {\n            this.didPeek = false;\n            token = this.peeked;\n        }\n        else {\n            token = this.reader.read();\n        }\n        if (token) {\n            this._offset = lengthAdd(this._offset, token.length);\n        }\n        return token;\n    }\n    peek() {\n        if (!this.didPeek) {\n            this.peeked = this.reader.read();\n            this.didPeek = true;\n        }\n        return this.peeked;\n    }\n}\n/**\n * Does not support peek.\n*/\nclass NonPeekableTextBufferTokenizer {\n    constructor(textModel, bracketTokens) {\n        this.textModel = textModel;\n        this.bracketTokens = bracketTokens;\n        this.lineIdx = 0;\n        this.line = null;\n        this.lineCharOffset = 0;\n        this.lineTokens = null;\n        this.lineTokenOffset = 0;\n        /** Must be a zero line token. The end of the document cannot be peeked. */\n        this.peekedToken = null;\n        this.textBufferLineCount = textModel.getLineCount();\n        this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n    }\n    setPosition(lineIdx, column) {\n        // We must not jump into a token!\n        if (lineIdx === this.lineIdx) {\n            this.lineCharOffset = column;\n            if (this.line !== null) {\n                this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n            }\n        }\n        else {\n            this.lineIdx = lineIdx;\n            this.lineCharOffset = column;\n            this.line = null;\n        }\n        this.peekedToken = null;\n    }\n    read() {\n        if (this.peekedToken) {\n            const token = this.peekedToken;\n            this.peekedToken = null;\n            this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(token.length);\n            return token;\n        }\n        if (this.lineIdx > this.textBufferLineCount - 1 || (this.lineIdx === this.textBufferLineCount - 1 && this.lineCharOffset >= this.textBufferLastLineLength)) {\n            // We are after the end\n            return null;\n        }\n        if (this.line === null) {\n            this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n            this.line = this.lineTokens.getLineContent();\n            this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n        }\n        const startLineIdx = this.lineIdx;\n        const startLineCharOffset = this.lineCharOffset;\n        // limits the length of text tokens.\n        // If text tokens get too long, incremental updates will be slow\n        let lengthHeuristic = 0;\n        while (true) {\n            const lineTokens = this.lineTokens;\n            const tokenCount = lineTokens.getCount();\n            let peekedBracketToken = null;\n            if (this.lineTokenOffset < tokenCount) {\n                const tokenMetadata = lineTokens.getMetadata(this.lineTokenOffset);\n                while (this.lineTokenOffset + 1 < tokenCount && tokenMetadata === lineTokens.getMetadata(this.lineTokenOffset + 1)) {\n                    // Skip tokens that are identical.\n                    // Sometimes, (bracket) identifiers are split up into multiple tokens.\n                    this.lineTokenOffset++;\n                }\n                const isOther = TokenMetadata.getTokenType(tokenMetadata) === 0 /* StandardTokenType.Other */;\n                const containsBracketType = TokenMetadata.containsBalancedBrackets(tokenMetadata);\n                const endOffset = lineTokens.getEndOffset(this.lineTokenOffset);\n                // Is there a bracket token next? Only consume text.\n                if (containsBracketType && isOther && this.lineCharOffset < endOffset) {\n                    const languageId = lineTokens.getLanguageId(this.lineTokenOffset);\n                    const text = this.line.substring(this.lineCharOffset, endOffset);\n                    const brackets = this.bracketTokens.getSingleLanguageBracketTokens(languageId);\n                    const regexp = brackets.regExpGlobal;\n                    if (regexp) {\n                        regexp.lastIndex = 0;\n                        const match = regexp.exec(text);\n                        if (match) {\n                            peekedBracketToken = brackets.getToken(match[0]);\n                            if (peekedBracketToken) {\n                                // Consume leading text of the token\n                                this.lineCharOffset += match.index;\n                            }\n                        }\n                    }\n                }\n                lengthHeuristic += endOffset - this.lineCharOffset;\n                if (peekedBracketToken) {\n                    // Don't skip the entire token, as a single token could contain multiple brackets.\n                    if (startLineIdx !== this.lineIdx || startLineCharOffset !== this.lineCharOffset) {\n                        // There is text before the bracket\n                        this.peekedToken = peekedBracketToken;\n                        break;\n                    }\n                    else {\n                        // Consume the peeked token\n                        this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(peekedBracketToken.length);\n                        return peekedBracketToken;\n                    }\n                }\n                else {\n                    // Skip the entire token, as the token contains no brackets at all.\n                    this.lineTokenOffset++;\n                    this.lineCharOffset = endOffset;\n                }\n            }\n            else {\n                if (this.lineIdx === this.textBufferLineCount - 1) {\n                    break;\n                }\n                this.lineIdx++;\n                this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n                this.lineTokenOffset = 0;\n                this.line = this.lineTokens.getLineContent();\n                this.lineCharOffset = 0;\n                lengthHeuristic += 33; // max 1000/33 = 30 lines\n                // This limits the amount of work to recompute min-indentation\n                if (lengthHeuristic > 1000) {\n                    // only break (automatically) at the end of line.\n                    break;\n                }\n            }\n            if (lengthHeuristic > 1500) {\n                // Eventually break regardless of the line length so that\n                // very long lines do not cause bad performance.\n                // This effective limits max indentation to 500, as\n                // indentation is not computed across multiple text nodes.\n                break;\n            }\n        }\n        // If a token contains some proper indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION}),\n        // unless the line is too long.\n        // Thus, the min indentation of the document is the minimum min indentation of every text node.\n        const length = lengthDiff(startLineIdx, startLineCharOffset, this.lineIdx, this.lineCharOffset);\n        return new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n    }\n}\nexport class FastTokenizer {\n    constructor(text, brackets) {\n        this.text = text;\n        this._offset = lengthZero;\n        this.idx = 0;\n        const regExpStr = brackets.getRegExpStr();\n        const regexp = regExpStr ? new RegExp(regExpStr + '|\\n', 'gi') : null;\n        const tokens = [];\n        let match;\n        let curLineCount = 0;\n        let lastLineBreakOffset = 0;\n        let lastTokenEndOffset = 0;\n        let lastTokenEndLine = 0;\n        const smallTextTokens0Line = [];\n        for (let i = 0; i < 60; i++) {\n            smallTextTokens0Line.push(new Token(toLength(0, i), 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(0, i))));\n        }\n        const smallTextTokens1Line = [];\n        for (let i = 0; i < 60; i++) {\n            smallTextTokens1Line.push(new Token(toLength(1, i), 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(1, i))));\n        }\n        if (regexp) {\n            regexp.lastIndex = 0;\n            // If a token contains indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION})\n            while ((match = regexp.exec(text)) !== null) {\n                const curOffset = match.index;\n                const value = match[0];\n                if (value === '\\n') {\n                    curLineCount++;\n                    lastLineBreakOffset = curOffset + 1;\n                }\n                else {\n                    if (lastTokenEndOffset !== curOffset) {\n                        let token;\n                        if (lastTokenEndLine === curLineCount) {\n                            const colCount = curOffset - lastTokenEndOffset;\n                            if (colCount < smallTextTokens0Line.length) {\n                                token = smallTextTokens0Line[colCount];\n                            }\n                            else {\n                                const length = toLength(0, colCount);\n                                token = new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n                            }\n                        }\n                        else {\n                            const lineCount = curLineCount - lastTokenEndLine;\n                            const colCount = curOffset - lastLineBreakOffset;\n                            if (lineCount === 1 && colCount < smallTextTokens1Line.length) {\n                                token = smallTextTokens1Line[colCount];\n                            }\n                            else {\n                                const length = toLength(lineCount, colCount);\n                                token = new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n                            }\n                        }\n                        tokens.push(token);\n                    }\n                    // value is matched by regexp, so the token must exist\n                    tokens.push(brackets.getToken(value));\n                    lastTokenEndOffset = curOffset + value.length;\n                    lastTokenEndLine = curLineCount;\n                }\n            }\n        }\n        const offset = text.length;\n        if (lastTokenEndOffset !== offset) {\n            const length = (lastTokenEndLine === curLineCount)\n                ? toLength(0, offset - lastTokenEndOffset)\n                : toLength(curLineCount - lastTokenEndLine, offset - lastLineBreakOffset);\n            tokens.push(new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length)));\n        }\n        this.length = toLength(curLineCount, offset - lastLineBreakOffset);\n        this.tokens = tokens;\n    }\n    get offset() {\n        return this._offset;\n    }\n    read() {\n        return this.tokens[this.idx++] || null;\n    }\n    peek() {\n        return this.tokens[this.idx] || null;\n    }\n    skip(length) {\n        throw new NotSupportedError();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Selection } from '../core/selection.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { TextChange, compressConsecutiveTextChanges } from '../core/textChange.js';\nimport * as buffer from '../../../base/common/buffer.js';\nimport { basename } from '../../../base/common/resources.js';\nfunction uriGetComparisonKey(resource) {\n    return resource.toString();\n}\nexport class SingleModelEditStackData {\n    static create(model, beforeCursorState) {\n        const alternativeVersionId = model.getAlternativeVersionId();\n        const eol = getModelEOL(model);\n        return new SingleModelEditStackData(alternativeVersionId, alternativeVersionId, eol, eol, beforeCursorState, beforeCursorState, []);\n    }\n    constructor(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes) {\n        this.beforeVersionId = beforeVersionId;\n        this.afterVersionId = afterVersionId;\n        this.beforeEOL = beforeEOL;\n        this.afterEOL = afterEOL;\n        this.beforeCursorState = beforeCursorState;\n        this.afterCursorState = afterCursorState;\n        this.changes = changes;\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        if (textChanges.length > 0) {\n            this.changes = compressConsecutiveTextChanges(this.changes, textChanges);\n        }\n        this.afterEOL = afterEOL;\n        this.afterVersionId = afterVersionId;\n        this.afterCursorState = afterCursorState;\n    }\n    static _writeSelectionsSize(selections) {\n        return 4 + 4 * 4 * (selections ? selections.length : 0);\n    }\n    static _writeSelections(b, selections, offset) {\n        buffer.writeUInt32BE(b, (selections ? selections.length : 0), offset);\n        offset += 4;\n        if (selections) {\n            for (const selection of selections) {\n                buffer.writeUInt32BE(b, selection.selectionStartLineNumber, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.selectionStartColumn, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.positionLineNumber, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.positionColumn, offset);\n                offset += 4;\n            }\n        }\n        return offset;\n    }\n    static _readSelections(b, offset, dest) {\n        const count = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        for (let i = 0; i < count; i++) {\n            const selectionStartLineNumber = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const selectionStartColumn = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const positionLineNumber = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const positionColumn = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            dest.push(new Selection(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn));\n        }\n        return offset;\n    }\n    serialize() {\n        let necessarySize = (+4 // beforeVersionId\n            + 4 // afterVersionId\n            + 1 // beforeEOL\n            + 1 // afterEOL\n            + SingleModelEditStackData._writeSelectionsSize(this.beforeCursorState)\n            + SingleModelEditStackData._writeSelectionsSize(this.afterCursorState)\n            + 4 // change count\n        );\n        for (const change of this.changes) {\n            necessarySize += change.writeSize();\n        }\n        const b = new Uint8Array(necessarySize);\n        let offset = 0;\n        buffer.writeUInt32BE(b, this.beforeVersionId, offset);\n        offset += 4;\n        buffer.writeUInt32BE(b, this.afterVersionId, offset);\n        offset += 4;\n        buffer.writeUInt8(b, this.beforeEOL, offset);\n        offset += 1;\n        buffer.writeUInt8(b, this.afterEOL, offset);\n        offset += 1;\n        offset = SingleModelEditStackData._writeSelections(b, this.beforeCursorState, offset);\n        offset = SingleModelEditStackData._writeSelections(b, this.afterCursorState, offset);\n        buffer.writeUInt32BE(b, this.changes.length, offset);\n        offset += 4;\n        for (const change of this.changes) {\n            offset = change.write(b, offset);\n        }\n        return b.buffer;\n    }\n    static deserialize(source) {\n        const b = new Uint8Array(source);\n        let offset = 0;\n        const beforeVersionId = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const afterVersionId = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const beforeEOL = buffer.readUInt8(b, offset);\n        offset += 1;\n        const afterEOL = buffer.readUInt8(b, offset);\n        offset += 1;\n        const beforeCursorState = [];\n        offset = SingleModelEditStackData._readSelections(b, offset, beforeCursorState);\n        const afterCursorState = [];\n        offset = SingleModelEditStackData._readSelections(b, offset, afterCursorState);\n        const changeCount = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const changes = [];\n        for (let i = 0; i < changeCount; i++) {\n            offset = TextChange.read(b, offset, changes);\n        }\n        return new SingleModelEditStackData(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes);\n    }\n}\nexport class SingleModelEditStackElement {\n    get type() {\n        return 0 /* UndoRedoElementType.Resource */;\n    }\n    get resource() {\n        if (URI.isUri(this.model)) {\n            return this.model;\n        }\n        return this.model.uri;\n    }\n    constructor(label, code, model, beforeCursorState) {\n        this.label = label;\n        this.code = code;\n        this.model = model;\n        this._data = SingleModelEditStackData.create(model, beforeCursorState);\n    }\n    toString() {\n        const data = (this._data instanceof SingleModelEditStackData ? this._data : SingleModelEditStackData.deserialize(this._data));\n        return data.changes.map(change => change.toString()).join(', ');\n    }\n    matchesResource(resource) {\n        const uri = (URI.isUri(this.model) ? this.model : this.model.uri);\n        return (uri.toString() === resource.toString());\n    }\n    setModel(model) {\n        this.model = model;\n    }\n    canAppend(model) {\n        return (this.model === model && this._data instanceof SingleModelEditStackData);\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);\n        }\n    }\n    close() {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n    }\n    open() {\n        if (!(this._data instanceof SingleModelEditStackData)) {\n            this._data = SingleModelEditStackData.deserialize(this._data);\n        }\n    }\n    undo() {\n        if (URI.isUri(this.model)) {\n            // don't have a model\n            throw new Error(`Invalid SingleModelEditStackElement`);\n        }\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        const data = SingleModelEditStackData.deserialize(this._data);\n        this.model._applyUndo(data.changes, data.beforeEOL, data.beforeVersionId, data.beforeCursorState);\n    }\n    redo() {\n        if (URI.isUri(this.model)) {\n            // don't have a model\n            throw new Error(`Invalid SingleModelEditStackElement`);\n        }\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        const data = SingleModelEditStackData.deserialize(this._data);\n        this.model._applyRedo(data.changes, data.afterEOL, data.afterVersionId, data.afterCursorState);\n    }\n    heapSize() {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        return this._data.byteLength + 168 /*heap overhead*/;\n    }\n}\nexport class MultiModelEditStackElement {\n    get resources() {\n        return this._editStackElementsArr.map(editStackElement => editStackElement.resource);\n    }\n    constructor(label, code, editStackElements) {\n        this.label = label;\n        this.code = code;\n        this.type = 1 /* UndoRedoElementType.Workspace */;\n        this._isOpen = true;\n        this._editStackElementsArr = editStackElements.slice(0);\n        this._editStackElementsMap = new Map();\n        for (const editStackElement of this._editStackElementsArr) {\n            const key = uriGetComparisonKey(editStackElement.resource);\n            this._editStackElementsMap.set(key, editStackElement);\n        }\n        this._delegate = null;\n    }\n    prepareUndoRedo() {\n        if (this._delegate) {\n            return this._delegate.prepareUndoRedo(this);\n        }\n    }\n    matchesResource(resource) {\n        const key = uriGetComparisonKey(resource);\n        return (this._editStackElementsMap.has(key));\n    }\n    setModel(model) {\n        const key = uriGetComparisonKey(URI.isUri(model) ? model : model.uri);\n        if (this._editStackElementsMap.has(key)) {\n            this._editStackElementsMap.get(key).setModel(model);\n        }\n    }\n    canAppend(model) {\n        if (!this._isOpen) {\n            return false;\n        }\n        const key = uriGetComparisonKey(model.uri);\n        if (this._editStackElementsMap.has(key)) {\n            const editStackElement = this._editStackElementsMap.get(key);\n            return editStackElement.canAppend(model);\n        }\n        return false;\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        const key = uriGetComparisonKey(model.uri);\n        const editStackElement = this._editStackElementsMap.get(key);\n        editStackElement.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);\n    }\n    close() {\n        this._isOpen = false;\n    }\n    open() {\n        // cannot reopen\n    }\n    undo() {\n        this._isOpen = false;\n        for (const editStackElement of this._editStackElementsArr) {\n            editStackElement.undo();\n        }\n    }\n    redo() {\n        for (const editStackElement of this._editStackElementsArr) {\n            editStackElement.redo();\n        }\n    }\n    heapSize(resource) {\n        const key = uriGetComparisonKey(resource);\n        if (this._editStackElementsMap.has(key)) {\n            const editStackElement = this._editStackElementsMap.get(key);\n            return editStackElement.heapSize();\n        }\n        return 0;\n    }\n    split() {\n        return this._editStackElementsArr;\n    }\n    toString() {\n        const result = [];\n        for (const editStackElement of this._editStackElementsArr) {\n            result.push(`${basename(editStackElement.resource)}: ${editStackElement}`);\n        }\n        return `{${result.join(', ')}}`;\n    }\n}\nfunction getModelEOL(model) {\n    const eol = model.getEOL();\n    if (eol === '\\n') {\n        return 0 /* EndOfLineSequence.LF */;\n    }\n    else {\n        return 1 /* EndOfLineSequence.CRLF */;\n    }\n}\nexport function isEditStackElement(element) {\n    if (!element) {\n        return false;\n    }\n    return ((element instanceof SingleModelEditStackElement) || (element instanceof MultiModelEditStackElement));\n}\nexport class EditStack {\n    constructor(model, undoRedoService) {\n        this._model = model;\n        this._undoRedoService = undoRedoService;\n    }\n    pushStackElement() {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement)) {\n            lastElement.close();\n        }\n    }\n    popStackElement() {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement)) {\n            lastElement.open();\n        }\n    }\n    clear() {\n        this._undoRedoService.removeElements(this._model.uri);\n    }\n    _getOrCreateEditStackElement(beforeCursorState, group) {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement) && lastElement.canAppend(this._model)) {\n            return lastElement;\n        }\n        const newElement = new SingleModelEditStackElement(nls.localize('edit', \"Typing\"), 'undoredo.textBufferEdit', this._model, beforeCursorState);\n        this._undoRedoService.pushElement(newElement, group);\n        return newElement;\n    }\n    pushEOL(eol) {\n        const editStackElement = this._getOrCreateEditStackElement(null, undefined);\n        this._model.setEOL(eol);\n        editStackElement.append(this._model, [], getModelEOL(this._model), this._model.getAlternativeVersionId(), null);\n    }\n    pushEditOperation(beforeCursorState, editOperations, cursorStateComputer, group) {\n        const editStackElement = this._getOrCreateEditStackElement(beforeCursorState, group);\n        const inverseEditOperations = this._model.applyEdits(editOperations, true);\n        const afterCursorState = EditStack._computeCursorState(cursorStateComputer, inverseEditOperations);\n        const textChanges = inverseEditOperations.map((op, index) => ({ index: index, textChange: op.textChange }));\n        textChanges.sort((a, b) => {\n            if (a.textChange.oldPosition === b.textChange.oldPosition) {\n                return a.index - b.index;\n            }\n            return a.textChange.oldPosition - b.textChange.oldPosition;\n        });\n        editStackElement.append(this._model, textChanges.map(op => op.textChange), getModelEOL(this._model), this._model.getAlternativeVersionId(), afterCursorState);\n        return afterCursorState;\n    }\n    static _computeCursorState(cursorStateComputer, inverseEditOperations) {\n        try {\n            return cursorStateComputer ? cursorStateComputer(inverseEditOperations) : null;\n        }\n        catch (e) {\n            onUnexpectedError(e);\n            return null;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { findLast } from '../../../base/common/arraysFind.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Range } from '../core/range.js';\nimport { TextModelPart } from './textModelPart.js';\nimport { computeIndentLevel } from './utils.js';\nimport { HorizontalGuidesState, IndentGuide, IndentGuideHorizontalLine } from '../textModelGuides.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nexport class GuidesTextModelPart extends TextModelPart {\n    constructor(textModel, languageConfigurationService) {\n        super();\n        this.textModel = textModel;\n        this.languageConfigurationService = languageConfigurationService;\n    }\n    getLanguageConfiguration(languageId) {\n        return this.languageConfigurationService.getLanguageConfiguration(languageId);\n    }\n    _computeIndentLevel(lineIndex) {\n        return computeIndentLevel(this.textModel.getLineContent(lineIndex + 1), this.textModel.getOptions().tabSize);\n    }\n    getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n        this.assertNotDisposed();\n        const lineCount = this.textModel.getLineCount();\n        if (lineNumber < 1 || lineNumber > lineCount) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;\n        const offSide = Boolean(foldingRules && foldingRules.offSide);\n        let up_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let up_aboveContentLineIndent = -1;\n        let up_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let up_belowContentLineIndent = -1;\n        const up_resolveIndents = (lineNumber) => {\n            if (up_aboveContentLineIndex !== -1 &&\n                (up_aboveContentLineIndex === -2 ||\n                    up_aboveContentLineIndex > lineNumber - 1)) {\n                up_aboveContentLineIndex = -1;\n                up_aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        up_aboveContentLineIndex = lineIndex;\n                        up_aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (up_belowContentLineIndex === -2) {\n                up_belowContentLineIndex = -1;\n                up_belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        up_belowContentLineIndex = lineIndex;\n                        up_belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n        };\n        let down_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let down_aboveContentLineIndent = -1;\n        let down_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let down_belowContentLineIndent = -1;\n        const down_resolveIndents = (lineNumber) => {\n            if (down_aboveContentLineIndex === -2) {\n                down_aboveContentLineIndex = -1;\n                down_aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        down_aboveContentLineIndex = lineIndex;\n                        down_aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (down_belowContentLineIndex !== -1 &&\n                (down_belowContentLineIndex === -2 ||\n                    down_belowContentLineIndex < lineNumber - 1)) {\n                down_belowContentLineIndex = -1;\n                down_belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        down_belowContentLineIndex = lineIndex;\n                        down_belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n        };\n        let startLineNumber = 0;\n        let goUp = true;\n        let endLineNumber = 0;\n        let goDown = true;\n        let indent = 0;\n        let initialIndent = 0;\n        for (let distance = 0; goUp || goDown; distance++) {\n            const upLineNumber = lineNumber - distance;\n            const downLineNumber = lineNumber + distance;\n            if (distance > 1 && (upLineNumber < 1 || upLineNumber < minLineNumber)) {\n                goUp = false;\n            }\n            if (distance > 1 &&\n                (downLineNumber > lineCount || downLineNumber > maxLineNumber)) {\n                goDown = false;\n            }\n            if (distance > 50000) {\n                // stop processing\n                goUp = false;\n                goDown = false;\n            }\n            let upLineIndentLevel = -1;\n            if (goUp && upLineNumber >= 1) {\n                // compute indent level going up\n                const currentIndent = this._computeIndentLevel(upLineNumber - 1);\n                if (currentIndent >= 0) {\n                    // This line has content (besides whitespace)\n                    // Use the line's indent\n                    up_belowContentLineIndex = upLineNumber - 1;\n                    up_belowContentLineIndent = currentIndent;\n                    upLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);\n                }\n                else {\n                    up_resolveIndents(upLineNumber);\n                    upLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, up_aboveContentLineIndent, up_belowContentLineIndent);\n                }\n            }\n            let downLineIndentLevel = -1;\n            if (goDown && downLineNumber <= lineCount) {\n                // compute indent level going down\n                const currentIndent = this._computeIndentLevel(downLineNumber - 1);\n                if (currentIndent >= 0) {\n                    // This line has content (besides whitespace)\n                    // Use the line's indent\n                    down_aboveContentLineIndex = downLineNumber - 1;\n                    down_aboveContentLineIndent = currentIndent;\n                    downLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);\n                }\n                else {\n                    down_resolveIndents(downLineNumber);\n                    downLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, down_aboveContentLineIndent, down_belowContentLineIndent);\n                }\n            }\n            if (distance === 0) {\n                initialIndent = upLineIndentLevel;\n                continue;\n            }\n            if (distance === 1) {\n                if (downLineNumber <= lineCount &&\n                    downLineIndentLevel >= 0 &&\n                    initialIndent + 1 === downLineIndentLevel) {\n                    // This is the beginning of a scope, we have special handling here, since we want the\n                    // child scope indent to be active, not the parent scope\n                    goUp = false;\n                    startLineNumber = downLineNumber;\n                    endLineNumber = downLineNumber;\n                    indent = downLineIndentLevel;\n                    continue;\n                }\n                if (upLineNumber >= 1 &&\n                    upLineIndentLevel >= 0 &&\n                    upLineIndentLevel - 1 === initialIndent) {\n                    // This is the end of a scope, just like above\n                    goDown = false;\n                    startLineNumber = upLineNumber;\n                    endLineNumber = upLineNumber;\n                    indent = upLineIndentLevel;\n                    continue;\n                }\n                startLineNumber = lineNumber;\n                endLineNumber = lineNumber;\n                indent = initialIndent;\n                if (indent === 0) {\n                    // No need to continue\n                    return { startLineNumber, endLineNumber, indent };\n                }\n            }\n            if (goUp) {\n                if (upLineIndentLevel >= indent) {\n                    startLineNumber = upLineNumber;\n                }\n                else {\n                    goUp = false;\n                }\n            }\n            if (goDown) {\n                if (downLineIndentLevel >= indent) {\n                    endLineNumber = downLineNumber;\n                }\n                else {\n                    goDown = false;\n                }\n            }\n        }\n        return { startLineNumber, endLineNumber, indent };\n    }\n    getLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options) {\n        const result = [];\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            result.push([]);\n        }\n        // If requested, this could be made configurable.\n        const includeSingleLinePairs = true;\n        const bracketPairs = this.textModel.bracketPairs.getBracketPairsInRangeWithMinIndentation(new Range(startLineNumber, 1, endLineNumber, this.textModel.getLineMaxColumn(endLineNumber))).toArray();\n        let activeBracketPairRange = undefined;\n        if (activePosition && bracketPairs.length > 0) {\n            const bracketsContainingActivePosition = (startLineNumber <= activePosition.lineNumber &&\n                activePosition.lineNumber <= endLineNumber\n                // We don't need to query the brackets again if the cursor is in the viewport\n                ? bracketPairs\n                : this.textModel.bracketPairs.getBracketPairsInRange(Range.fromPositions(activePosition)).toArray()).filter((bp) => Range.strictContainsPosition(bp.range, activePosition));\n            activeBracketPairRange = findLast(bracketsContainingActivePosition, (i) => includeSingleLinePairs || i.range.startLineNumber !== i.range.endLineNumber)?.range;\n        }\n        const independentColorPoolPerBracketType = this.textModel.getOptions().bracketPairColorizationOptions.independentColorPoolPerBracketType;\n        const colorProvider = new BracketPairGuidesClassNames();\n        for (const pair of bracketPairs) {\n            /*\n\n\n                    {\n                    |\n                    }\n\n                    {\n                    |\n                    ----}\n\n                ____{\n                |test\n                ----}\n\n                renderHorizontalEndLineAtTheBottom:\n                    {\n                    |\n                    |x}\n                    --\n                renderHorizontalEndLineAtTheBottom:\n                ____{\n                |test\n                | x }\n                ----\n            */\n            if (!pair.closingBracketRange) {\n                continue;\n            }\n            const isActive = activeBracketPairRange && pair.range.equalsRange(activeBracketPairRange);\n            if (!isActive && !options.includeInactive) {\n                continue;\n            }\n            const className = colorProvider.getInlineClassName(pair.nestingLevel, pair.nestingLevelOfEqualBracketType, independentColorPoolPerBracketType) +\n                (options.highlightActive && isActive\n                    ? ' ' + colorProvider.activeClassName\n                    : '');\n            const start = pair.openingBracketRange.getStartPosition();\n            const end = pair.closingBracketRange.getStartPosition();\n            const horizontalGuides = options.horizontalGuides === HorizontalGuidesState.Enabled || (options.horizontalGuides === HorizontalGuidesState.EnabledForActive && isActive);\n            if (pair.range.startLineNumber === pair.range.endLineNumber) {\n                if (includeSingleLinePairs && horizontalGuides) {\n                    result[pair.range.startLineNumber - startLineNumber].push(new IndentGuide(-1, pair.openingBracketRange.getEndPosition().column, className, new IndentGuideHorizontalLine(false, end.column), -1, -1));\n                }\n                continue;\n            }\n            const endVisibleColumn = this.getVisibleColumnFromPosition(end);\n            const startVisibleColumn = this.getVisibleColumnFromPosition(pair.openingBracketRange.getStartPosition());\n            const guideVisibleColumn = Math.min(startVisibleColumn, endVisibleColumn, pair.minVisibleColumnIndentation + 1);\n            let renderHorizontalEndLineAtTheBottom = false;\n            const firstNonWsIndex = strings.firstNonWhitespaceIndex(this.textModel.getLineContent(pair.closingBracketRange.startLineNumber));\n            const hasTextBeforeClosingBracket = firstNonWsIndex < pair.closingBracketRange.startColumn - 1;\n            if (hasTextBeforeClosingBracket) {\n                renderHorizontalEndLineAtTheBottom = true;\n            }\n            const visibleGuideStartLineNumber = Math.max(start.lineNumber, startLineNumber);\n            const visibleGuideEndLineNumber = Math.min(end.lineNumber, endLineNumber);\n            const offset = renderHorizontalEndLineAtTheBottom ? 1 : 0;\n            for (let l = visibleGuideStartLineNumber; l < visibleGuideEndLineNumber + offset; l++) {\n                result[l - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, null, l === start.lineNumber ? start.column : -1, l === end.lineNumber ? end.column : -1));\n            }\n            if (horizontalGuides) {\n                if (start.lineNumber >= startLineNumber && startVisibleColumn > guideVisibleColumn) {\n                    result[start.lineNumber - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, new IndentGuideHorizontalLine(false, start.column), -1, -1));\n                }\n                if (end.lineNumber <= endLineNumber && endVisibleColumn > guideVisibleColumn) {\n                    result[end.lineNumber - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, new IndentGuideHorizontalLine(!renderHorizontalEndLineAtTheBottom, end.column), -1, -1));\n                }\n            }\n        }\n        for (const guides of result) {\n            guides.sort((a, b) => a.visibleColumn - b.visibleColumn);\n        }\n        return result;\n    }\n    getVisibleColumnFromPosition(position) {\n        return (CursorColumns.visibleColumnFromColumn(this.textModel.getLineContent(position.lineNumber), position.column, this.textModel.getOptions().tabSize) + 1);\n    }\n    getLinesIndentGuides(startLineNumber, endLineNumber) {\n        this.assertNotDisposed();\n        const lineCount = this.textModel.getLineCount();\n        if (startLineNumber < 1 || startLineNumber > lineCount) {\n            throw new Error('Illegal value for startLineNumber');\n        }\n        if (endLineNumber < 1 || endLineNumber > lineCount) {\n            throw new Error('Illegal value for endLineNumber');\n        }\n        const options = this.textModel.getOptions();\n        const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;\n        const offSide = Boolean(foldingRules && foldingRules.offSide);\n        const result = new Array(endLineNumber - startLineNumber + 1);\n        let aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let aboveContentLineIndent = -1;\n        let belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let belowContentLineIndent = -1;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const resultIndex = lineNumber - startLineNumber;\n            const currentIndent = this._computeIndentLevel(lineNumber - 1);\n            if (currentIndent >= 0) {\n                // This line has content (besides whitespace)\n                // Use the line's indent\n                aboveContentLineIndex = lineNumber - 1;\n                aboveContentLineIndent = currentIndent;\n                result[resultIndex] = Math.ceil(currentIndent / options.indentSize);\n                continue;\n            }\n            if (aboveContentLineIndex === -2) {\n                aboveContentLineIndex = -1;\n                aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        aboveContentLineIndex = lineIndex;\n                        aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (belowContentLineIndex !== -1 &&\n                (belowContentLineIndex === -2 || belowContentLineIndex < lineNumber - 1)) {\n                belowContentLineIndex = -1;\n                belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        belowContentLineIndex = lineIndex;\n                        belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            result[resultIndex] = this._getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent);\n        }\n        return result;\n    }\n    _getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent) {\n        const options = this.textModel.getOptions();\n        if (aboveContentLineIndent === -1 || belowContentLineIndent === -1) {\n            // At the top or bottom of the file\n            return 0;\n        }\n        else if (aboveContentLineIndent < belowContentLineIndent) {\n            // we are inside the region above\n            return 1 + Math.floor(aboveContentLineIndent / options.indentSize);\n        }\n        else if (aboveContentLineIndent === belowContentLineIndent) {\n            // we are in between two regions\n            return Math.ceil(belowContentLineIndent / options.indentSize);\n        }\n        else {\n            if (offSide) {\n                // same level as region below\n                return Math.ceil(belowContentLineIndent / options.indentSize);\n            }\n            else {\n                // we are inside the region that ends below\n                return 1 + Math.floor(belowContentLineIndent / options.indentSize);\n            }\n        }\n    }\n}\nexport class BracketPairGuidesClassNames {\n    constructor() {\n        this.activeClassName = 'indent-active';\n    }\n    getInlineClassName(nestingLevel, nestingLevelOfEqualBracketType, independentColorPoolPerBracketType) {\n        return this.getInlineClassNameOfLevel(independentColorPoolPerBracketType ? nestingLevelOfEqualBracketType : nestingLevel);\n    }\n    getInlineClassNameOfLevel(level) {\n        // To support a dynamic amount of colors up to 6 colors,\n        // we use a number that is a lcm of all numbers from 1 to 6.\n        return `bracket-indent-guide lvl-${level % 30}`;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class BracketInfo {\n    constructor(range, \n    /** 0-based level */\n    nestingLevel, nestingLevelOfEqualBracketType, isInvalid) {\n        this.range = range;\n        this.nestingLevel = nestingLevel;\n        this.nestingLevelOfEqualBracketType = nestingLevelOfEqualBracketType;\n        this.isInvalid = isInvalid;\n    }\n}\nexport class BracketPairInfo {\n    constructor(range, openingBracketRange, closingBracketRange, \n    /** 0-based */\n    nestingLevel, nestingLevelOfEqualBracketType, bracketPairNode) {\n        this.range = range;\n        this.openingBracketRange = openingBracketRange;\n        this.closingBracketRange = closingBracketRange;\n        this.nestingLevel = nestingLevel;\n        this.nestingLevelOfEqualBracketType = nestingLevelOfEqualBracketType;\n        this.bracketPairNode = bracketPairNode;\n    }\n    get openingBracketInfo() {\n        return this.bracketPairNode.openingBracket.bracketInfo;\n    }\n}\nexport class BracketPairWithMinIndentationInfo extends BracketPairInfo {\n    constructor(range, openingBracketRange, closingBracketRange, \n    /**\n     * 0-based\n    */\n    nestingLevel, nestingLevelOfEqualBracketType, bracketPairNode, \n    /**\n     * -1 if not requested, otherwise the size of the minimum indentation in the bracket pair in terms of visible columns.\n    */\n    minVisibleColumnIndentation) {\n        super(range, openingBracketRange, closingBracketRange, nestingLevel, nestingLevelOfEqualBracketType, bracketPairNode);\n        this.minVisibleColumnIndentation = minVisibleColumnIndentation;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../../base/common/event.js';\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { BracketInfo, BracketPairWithMinIndentationInfo } from '../../../textModelBracketPairs.js';\nimport { TextEditInfo } from './beforeEditPositionMapper.js';\nimport { LanguageAgnosticBracketTokens } from './brackets.js';\nimport { lengthAdd, lengthGreaterThanEqual, lengthLessThan, lengthLessThanEqual, lengthsToRange, lengthZero, positionToLength, toLength } from './length.js';\nimport { parseDocument } from './parser.js';\nimport { DenseKeyProvider } from './smallImmutableSet.js';\nimport { FastTokenizer, TextBufferTokenizer } from './tokenizer.js';\nimport { CallbackIterable } from '../../../../../base/common/arrays.js';\nimport { combineTextEditInfos } from './combineTextEditInfos.js';\nexport class BracketPairsTree extends Disposable {\n    didLanguageChange(languageId) {\n        return this.brackets.didLanguageChange(languageId);\n    }\n    constructor(textModel, getLanguageConfiguration) {\n        super();\n        this.textModel = textModel;\n        this.getLanguageConfiguration = getLanguageConfiguration;\n        this.didChangeEmitter = new Emitter();\n        this.denseKeyProvider = new DenseKeyProvider();\n        this.brackets = new LanguageAgnosticBracketTokens(this.denseKeyProvider, this.getLanguageConfiguration);\n        this.onDidChange = this.didChangeEmitter.event;\n        this.queuedTextEditsForInitialAstWithoutTokens = [];\n        this.queuedTextEdits = [];\n        if (!textModel.tokenization.hasTokens) {\n            const brackets = this.brackets.getSingleLanguageBracketTokens(this.textModel.getLanguageId());\n            const tokenizer = new FastTokenizer(this.textModel.getValue(), brackets);\n            this.initialAstWithoutTokens = parseDocument(tokenizer, [], undefined, true);\n            this.astWithTokens = this.initialAstWithoutTokens;\n        }\n        else if (textModel.tokenization.backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n            // Skip the initial ast, as there is no flickering.\n            // Directly create the tree with token information.\n            this.initialAstWithoutTokens = undefined;\n            this.astWithTokens = this.parseDocumentFromTextBuffer([], undefined, false);\n        }\n        else {\n            // We missed some token changes already, so we cannot use the fast tokenizer + delta increments\n            this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer([], undefined, true);\n            this.astWithTokens = this.initialAstWithoutTokens;\n        }\n    }\n    //#region TextModel events\n    handleDidChangeBackgroundTokenizationState() {\n        if (this.textModel.tokenization.backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n            const wasUndefined = this.initialAstWithoutTokens === undefined;\n            // Clear the initial tree as we can use the tree with token information now.\n            this.initialAstWithoutTokens = undefined;\n            if (!wasUndefined) {\n                this.didChangeEmitter.fire();\n            }\n        }\n    }\n    handleDidChangeTokens({ ranges }) {\n        const edits = ranges.map(r => new TextEditInfo(toLength(r.fromLineNumber - 1, 0), toLength(r.toLineNumber, 0), toLength(r.toLineNumber - r.fromLineNumber + 1, 0)));\n        this.handleEdits(edits, true);\n        if (!this.initialAstWithoutTokens) {\n            this.didChangeEmitter.fire();\n        }\n    }\n    handleContentChanged(change) {\n        const edits = TextEditInfo.fromModelContentChanges(change.changes);\n        this.handleEdits(edits, false);\n    }\n    handleEdits(edits, tokenChange) {\n        // Lazily queue the edits and only apply them when the tree is accessed.\n        const result = combineTextEditInfos(this.queuedTextEdits, edits);\n        this.queuedTextEdits = result;\n        if (this.initialAstWithoutTokens && !tokenChange) {\n            this.queuedTextEditsForInitialAstWithoutTokens = combineTextEditInfos(this.queuedTextEditsForInitialAstWithoutTokens, edits);\n        }\n    }\n    //#endregion\n    flushQueue() {\n        if (this.queuedTextEdits.length > 0) {\n            this.astWithTokens = this.parseDocumentFromTextBuffer(this.queuedTextEdits, this.astWithTokens, false);\n            this.queuedTextEdits = [];\n        }\n        if (this.queuedTextEditsForInitialAstWithoutTokens.length > 0) {\n            if (this.initialAstWithoutTokens) {\n                this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer(this.queuedTextEditsForInitialAstWithoutTokens, this.initialAstWithoutTokens, false);\n            }\n            this.queuedTextEditsForInitialAstWithoutTokens = [];\n        }\n    }\n    /**\n     * @pure (only if isPure = true)\n    */\n    parseDocumentFromTextBuffer(edits, previousAst, immutable) {\n        // Is much faster if `isPure = false`.\n        const isPure = false;\n        const previousAstClone = isPure ? previousAst?.deepClone() : previousAst;\n        const tokenizer = new TextBufferTokenizer(this.textModel, this.brackets);\n        const result = parseDocument(tokenizer, edits, previousAstClone, immutable);\n        return result;\n    }\n    getBracketsInRange(range, onlyColorizedBrackets) {\n        this.flushQueue();\n        const startOffset = toLength(range.startLineNumber - 1, range.startColumn - 1);\n        const endOffset = toLength(range.endLineNumber - 1, range.endColumn - 1);\n        return new CallbackIterable(cb => {\n            const node = this.initialAstWithoutTokens || this.astWithTokens;\n            collectBrackets(node, lengthZero, node.length, startOffset, endOffset, cb, 0, 0, new Map(), onlyColorizedBrackets);\n        });\n    }\n    getBracketPairsInRange(range, includeMinIndentation) {\n        this.flushQueue();\n        const startLength = positionToLength(range.getStartPosition());\n        const endLength = positionToLength(range.getEndPosition());\n        return new CallbackIterable(cb => {\n            const node = this.initialAstWithoutTokens || this.astWithTokens;\n            const context = new CollectBracketPairsContext(cb, includeMinIndentation, this.textModel);\n            collectBracketPairs(node, lengthZero, node.length, startLength, endLength, context, 0, new Map());\n        });\n    }\n    getFirstBracketAfter(position) {\n        this.flushQueue();\n        const node = this.initialAstWithoutTokens || this.astWithTokens;\n        return getFirstBracketAfter(node, lengthZero, node.length, positionToLength(position));\n    }\n    getFirstBracketBefore(position) {\n        this.flushQueue();\n        const node = this.initialAstWithoutTokens || this.astWithTokens;\n        return getFirstBracketBefore(node, lengthZero, node.length, positionToLength(position));\n    }\n}\nfunction getFirstBracketBefore(node, nodeOffsetStart, nodeOffsetEnd, position) {\n    if (node.kind === 4 /* AstNodeKind.List */ || node.kind === 2 /* AstNodeKind.Pair */) {\n        const lengths = [];\n        for (const child of node.children) {\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            lengths.push({ nodeOffsetStart, nodeOffsetEnd });\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n        for (let i = lengths.length - 1; i >= 0; i--) {\n            const { nodeOffsetStart, nodeOffsetEnd } = lengths[i];\n            if (lengthLessThan(nodeOffsetStart, position)) {\n                const result = getFirstBracketBefore(node.children[i], nodeOffsetStart, nodeOffsetEnd, position);\n                if (result) {\n                    return result;\n                }\n            }\n        }\n        return null;\n    }\n    else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n        return null;\n    }\n    else if (node.kind === 1 /* AstNodeKind.Bracket */) {\n        const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n        return {\n            bracketInfo: node.bracketInfo,\n            range\n        };\n    }\n    return null;\n}\nfunction getFirstBracketAfter(node, nodeOffsetStart, nodeOffsetEnd, position) {\n    if (node.kind === 4 /* AstNodeKind.List */ || node.kind === 2 /* AstNodeKind.Pair */) {\n        for (const child of node.children) {\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThan(position, nodeOffsetEnd)) {\n                const result = getFirstBracketAfter(child, nodeOffsetStart, nodeOffsetEnd, position);\n                if (result) {\n                    return result;\n                }\n            }\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n        return null;\n    }\n    else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n        return null;\n    }\n    else if (node.kind === 1 /* AstNodeKind.Bracket */) {\n        const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n        return {\n            bracketInfo: node.bracketInfo,\n            range\n        };\n    }\n    return null;\n}\nfunction collectBrackets(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, level, nestingLevelOfEqualBracketType, levelPerBracketType, onlyColorizedBrackets, parentPairIsIncomplete = false) {\n    if (level > 200) {\n        return true;\n    }\n    whileLoop: while (true) {\n        switch (node.kind) {\n            case 4 /* AstNodeKind.List */: {\n                const childCount = node.childrenLength;\n                for (let i = 0; i < childCount; i++) {\n                    const child = node.getChild(i);\n                    if (!child) {\n                        continue;\n                    }\n                    nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n                    if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                        lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                        const childEndsAfterEnd = lengthGreaterThanEqual(nodeOffsetEnd, endOffset);\n                        if (childEndsAfterEnd) {\n                            // No child after this child in the requested window, don't recurse\n                            node = child;\n                            continue whileLoop;\n                        }\n                        const shouldContinue = collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, level, 0, levelPerBracketType, onlyColorizedBrackets);\n                        if (!shouldContinue) {\n                            return false;\n                        }\n                    }\n                    nodeOffsetStart = nodeOffsetEnd;\n                }\n                return true;\n            }\n            case 2 /* AstNodeKind.Pair */: {\n                const colorize = !onlyColorizedBrackets || !node.closingBracket || node.closingBracket.bracketInfo.closesColorized(node.openingBracket.bracketInfo);\n                let levelPerBracket = 0;\n                if (levelPerBracketType) {\n                    let existing = levelPerBracketType.get(node.openingBracket.text);\n                    if (existing === undefined) {\n                        existing = 0;\n                    }\n                    levelPerBracket = existing;\n                    if (colorize) {\n                        existing++;\n                        levelPerBracketType.set(node.openingBracket.text, existing);\n                    }\n                }\n                const childCount = node.childrenLength;\n                for (let i = 0; i < childCount; i++) {\n                    const child = node.getChild(i);\n                    if (!child) {\n                        continue;\n                    }\n                    nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n                    if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                        lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                        const childEndsAfterEnd = lengthGreaterThanEqual(nodeOffsetEnd, endOffset);\n                        if (childEndsAfterEnd && child.kind !== 1 /* AstNodeKind.Bracket */) {\n                            // No child after this child in the requested window, don't recurse\n                            // Don't do this for brackets because of unclosed/unopened brackets\n                            node = child;\n                            if (colorize) {\n                                level++;\n                                nestingLevelOfEqualBracketType = levelPerBracket + 1;\n                            }\n                            else {\n                                nestingLevelOfEqualBracketType = levelPerBracket;\n                            }\n                            continue whileLoop;\n                        }\n                        if (colorize || child.kind !== 1 /* AstNodeKind.Bracket */ || !node.closingBracket) {\n                            const shouldContinue = collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, colorize ? level + 1 : level, colorize ? levelPerBracket + 1 : levelPerBracket, levelPerBracketType, onlyColorizedBrackets, !node.closingBracket);\n                            if (!shouldContinue) {\n                                return false;\n                            }\n                        }\n                    }\n                    nodeOffsetStart = nodeOffsetEnd;\n                }\n                levelPerBracketType?.set(node.openingBracket.text, levelPerBracket);\n                return true;\n            }\n            case 3 /* AstNodeKind.UnexpectedClosingBracket */: {\n                const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n                return push(new BracketInfo(range, level - 1, 0, true));\n            }\n            case 1 /* AstNodeKind.Bracket */: {\n                const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n                return push(new BracketInfo(range, level - 1, nestingLevelOfEqualBracketType - 1, parentPairIsIncomplete));\n            }\n            case 0 /* AstNodeKind.Text */:\n                return true;\n        }\n    }\n}\nclass CollectBracketPairsContext {\n    constructor(push, includeMinIndentation, textModel) {\n        this.push = push;\n        this.includeMinIndentation = includeMinIndentation;\n        this.textModel = textModel;\n    }\n}\nfunction collectBracketPairs(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, context, level, levelPerBracketType) {\n    if (level > 200) {\n        return true;\n    }\n    let shouldContinue = true;\n    if (node.kind === 2 /* AstNodeKind.Pair */) {\n        let levelPerBracket = 0;\n        if (levelPerBracketType) {\n            let existing = levelPerBracketType.get(node.openingBracket.text);\n            if (existing === undefined) {\n                existing = 0;\n            }\n            levelPerBracket = existing;\n            existing++;\n            levelPerBracketType.set(node.openingBracket.text, existing);\n        }\n        const openingBracketEnd = lengthAdd(nodeOffsetStart, node.openingBracket.length);\n        let minIndentation = -1;\n        if (context.includeMinIndentation) {\n            minIndentation = node.computeMinIndentation(nodeOffsetStart, context.textModel);\n        }\n        shouldContinue = context.push(new BracketPairWithMinIndentationInfo(lengthsToRange(nodeOffsetStart, nodeOffsetEnd), lengthsToRange(nodeOffsetStart, openingBracketEnd), node.closingBracket\n            ? lengthsToRange(lengthAdd(openingBracketEnd, node.child?.length || lengthZero), nodeOffsetEnd)\n            : undefined, level, levelPerBracket, node, minIndentation));\n        nodeOffsetStart = openingBracketEnd;\n        if (shouldContinue && node.child) {\n            const child = node.child;\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                shouldContinue = collectBracketPairs(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, context, level + 1, levelPerBracketType);\n                if (!shouldContinue) {\n                    return false;\n                }\n            }\n        }\n        levelPerBracketType?.set(node.openingBracket.text, levelPerBracket);\n    }\n    else {\n        let curOffset = nodeOffsetStart;\n        for (const child of node.children) {\n            const childOffset = curOffset;\n            curOffset = lengthAdd(curOffset, child.length);\n            if (lengthLessThanEqual(childOffset, endOffset) &&\n                lengthLessThanEqual(startOffset, curOffset)) {\n                shouldContinue = collectBracketPairs(child, childOffset, curOffset, startOffset, endOffset, context, level, levelPerBracketType);\n                if (!shouldContinue) {\n                    return false;\n                }\n            }\n        }\n    }\n    return shouldContinue;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CallbackIterable, compareBy } from '../../../../base/common/arrays.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable, DisposableStore, MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { Range } from '../../core/range.js';\nimport { ignoreBracketsInToken } from '../../languages/supports.js';\nimport { BracketsUtils } from '../../languages/supports/richEditBrackets.js';\nimport { BracketPairsTree } from './bracketPairsTree/bracketPairsTree.js';\nexport class BracketPairsTextModelPart extends Disposable {\n    get canBuildAST() {\n        const maxSupportedDocumentLength = /* max lines */ 50_000 * /* average column count */ 100;\n        return this.textModel.getValueLength() <= maxSupportedDocumentLength;\n    }\n    constructor(textModel, languageConfigurationService) {\n        super();\n        this.textModel = textModel;\n        this.languageConfigurationService = languageConfigurationService;\n        this.bracketPairsTree = this._register(new MutableDisposable());\n        this.onDidChangeEmitter = new Emitter();\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.bracketsRequested = false;\n    }\n    //#region TextModel events\n    handleLanguageConfigurationServiceChange(e) {\n        if (!e.languageId || this.bracketPairsTree.value?.object.didLanguageChange(e.languageId)) {\n            this.bracketPairsTree.clear();\n            this.updateBracketPairsTree();\n        }\n    }\n    handleDidChangeOptions(e) {\n        this.bracketPairsTree.clear();\n        this.updateBracketPairsTree();\n    }\n    handleDidChangeLanguage(e) {\n        this.bracketPairsTree.clear();\n        this.updateBracketPairsTree();\n    }\n    handleDidChangeContent(change) {\n        this.bracketPairsTree.value?.object.handleContentChanged(change);\n    }\n    handleDidChangeBackgroundTokenizationState() {\n        this.bracketPairsTree.value?.object.handleDidChangeBackgroundTokenizationState();\n    }\n    handleDidChangeTokens(e) {\n        this.bracketPairsTree.value?.object.handleDidChangeTokens(e);\n    }\n    //#endregion\n    updateBracketPairsTree() {\n        if (this.bracketsRequested && this.canBuildAST) {\n            if (!this.bracketPairsTree.value) {\n                const store = new DisposableStore();\n                this.bracketPairsTree.value = createDisposableRef(store.add(new BracketPairsTree(this.textModel, (languageId) => {\n                    return this.languageConfigurationService.getLanguageConfiguration(languageId);\n                })), store);\n                store.add(this.bracketPairsTree.value.object.onDidChange(e => this.onDidChangeEmitter.fire(e)));\n                this.onDidChangeEmitter.fire();\n            }\n        }\n        else {\n            if (this.bracketPairsTree.value) {\n                this.bracketPairsTree.clear();\n                // Important: Don't call fire if there was no change!\n                this.onDidChangeEmitter.fire();\n            }\n        }\n    }\n    /**\n     * Returns all bracket pairs that intersect the given range.\n     * The result is sorted by the start position.\n    */\n    getBracketPairsInRange(range) {\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return this.bracketPairsTree.value?.object.getBracketPairsInRange(range, false) || CallbackIterable.empty;\n    }\n    getBracketPairsInRangeWithMinIndentation(range) {\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return this.bracketPairsTree.value?.object.getBracketPairsInRange(range, true) || CallbackIterable.empty;\n    }\n    getBracketsInRange(range, onlyColorizedBrackets = false) {\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return this.bracketPairsTree.value?.object.getBracketsInRange(range, onlyColorizedBrackets) || CallbackIterable.empty;\n    }\n    findMatchingBracketUp(_bracket, _position, maxDuration) {\n        const position = this.textModel.validatePosition(_position);\n        const languageId = this.textModel.getLanguageIdAtPosition(position.lineNumber, position.column);\n        if (this.canBuildAST) {\n            const closingBracketInfo = this.languageConfigurationService\n                .getLanguageConfiguration(languageId)\n                .bracketsNew.getClosingBracketInfo(_bracket);\n            if (!closingBracketInfo) {\n                return null;\n            }\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(_position, _position)).findLast((b) => closingBracketInfo.closes(b.openingBracketInfo));\n            if (bracketPair) {\n                return bracketPair.openingBracketRange;\n            }\n            return null;\n        }\n        else {\n            // Fallback to old bracket matching code:\n            const bracket = _bracket.toLowerCase();\n            const bracketsSupport = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n            if (!bracketsSupport) {\n                return null;\n            }\n            const data = bracketsSupport.textIsBracket[bracket];\n            if (!data) {\n                return null;\n            }\n            return stripBracketSearchCanceled(this._findMatchingBracketUp(data, position, createTimeBasedContinueBracketSearchPredicate(maxDuration)));\n        }\n    }\n    matchBracket(position, maxDuration) {\n        if (this.canBuildAST) {\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(position, position)).filter((item) => item.closingBracketRange !== undefined &&\n                (item.openingBracketRange.containsPosition(position) ||\n                    item.closingBracketRange.containsPosition(position))).findLastMaxBy(compareBy((item) => item.openingBracketRange.containsPosition(position)\n                ? item.openingBracketRange\n                : item.closingBracketRange, Range.compareRangesUsingStarts));\n            if (bracketPair) {\n                return [bracketPair.openingBracketRange, bracketPair.closingBracketRange];\n            }\n            return null;\n        }\n        else {\n            // Fallback to old bracket matching code:\n            const continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);\n            return this._matchBracket(this.textModel.validatePosition(position), continueSearchPredicate);\n        }\n    }\n    _establishBracketSearchOffsets(position, lineTokens, modeBrackets, tokenIndex) {\n        const tokenCount = lineTokens.getCount();\n        const currentLanguageId = lineTokens.getLanguageId(tokenIndex);\n        // limit search to not go before `maxBracketLength`\n        let searchStartOffset = Math.max(0, position.column - 1 - modeBrackets.maxBracketLength);\n        for (let i = tokenIndex - 1; i >= 0; i--) {\n            const tokenEndOffset = lineTokens.getEndOffset(i);\n            if (tokenEndOffset <= searchStartOffset) {\n                break;\n            }\n            if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n                searchStartOffset = tokenEndOffset;\n                break;\n            }\n        }\n        // limit search to not go after `maxBracketLength`\n        let searchEndOffset = Math.min(lineTokens.getLineContent().length, position.column - 1 + modeBrackets.maxBracketLength);\n        for (let i = tokenIndex + 1; i < tokenCount; i++) {\n            const tokenStartOffset = lineTokens.getStartOffset(i);\n            if (tokenStartOffset >= searchEndOffset) {\n                break;\n            }\n            if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n                searchEndOffset = tokenStartOffset;\n                break;\n            }\n        }\n        return { searchStartOffset, searchEndOffset };\n    }\n    _matchBracket(position, continueSearchPredicate) {\n        const lineNumber = position.lineNumber;\n        const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n        const lineText = this.textModel.getLineContent(lineNumber);\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        if (tokenIndex < 0) {\n            return null;\n        }\n        const currentModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).brackets;\n        // check that the token is not to be ignored\n        if (currentModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {\n            let { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, currentModeBrackets, tokenIndex);\n            // it might be the case that [currentTokenStart -> currentTokenEnd] contains multiple brackets\n            // `bestResult` will contain the most right-side result\n            let bestResult = null;\n            while (true) {\n                const foundBracket = BracketsUtils.findNextBracketInRange(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!foundBracket) {\n                    // there are no more brackets in this text\n                    break;\n                }\n                // check that we didn't hit a bracket too far away from position\n                if (foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n                    const r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);\n                    if (r) {\n                        if (r instanceof BracketSearchCanceled) {\n                            return null;\n                        }\n                        bestResult = r;\n                    }\n                }\n                searchStartOffset = foundBracket.endColumn - 1;\n            }\n            if (bestResult) {\n                return bestResult;\n            }\n        }\n        // If position is in between two tokens, try also looking in the previous token\n        if (tokenIndex > 0 && lineTokens.getStartOffset(tokenIndex) === position.column - 1) {\n            const prevTokenIndex = tokenIndex - 1;\n            const prevModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(prevTokenIndex)).brackets;\n            // check that previous token is not to be ignored\n            if (prevModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(prevTokenIndex))) {\n                const { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, prevModeBrackets, prevTokenIndex);\n                const foundBracket = BracketsUtils.findPrevBracketInRange(prevModeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                // check that we didn't hit a bracket too far away from position\n                if (foundBracket && foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n                    const r = this._matchFoundBracket(foundBracket, prevModeBrackets.textIsBracket[foundBracketText], prevModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);\n                    if (r) {\n                        if (r instanceof BracketSearchCanceled) {\n                            return null;\n                        }\n                        return r;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    _matchFoundBracket(foundBracket, data, isOpen, continueSearchPredicate) {\n        if (!data) {\n            return null;\n        }\n        const matched = (isOpen\n            ? this._findMatchingBracketDown(data, foundBracket.getEndPosition(), continueSearchPredicate)\n            : this._findMatchingBracketUp(data, foundBracket.getStartPosition(), continueSearchPredicate));\n        if (!matched) {\n            return null;\n        }\n        if (matched instanceof BracketSearchCanceled) {\n            return matched;\n        }\n        return [foundBracket, matched];\n    }\n    _findMatchingBracketUp(bracket, position, continueSearchPredicate) {\n        // console.log('_findMatchingBracketUp: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n        const languageId = bracket.languageId;\n        const reversedBracketRegex = bracket.reversedRegex;\n        let count = -1;\n        let totalCallCount = 0;\n        const searchPrevMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                if (bracket.isOpen(hitText)) {\n                    count++;\n                }\n                else if (bracket.isClose(hitText)) {\n                    count--;\n                }\n                if (count === 0) {\n                    return r;\n                }\n                searchEndOffset = r.startColumn - 1;\n            }\n            return null;\n        };\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = tokenCount - 1;\n            let searchStartOffset = lineText.length;\n            let searchEndOffset = lineText.length;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex >= 0; tokenIndex--) {\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchStartOffset\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return r;\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n        return null;\n    }\n    _findMatchingBracketDown(bracket, position, continueSearchPredicate) {\n        // console.log('_findMatchingBracketDown: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n        const languageId = bracket.languageId;\n        const bracketRegex = bracket.forwardRegex;\n        let count = 1;\n        let totalCallCount = 0;\n        const searchNextMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findNextBracketInRange(bracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                if (bracket.isOpen(hitText)) {\n                    count++;\n                }\n                else if (bracket.isClose(hitText)) {\n                    count--;\n                }\n                if (count === 0) {\n                    return r;\n                }\n                searchStartOffset = r.endColumn - 1;\n            }\n            return null;\n        };\n        const lineCount = this.textModel.getLineCount();\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return r;\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n        return null;\n    }\n    findPrevBracket(_position) {\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            this.bracketsRequested = true;\n            this.updateBracketPairsTree();\n            return this.bracketPairsTree.value?.object.getFirstBracketBefore(position) || null;\n        }\n        let languageId = null;\n        let modeBrackets = null;\n        let bracketConfig = null;\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = tokenCount - 1;\n            let searchStartOffset = lineText.length;\n            let searchEndOffset = lineText.length;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex >= 0; tokenIndex--) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && bracketConfig && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchStartOffset\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return this._toFoundBracket(bracketConfig, r);\n                }\n            }\n        }\n        return null;\n    }\n    findNextBracket(_position) {\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            this.bracketsRequested = true;\n            this.updateBracketPairsTree();\n            return this.bracketPairsTree.value?.object.getFirstBracketAfter(position) || null;\n        }\n        const lineCount = this.textModel.getLineCount();\n        let languageId = null;\n        let modeBrackets = null;\n        let bracketConfig = null;\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return this._toFoundBracket(bracketConfig, r);\n                }\n            }\n        }\n        return null;\n    }\n    findEnclosingBrackets(_position, maxDuration) {\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            const range = Range.fromPositions(position);\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(position, position)).findLast((item) => item.closingBracketRange !== undefined && item.range.strictContainsRange(range));\n            if (bracketPair) {\n                return [bracketPair.openingBracketRange, bracketPair.closingBracketRange];\n            }\n            return null;\n        }\n        const continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);\n        const lineCount = this.textModel.getLineCount();\n        const savedCounts = new Map();\n        let counts = [];\n        const resetCounts = (languageId, modeBrackets) => {\n            if (!savedCounts.has(languageId)) {\n                const tmp = [];\n                for (let i = 0, len = modeBrackets ? modeBrackets.brackets.length : 0; i < len; i++) {\n                    tmp[i] = 0;\n                }\n                savedCounts.set(languageId, tmp);\n            }\n            counts = savedCounts.get(languageId);\n        };\n        let totalCallCount = 0;\n        const searchInRange = (modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                const bracket = modeBrackets.textIsBracket[hitText];\n                if (bracket) {\n                    if (bracket.isOpen(hitText)) {\n                        counts[bracket.index]++;\n                    }\n                    else if (bracket.isClose(hitText)) {\n                        counts[bracket.index]--;\n                    }\n                    if (counts[bracket.index] === -1) {\n                        return this._matchFoundBracket(r, bracket, false, continueSearchPredicate);\n                    }\n                }\n                searchStartOffset = r.endColumn - 1;\n            }\n            return null;\n        };\n        let languageId = null;\n        let modeBrackets = null;\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    resetCounts(languageId, modeBrackets);\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return stripBracketSearchCanceled(r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    resetCounts(languageId, modeBrackets);\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return stripBracketSearchCanceled(r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return stripBracketSearchCanceled(r);\n                }\n            }\n        }\n        return null;\n    }\n    _toFoundBracket(bracketConfig, r) {\n        if (!r) {\n            return null;\n        }\n        let text = this.textModel.getValueInRange(r);\n        text = text.toLowerCase();\n        const bracketInfo = bracketConfig.getBracketInfo(text);\n        if (!bracketInfo) {\n            return null;\n        }\n        return {\n            range: r,\n            bracketInfo\n        };\n    }\n}\nfunction createDisposableRef(object, disposable) {\n    return {\n        object,\n        dispose: () => disposable?.dispose(),\n    };\n}\nfunction createTimeBasedContinueBracketSearchPredicate(maxDuration) {\n    if (typeof maxDuration === 'undefined') {\n        return () => true;\n    }\n    else {\n        const startTime = Date.now();\n        return () => {\n            return (Date.now() - startTime <= maxDuration);\n        };\n    }\n}\nclass BracketSearchCanceled {\n    static { this.INSTANCE = new BracketSearchCanceled(); }\n    constructor() {\n        this._searchCanceledBrand = undefined;\n    }\n}\nfunction stripBracketSearchCanceled(result) {\n    if (result instanceof BracketSearchCanceled) {\n        return null;\n    }\n    return result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { Range } from '../../core/range.js';\nimport { editorBracketHighlightingForeground1, editorBracketHighlightingForeground2, editorBracketHighlightingForeground3, editorBracketHighlightingForeground4, editorBracketHighlightingForeground5, editorBracketHighlightingForeground6, editorBracketHighlightingUnexpectedBracketForeground } from '../../core/editorColorRegistry.js';\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\nexport class ColorizedBracketPairsDecorationProvider extends Disposable {\n    constructor(textModel) {\n        super();\n        this.textModel = textModel;\n        this.colorProvider = new ColorProvider();\n        this.onDidChangeEmitter = new Emitter();\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.colorizationOptions = textModel.getOptions().bracketPairColorizationOptions;\n        this._register(textModel.bracketPairs.onDidChange(e => {\n            this.onDidChangeEmitter.fire();\n        }));\n    }\n    //#region TextModel events\n    handleDidChangeOptions(e) {\n        this.colorizationOptions = this.textModel.getOptions().bracketPairColorizationOptions;\n    }\n    //#endregion\n    getDecorationsInRange(range, ownerId, filterOutValidation, onlyMinimapDecorations) {\n        if (onlyMinimapDecorations) {\n            // Bracket pair colorization decorations are not rendered in the minimap\n            return [];\n        }\n        if (ownerId === undefined) {\n            return [];\n        }\n        if (!this.colorizationOptions.enabled) {\n            return [];\n        }\n        const result = this.textModel.bracketPairs.getBracketsInRange(range, true).map(bracket => ({\n            id: `bracket${bracket.range.toString()}-${bracket.nestingLevel}`,\n            options: {\n                description: 'BracketPairColorization',\n                inlineClassName: this.colorProvider.getInlineClassName(bracket, this.colorizationOptions.independentColorPoolPerBracketType),\n            },\n            ownerId: 0,\n            range: bracket.range,\n        })).toArray();\n        return result;\n    }\n    getAllDecorations(ownerId, filterOutValidation) {\n        if (ownerId === undefined) {\n            return [];\n        }\n        if (!this.colorizationOptions.enabled) {\n            return [];\n        }\n        return this.getDecorationsInRange(new Range(1, 1, this.textModel.getLineCount(), 1), ownerId, filterOutValidation);\n    }\n}\nclass ColorProvider {\n    constructor() {\n        this.unexpectedClosingBracketClassName = 'unexpected-closing-bracket';\n    }\n    getInlineClassName(bracket, independentColorPoolPerBracketType) {\n        if (bracket.isInvalid) {\n            return this.unexpectedClosingBracketClassName;\n        }\n        return this.getInlineClassNameOfLevel(independentColorPoolPerBracketType ? bracket.nestingLevelOfEqualBracketType : bracket.nestingLevel);\n    }\n    getInlineClassNameOfLevel(level) {\n        // To support a dynamic amount of colors up to 6 colors,\n        // we use a number that is a lcm of all numbers from 1 to 6.\n        return `bracket-highlighting-${level % 30}`;\n    }\n}\nregisterThemingParticipant((theme, collector) => {\n    const colors = [\n        editorBracketHighlightingForeground1,\n        editorBracketHighlightingForeground2,\n        editorBracketHighlightingForeground3,\n        editorBracketHighlightingForeground4,\n        editorBracketHighlightingForeground5,\n        editorBracketHighlightingForeground6\n    ];\n    const colorProvider = new ColorProvider();\n    collector.addRule(`.monaco-editor .${colorProvider.unexpectedClosingBracketClassName} { color: ${theme.getColor(editorBracketHighlightingUnexpectedBracketForeground)}; }`);\n    const colorValues = colors\n        .map(c => theme.getColor(c))\n        .filter((c) => !!c)\n        .filter(c => !c.isTransparent());\n    for (let level = 0; level < 30; level++) {\n        const color = colorValues[level % colorValues.length];\n        collector.addRule(`.monaco-editor .${colorProvider.getInlineClassNameOfLevel(level)} { color: ${color}; }`);\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass SpacesDiffResult {\n    constructor() {\n        this.spacesDiff = 0;\n        this.looksLikeAlignment = false;\n    }\n}\n/**\n * Compute the diff in spaces between two line's indentation.\n */\nfunction spacesDiff(a, aLength, b, bLength, result) {\n    result.spacesDiff = 0;\n    result.looksLikeAlignment = false;\n    // This can go both ways (e.g.):\n    //  - a: \"\\t\"\n    //  - b: \"\\t    \"\n    //  => This should count 1 tab and 4 spaces\n    let i;\n    for (i = 0; i < aLength && i < bLength; i++) {\n        const aCharCode = a.charCodeAt(i);\n        const bCharCode = b.charCodeAt(i);\n        if (aCharCode !== bCharCode) {\n            break;\n        }\n    }\n    let aSpacesCnt = 0, aTabsCount = 0;\n    for (let j = i; j < aLength; j++) {\n        const aCharCode = a.charCodeAt(j);\n        if (aCharCode === 32 /* CharCode.Space */) {\n            aSpacesCnt++;\n        }\n        else {\n            aTabsCount++;\n        }\n    }\n    let bSpacesCnt = 0, bTabsCount = 0;\n    for (let j = i; j < bLength; j++) {\n        const bCharCode = b.charCodeAt(j);\n        if (bCharCode === 32 /* CharCode.Space */) {\n            bSpacesCnt++;\n        }\n        else {\n            bTabsCount++;\n        }\n    }\n    if (aSpacesCnt > 0 && aTabsCount > 0) {\n        return;\n    }\n    if (bSpacesCnt > 0 && bTabsCount > 0) {\n        return;\n    }\n    const tabsDiff = Math.abs(aTabsCount - bTabsCount);\n    const spacesDiff = Math.abs(aSpacesCnt - bSpacesCnt);\n    if (tabsDiff === 0) {\n        // check if the indentation difference might be caused by alignment reasons\n        // sometime folks like to align their code, but this should not be used as a hint\n        result.spacesDiff = spacesDiff;\n        if (spacesDiff > 0 && 0 <= bSpacesCnt - 1 && bSpacesCnt - 1 < a.length && bSpacesCnt < b.length) {\n            if (b.charCodeAt(bSpacesCnt) !== 32 /* CharCode.Space */ && a.charCodeAt(bSpacesCnt - 1) === 32 /* CharCode.Space */) {\n                if (a.charCodeAt(a.length - 1) === 44 /* CharCode.Comma */) {\n                    // This looks like an alignment desire: e.g.\n                    // const a = b + c,\n                    //       d = b - c;\n                    result.looksLikeAlignment = true;\n                }\n            }\n        }\n        return;\n    }\n    if (spacesDiff % tabsDiff === 0) {\n        result.spacesDiff = spacesDiff / tabsDiff;\n        return;\n    }\n}\nexport function guessIndentation(source, defaultTabSize, defaultInsertSpaces) {\n    // Look at most at the first 10k lines\n    const linesCount = Math.min(source.getLineCount(), 10000);\n    let linesIndentedWithTabsCount = 0; // number of lines that contain at least one tab in indentation\n    let linesIndentedWithSpacesCount = 0; // number of lines that contain only spaces in indentation\n    let previousLineText = ''; // content of latest line that contained non-whitespace chars\n    let previousLineIndentation = 0; // index at which latest line contained the first non-whitespace char\n    const ALLOWED_TAB_SIZE_GUESSES = [2, 4, 6, 8, 3, 5, 7]; // prefer even guesses for `tabSize`, limit to [2, 8].\n    const MAX_ALLOWED_TAB_SIZE_GUESS = 8; // max(ALLOWED_TAB_SIZE_GUESSES) = 8\n    const spacesDiffCount = [0, 0, 0, 0, 0, 0, 0, 0, 0]; // `tabSize` scores\n    const tmp = new SpacesDiffResult();\n    for (let lineNumber = 1; lineNumber <= linesCount; lineNumber++) {\n        const currentLineLength = source.getLineLength(lineNumber);\n        const currentLineText = source.getLineContent(lineNumber);\n        // if the text buffer is chunk based, so long lines are cons-string, v8 will flattern the string when we check charCode.\n        // checking charCode on chunks directly is cheaper.\n        const useCurrentLineText = (currentLineLength <= 65536);\n        let currentLineHasContent = false; // does `currentLineText` contain non-whitespace chars\n        let currentLineIndentation = 0; // index at which `currentLineText` contains the first non-whitespace char\n        let currentLineSpacesCount = 0; // count of spaces found in `currentLineText` indentation\n        let currentLineTabsCount = 0; // count of tabs found in `currentLineText` indentation\n        for (let j = 0, lenJ = currentLineLength; j < lenJ; j++) {\n            const charCode = (useCurrentLineText ? currentLineText.charCodeAt(j) : source.getLineCharCode(lineNumber, j));\n            if (charCode === 9 /* CharCode.Tab */) {\n                currentLineTabsCount++;\n            }\n            else if (charCode === 32 /* CharCode.Space */) {\n                currentLineSpacesCount++;\n            }\n            else {\n                // Hit non whitespace character on this line\n                currentLineHasContent = true;\n                currentLineIndentation = j;\n                break;\n            }\n        }\n        // Ignore empty or only whitespace lines\n        if (!currentLineHasContent) {\n            continue;\n        }\n        if (currentLineTabsCount > 0) {\n            linesIndentedWithTabsCount++;\n        }\n        else if (currentLineSpacesCount > 1) {\n            linesIndentedWithSpacesCount++;\n        }\n        spacesDiff(previousLineText, previousLineIndentation, currentLineText, currentLineIndentation, tmp);\n        if (tmp.looksLikeAlignment) {\n            // if defaultInsertSpaces === true && the spaces count == tabSize, we may want to count it as valid indentation\n            //\n            // - item1\n            //   - item2\n            //\n            // otherwise skip this line entirely\n            //\n            // const a = 1,\n            //       b = 2;\n            if (!(defaultInsertSpaces && defaultTabSize === tmp.spacesDiff)) {\n                continue;\n            }\n        }\n        const currentSpacesDiff = tmp.spacesDiff;\n        if (currentSpacesDiff <= MAX_ALLOWED_TAB_SIZE_GUESS) {\n            spacesDiffCount[currentSpacesDiff]++;\n        }\n        previousLineText = currentLineText;\n        previousLineIndentation = currentLineIndentation;\n    }\n    let insertSpaces = defaultInsertSpaces;\n    if (linesIndentedWithTabsCount !== linesIndentedWithSpacesCount) {\n        insertSpaces = (linesIndentedWithTabsCount < linesIndentedWithSpacesCount);\n    }\n    let tabSize = defaultTabSize;\n    // Guess tabSize only if inserting spaces...\n    if (insertSpaces) {\n        let tabSizeScore = (insertSpaces ? 0 : 0.1 * linesCount);\n        // console.log(\"score threshold: \" + tabSizeScore);\n        ALLOWED_TAB_SIZE_GUESSES.forEach((possibleTabSize) => {\n            const possibleTabSizeScore = spacesDiffCount[possibleTabSize];\n            if (possibleTabSizeScore > tabSizeScore) {\n                tabSizeScore = possibleTabSizeScore;\n                tabSize = possibleTabSize;\n            }\n        });\n        // Let a tabSize of 2 win even if it is not the maximum\n        // (only in case 4 was guessed)\n        if (tabSize === 4 && spacesDiffCount[4] > 0 && spacesDiffCount[2] > 0 && spacesDiffCount[2] >= spacesDiffCount[4] / 2) {\n            tabSize = 2;\n        }\n    }\n    // console.log('--------------------------');\n    // console.log('linesIndentedWithTabsCount: ' + linesIndentedWithTabsCount + ', linesIndentedWithSpacesCount: ' + linesIndentedWithSpacesCount);\n    // console.log('spacesDiffCount: ' + spacesDiffCount);\n    // console.log('tabSize: ' + tabSize + ', tabSizeScore: ' + tabSizeScore);\n    return {\n        insertSpaces: insertSpaces,\n        tabSize: tabSize\n    };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function getNodeColor(node) {\n    return ((node.metadata & 1 /* Constants.ColorMask */) >>> 0 /* Constants.ColorOffset */);\n}\nfunction setNodeColor(node, color) {\n    node.metadata = ((node.metadata & 254 /* Constants.ColorMaskInverse */) | (color << 0 /* Constants.ColorOffset */));\n}\nfunction getNodeIsVisited(node) {\n    return ((node.metadata & 2 /* Constants.IsVisitedMask */) >>> 1 /* Constants.IsVisitedOffset */) === 1;\n}\nfunction setNodeIsVisited(node, value) {\n    node.metadata = ((node.metadata & 253 /* Constants.IsVisitedMaskInverse */) | ((value ? 1 : 0) << 1 /* Constants.IsVisitedOffset */));\n}\nfunction getNodeIsForValidation(node) {\n    return ((node.metadata & 4 /* Constants.IsForValidationMask */) >>> 2 /* Constants.IsForValidationOffset */) === 1;\n}\nfunction setNodeIsForValidation(node, value) {\n    node.metadata = ((node.metadata & 251 /* Constants.IsForValidationMaskInverse */) | ((value ? 1 : 0) << 2 /* Constants.IsForValidationOffset */));\n}\nfunction getNodeIsInGlyphMargin(node) {\n    return ((node.metadata & 64 /* Constants.IsMarginMask */) >>> 6 /* Constants.IsMarginOffset */) === 1;\n}\nfunction setNodeIsInGlyphMargin(node, value) {\n    node.metadata = ((node.metadata & 191 /* Constants.IsMarginMaskInverse */) | ((value ? 1 : 0) << 6 /* Constants.IsMarginOffset */));\n}\nfunction getNodeStickiness(node) {\n    return ((node.metadata & 24 /* Constants.StickinessMask */) >>> 3 /* Constants.StickinessOffset */);\n}\nfunction _setNodeStickiness(node, stickiness) {\n    node.metadata = ((node.metadata & 231 /* Constants.StickinessMaskInverse */) | (stickiness << 3 /* Constants.StickinessOffset */));\n}\nfunction getCollapseOnReplaceEdit(node) {\n    return ((node.metadata & 32 /* Constants.CollapseOnReplaceEditMask */) >>> 5 /* Constants.CollapseOnReplaceEditOffset */) === 1;\n}\nfunction setCollapseOnReplaceEdit(node, value) {\n    node.metadata = ((node.metadata & 223 /* Constants.CollapseOnReplaceEditMaskInverse */) | ((value ? 1 : 0) << 5 /* Constants.CollapseOnReplaceEditOffset */));\n}\nexport class IntervalNode {\n    constructor(id, start, end) {\n        this.metadata = 0;\n        this.parent = this;\n        this.left = this;\n        this.right = this;\n        setNodeColor(this, 1 /* NodeColor.Red */);\n        this.start = start;\n        this.end = end;\n        // FORCE_OVERFLOWING_TEST: this.delta = start;\n        this.delta = 0;\n        this.maxEnd = end;\n        this.id = id;\n        this.ownerId = 0;\n        this.options = null;\n        setNodeIsForValidation(this, false);\n        setNodeIsInGlyphMargin(this, false);\n        _setNodeStickiness(this, 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n        setCollapseOnReplaceEdit(this, false);\n        this.cachedVersionId = 0;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        this.range = null;\n        setNodeIsVisited(this, false);\n    }\n    reset(versionId, start, end, range) {\n        this.start = start;\n        this.end = end;\n        this.maxEnd = end;\n        this.cachedVersionId = versionId;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        this.range = range;\n    }\n    setOptions(options) {\n        this.options = options;\n        const className = this.options.className;\n        setNodeIsForValidation(this, (className === \"squiggly-error\" /* ClassName.EditorErrorDecoration */\n            || className === \"squiggly-warning\" /* ClassName.EditorWarningDecoration */\n            || className === \"squiggly-info\" /* ClassName.EditorInfoDecoration */));\n        setNodeIsInGlyphMargin(this, this.options.glyphMarginClassName !== null);\n        _setNodeStickiness(this, this.options.stickiness);\n        setCollapseOnReplaceEdit(this, this.options.collapseOnReplaceEdit);\n    }\n    setCachedOffsets(absoluteStart, absoluteEnd, cachedVersionId) {\n        if (this.cachedVersionId !== cachedVersionId) {\n            this.range = null;\n        }\n        this.cachedVersionId = cachedVersionId;\n        this.cachedAbsoluteStart = absoluteStart;\n        this.cachedAbsoluteEnd = absoluteEnd;\n    }\n    detach() {\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    }\n}\nexport const SENTINEL = new IntervalNode(null, 0, 0);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nsetNodeColor(SENTINEL, 0 /* NodeColor.Black */);\nexport class IntervalTree {\n    constructor() {\n        this.root = SENTINEL;\n        this.requestNormalizeDelta = false;\n    }\n    intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n        if (this.root === SENTINEL) {\n            return [];\n        }\n        return intervalSearch(this, start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n    }\n    search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n        if (this.root === SENTINEL) {\n            return [];\n        }\n        return search(this, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n    }\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n    collectNodesFromOwner(ownerId) {\n        return collectNodesFromOwner(this, ownerId);\n    }\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n    collectNodesPostOrder() {\n        return collectNodesPostOrder(this);\n    }\n    insert(node) {\n        rbTreeInsert(this, node);\n        this._normalizeDeltaIfNecessary();\n    }\n    delete(node) {\n        rbTreeDelete(this, node);\n        this._normalizeDeltaIfNecessary();\n    }\n    resolveNode(node, cachedVersionId) {\n        const initialNode = node;\n        let delta = 0;\n        while (node !== this.root) {\n            if (node === node.parent.right) {\n                delta += node.parent.delta;\n            }\n            node = node.parent;\n        }\n        const nodeStart = initialNode.start + delta;\n        const nodeEnd = initialNode.end + delta;\n        initialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n    }\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\n        // Our strategy is to remove all directly impacted nodes, and then add them back to the tree.\n        // (1) collect all nodes that are intersecting this edit as nodes of interest\n        const nodesOfInterest = searchForEditing(this, offset, offset + length);\n        // (2) remove all nodes that are intersecting this edit\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            rbTreeDelete(this, node);\n        }\n        this._normalizeDeltaIfNecessary();\n        // (3) edit all tree nodes except the nodes of interest\n        noOverlapReplace(this, offset, offset + length, textLength);\n        this._normalizeDeltaIfNecessary();\n        // (4) edit the nodes of interest and insert them back in the tree\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            node.start = node.cachedAbsoluteStart;\n            node.end = node.cachedAbsoluteEnd;\n            nodeAcceptEdit(node, offset, (offset + length), textLength, forceMoveMarkers);\n            node.maxEnd = node.end;\n            rbTreeInsert(this, node);\n        }\n        this._normalizeDeltaIfNecessary();\n    }\n    _normalizeDeltaIfNecessary() {\n        if (!this.requestNormalizeDelta) {\n            return;\n        }\n        this.requestNormalizeDelta = false;\n        normalizeDelta(this);\n    }\n}\n//#region Delta Normalization\nfunction normalizeDelta(T) {\n    let node = T.root;\n    let delta = 0;\n    while (node !== SENTINEL) {\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        node.start = delta + node.start;\n        node.end = delta + node.end;\n        node.delta = 0;\n        recomputeMaxEnd(node);\n        setNodeIsVisited(node, true);\n        // going up from this node\n        setNodeIsVisited(node.left, false);\n        setNodeIsVisited(node.right, false);\n        if (node === node.parent.right) {\n            delta -= node.parent.delta;\n        }\n        node = node.parent;\n    }\n    setNodeIsVisited(T.root, false);\n}\nfunction adjustMarkerBeforeColumn(markerOffset, markerStickToPreviousCharacter, checkOffset, moveSemantics) {\n    if (markerOffset < checkOffset) {\n        return true;\n    }\n    if (markerOffset > checkOffset) {\n        return false;\n    }\n    if (moveSemantics === 1 /* MarkerMoveSemantics.ForceMove */) {\n        return false;\n    }\n    if (moveSemantics === 2 /* MarkerMoveSemantics.ForceStay */) {\n        return true;\n    }\n    return markerStickToPreviousCharacter;\n}\n/**\n * This is a lot more complicated than strictly necessary to maintain the same behaviour\n * as when decorations were implemented using two markers.\n */\nexport function nodeAcceptEdit(node, start, end, textLength, forceMoveMarkers) {\n    const nodeStickiness = getNodeStickiness(node);\n    const startStickToPreviousCharacter = (nodeStickiness === 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */\n        || nodeStickiness === 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */);\n    const endStickToPreviousCharacter = (nodeStickiness === 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n        || nodeStickiness === 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */);\n    const deletingCnt = (end - start);\n    const insertingCnt = textLength;\n    const commonLength = Math.min(deletingCnt, insertingCnt);\n    const nodeStart = node.start;\n    let startDone = false;\n    const nodeEnd = node.end;\n    let endDone = false;\n    if (start <= nodeStart && nodeEnd <= end && getCollapseOnReplaceEdit(node)) {\n        // This edit encompasses the entire decoration range\n        // and the decoration has asked to become collapsed\n        node.start = start;\n        startDone = true;\n        node.end = start;\n        endDone = true;\n    }\n    {\n        const moveSemantics = forceMoveMarkers ? 1 /* MarkerMoveSemantics.ForceMove */ : (deletingCnt > 0 ? 2 /* MarkerMoveSemantics.ForceStay */ : 0 /* MarkerMoveSemantics.MarkerDefined */);\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {\n            endDone = true;\n        }\n    }\n    if (commonLength > 0 && !forceMoveMarkers) {\n        const moveSemantics = (deletingCnt > insertingCnt ? 2 /* MarkerMoveSemantics.ForceStay */ : 0 /* MarkerMoveSemantics.MarkerDefined */);\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n            endDone = true;\n        }\n    }\n    {\n        const moveSemantics = forceMoveMarkers ? 1 /* MarkerMoveSemantics.ForceMove */ : 0 /* MarkerMoveSemantics.MarkerDefined */;\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, moveSemantics)) {\n            node.start = start + insertingCnt;\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, moveSemantics)) {\n            node.end = start + insertingCnt;\n            endDone = true;\n        }\n    }\n    // Finish\n    const deltaColumn = (insertingCnt - deletingCnt);\n    if (!startDone) {\n        node.start = Math.max(0, nodeStart + deltaColumn);\n    }\n    if (!endDone) {\n        node.end = Math.max(0, nodeEnd + deltaColumn);\n    }\n    if (node.start > node.end) {\n        node.end = node.start;\n    }\n}\nfunction searchForEditing(T, start, end) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > end) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = delta + node.end;\n        if (nodeEnd >= start) {\n            node.setCachedOffsets(nodeStart, nodeEnd, 0);\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction noOverlapReplace(T, start, end, textLength) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    const editDelta = (textLength - (end - start));\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            recomputeMaxEnd(node);\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > end) {\n            node.start += editDelta;\n            node.end += editDelta;\n            node.delta += editDelta;\n            if (node.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || node.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n                T.requestNormalizeDelta = true;\n            }\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n}\n//#endregion\n//#region Searching\nfunction collectNodesFromOwner(T, ownerId) {\n    let node = T.root;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        if (node.ownerId === ownerId) {\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction collectNodesPostOrder(T) {\n    let node = T.root;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        result[resultLen++] = node;\n        setNodeIsVisited(node, true);\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction search(T, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n    let node = T.root;\n    let delta = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        nodeEnd = delta + node.end;\n        node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n        let include = true;\n        if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n            include = false;\n        }\n        if (filterOutValidation && getNodeIsForValidation(node)) {\n            include = false;\n        }\n        if (onlyMarginDecorations && !getNodeIsInGlyphMargin(node)) {\n            include = false;\n        }\n        if (include) {\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < intervalStart) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > intervalEnd) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = delta + node.end;\n        if (nodeEnd >= intervalStart) {\n            // There is overlap\n            node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n            let include = true;\n            if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n                include = false;\n            }\n            if (filterOutValidation && getNodeIsForValidation(node)) {\n                include = false;\n            }\n            if (onlyMarginDecorations && !getNodeIsInGlyphMargin(node)) {\n                include = false;\n            }\n            if (include) {\n                result[resultLen++] = node;\n            }\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\n//#endregion\n//#region Insertion\nfunction rbTreeInsert(T, newNode) {\n    if (T.root === SENTINEL) {\n        newNode.parent = SENTINEL;\n        newNode.left = SENTINEL;\n        newNode.right = SENTINEL;\n        setNodeColor(newNode, 0 /* NodeColor.Black */);\n        T.root = newNode;\n        return T.root;\n    }\n    treeInsert(T, newNode);\n    recomputeMaxEndWalkToRoot(newNode.parent);\n    // repair tree\n    let x = newNode;\n    while (x !== T.root && getNodeColor(x.parent) === 1 /* NodeColor.Red */) {\n        if (x.parent === x.parent.parent.left) {\n            const y = x.parent.parent.right;\n            if (getNodeColor(y) === 1 /* NodeColor.Red */) {\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(y, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.right) {\n                    x = x.parent;\n                    leftRotate(T, x);\n                }\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                rightRotate(T, x.parent.parent);\n            }\n        }\n        else {\n            const y = x.parent.parent.left;\n            if (getNodeColor(y) === 1 /* NodeColor.Red */) {\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(y, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.left) {\n                    x = x.parent;\n                    rightRotate(T, x);\n                }\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                leftRotate(T, x.parent.parent);\n            }\n        }\n    }\n    setNodeColor(T.root, 0 /* NodeColor.Black */);\n    return newNode;\n}\nfunction treeInsert(T, z) {\n    let delta = 0;\n    let x = T.root;\n    const zAbsoluteStart = z.start;\n    const zAbsoluteEnd = z.end;\n    while (true) {\n        const cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);\n        if (cmp < 0) {\n            // this node should be inserted to the left\n            // => it is not affected by the node's delta\n            if (x.left === SENTINEL) {\n                z.start -= delta;\n                z.end -= delta;\n                z.maxEnd -= delta;\n                x.left = z;\n                break;\n            }\n            else {\n                x = x.left;\n            }\n        }\n        else {\n            // this node should be inserted to the right\n            // => it is not affected by the node's delta\n            if (x.right === SENTINEL) {\n                z.start -= (delta + x.delta);\n                z.end -= (delta + x.delta);\n                z.maxEnd -= (delta + x.delta);\n                x.right = z;\n                break;\n            }\n            else {\n                delta += x.delta;\n                x = x.right;\n            }\n        }\n    }\n    z.parent = x;\n    z.left = SENTINEL;\n    z.right = SENTINEL;\n    setNodeColor(z, 1 /* NodeColor.Red */);\n}\n//#endregion\n//#region Deletion\nfunction rbTreeDelete(T, z) {\n    let x;\n    let y;\n    // RB-DELETE except we don't swap z and y in case c)\n    // i.e. we always delete what's pointed at by z.\n    if (z.left === SENTINEL) {\n        x = z.right;\n        y = z;\n        // x's delta is no longer influenced by z's delta\n        x.delta += z.delta;\n        if (x.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || x.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n        x.start += z.delta;\n        x.end += z.delta;\n    }\n    else if (z.right === SENTINEL) {\n        x = z.left;\n        y = z;\n    }\n    else {\n        y = leftest(z.right);\n        x = y.right;\n        // y's delta is no longer influenced by z's delta,\n        // but we don't want to walk the entire right-hand-side subtree of x.\n        // we therefore maintain z's delta in y, and adjust only x\n        x.start += y.delta;\n        x.end += y.delta;\n        x.delta += y.delta;\n        if (x.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || x.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n        y.start += z.delta;\n        y.end += z.delta;\n        y.delta = z.delta;\n        if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n    }\n    if (y === T.root) {\n        T.root = x;\n        setNodeColor(x, 0 /* NodeColor.Black */);\n        z.detach();\n        resetSentinel();\n        recomputeMaxEnd(x);\n        T.root.parent = SENTINEL;\n        return;\n    }\n    const yWasRed = (getNodeColor(y) === 1 /* NodeColor.Red */);\n    if (y === y.parent.left) {\n        y.parent.left = x;\n    }\n    else {\n        y.parent.right = x;\n    }\n    if (y === z) {\n        x.parent = y.parent;\n    }\n    else {\n        if (y.parent === z) {\n            x.parent = y;\n        }\n        else {\n            x.parent = y.parent;\n        }\n        y.left = z.left;\n        y.right = z.right;\n        y.parent = z.parent;\n        setNodeColor(y, getNodeColor(z));\n        if (z === T.root) {\n            T.root = y;\n        }\n        else {\n            if (z === z.parent.left) {\n                z.parent.left = y;\n            }\n            else {\n                z.parent.right = y;\n            }\n        }\n        if (y.left !== SENTINEL) {\n            y.left.parent = y;\n        }\n        if (y.right !== SENTINEL) {\n            y.right.parent = y;\n        }\n    }\n    z.detach();\n    if (yWasRed) {\n        recomputeMaxEndWalkToRoot(x.parent);\n        if (y !== z) {\n            recomputeMaxEndWalkToRoot(y);\n            recomputeMaxEndWalkToRoot(y.parent);\n        }\n        resetSentinel();\n        return;\n    }\n    recomputeMaxEndWalkToRoot(x);\n    recomputeMaxEndWalkToRoot(x.parent);\n    if (y !== z) {\n        recomputeMaxEndWalkToRoot(y);\n        recomputeMaxEndWalkToRoot(y.parent);\n    }\n    // RB-DELETE-FIXUP\n    let w;\n    while (x !== T.root && getNodeColor(x) === 0 /* NodeColor.Black */) {\n        if (x === x.parent.left) {\n            w = x.parent.right;\n            if (getNodeColor(w) === 1 /* NodeColor.Red */) {\n                setNodeColor(w, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent, 1 /* NodeColor.Red */);\n                leftRotate(T, x.parent);\n                w = x.parent.right;\n            }\n            if (getNodeColor(w.left) === 0 /* NodeColor.Black */ && getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                setNodeColor(w, 1 /* NodeColor.Red */);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                    setNodeColor(w.left, 0 /* NodeColor.Black */);\n                    setNodeColor(w, 1 /* NodeColor.Red */);\n                    rightRotate(T, w);\n                    w = x.parent.right;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(w.right, 0 /* NodeColor.Black */);\n                leftRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n        else {\n            w = x.parent.left;\n            if (getNodeColor(w) === 1 /* NodeColor.Red */) {\n                setNodeColor(w, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent, 1 /* NodeColor.Red */);\n                rightRotate(T, x.parent);\n                w = x.parent.left;\n            }\n            if (getNodeColor(w.left) === 0 /* NodeColor.Black */ && getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                setNodeColor(w, 1 /* NodeColor.Red */);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.left) === 0 /* NodeColor.Black */) {\n                    setNodeColor(w.right, 0 /* NodeColor.Black */);\n                    setNodeColor(w, 1 /* NodeColor.Red */);\n                    leftRotate(T, w);\n                    w = x.parent.left;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(w.left, 0 /* NodeColor.Black */);\n                rightRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n    }\n    setNodeColor(x, 0 /* NodeColor.Black */);\n    resetSentinel();\n}\nfunction leftest(node) {\n    while (node.left !== SENTINEL) {\n        node = node.left;\n    }\n    return node;\n}\nfunction resetSentinel() {\n    SENTINEL.parent = SENTINEL;\n    SENTINEL.delta = 0; // optional\n    SENTINEL.start = 0; // optional\n    SENTINEL.end = 0; // optional\n}\n//#endregion\n//#region Rotations\nfunction leftRotate(T, x) {\n    const y = x.right; // set y.\n    y.delta += x.delta; // y's delta is no longer influenced by x's delta\n    if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n    }\n    y.start += x.delta;\n    y.end += x.delta;\n    x.right = y.left; // turn y's left subtree into x's right subtree.\n    if (y.left !== SENTINEL) {\n        y.left.parent = x;\n    }\n    y.parent = x.parent; // link x's parent to y.\n    if (x.parent === SENTINEL) {\n        T.root = y;\n    }\n    else if (x === x.parent.left) {\n        x.parent.left = y;\n    }\n    else {\n        x.parent.right = y;\n    }\n    y.left = x; // put x on y's left.\n    x.parent = y;\n    recomputeMaxEnd(x);\n    recomputeMaxEnd(y);\n}\nfunction rightRotate(T, y) {\n    const x = y.left;\n    y.delta -= x.delta;\n    if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n    }\n    y.start -= x.delta;\n    y.end -= x.delta;\n    y.left = x.right;\n    if (x.right !== SENTINEL) {\n        x.right.parent = y;\n    }\n    x.parent = y.parent;\n    if (y.parent === SENTINEL) {\n        T.root = x;\n    }\n    else if (y === y.parent.right) {\n        y.parent.right = x;\n    }\n    else {\n        y.parent.left = x;\n    }\n    x.right = y;\n    y.parent = x;\n    recomputeMaxEnd(y);\n    recomputeMaxEnd(x);\n}\n//#endregion\n//#region max end computation\nfunction computeMaxEnd(node) {\n    let maxEnd = node.end;\n    if (node.left !== SENTINEL) {\n        const leftMaxEnd = node.left.maxEnd;\n        if (leftMaxEnd > maxEnd) {\n            maxEnd = leftMaxEnd;\n        }\n    }\n    if (node.right !== SENTINEL) {\n        const rightMaxEnd = node.right.maxEnd + node.delta;\n        if (rightMaxEnd > maxEnd) {\n            maxEnd = rightMaxEnd;\n        }\n    }\n    return maxEnd;\n}\nexport function recomputeMaxEnd(node) {\n    node.maxEnd = computeMaxEnd(node);\n}\nfunction recomputeMaxEndWalkToRoot(node) {\n    while (node !== SENTINEL) {\n        const maxEnd = computeMaxEnd(node);\n        if (node.maxEnd === maxEnd) {\n            // no need to go further\n            return;\n        }\n        node.maxEnd = maxEnd;\n        node = node.parent;\n    }\n}\n//#endregion\n//#region utils\nexport function intervalCompare(aStart, aEnd, bStart, bEnd) {\n    if (aStart === bStart) {\n        return aEnd - bEnd;\n    }\n    return aStart - bStart;\n}\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class TreeNode {\n    constructor(piece, color) {\n        this.piece = piece;\n        this.color = color;\n        this.size_left = 0;\n        this.lf_left = 0;\n        this.parent = this;\n        this.left = this;\n        this.right = this;\n    }\n    next() {\n        if (this.right !== SENTINEL) {\n            return leftest(this.right);\n        }\n        let node = this;\n        while (node.parent !== SENTINEL) {\n            if (node.parent.left === node) {\n                break;\n            }\n            node = node.parent;\n        }\n        if (node.parent === SENTINEL) {\n            return SENTINEL;\n        }\n        else {\n            return node.parent;\n        }\n    }\n    prev() {\n        if (this.left !== SENTINEL) {\n            return righttest(this.left);\n        }\n        let node = this;\n        while (node.parent !== SENTINEL) {\n            if (node.parent.right === node) {\n                break;\n            }\n            node = node.parent;\n        }\n        if (node.parent === SENTINEL) {\n            return SENTINEL;\n        }\n        else {\n            return node.parent;\n        }\n    }\n    detach() {\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    }\n}\nexport const SENTINEL = new TreeNode(null, 0 /* NodeColor.Black */);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nSENTINEL.color = 0 /* NodeColor.Black */;\nexport function leftest(node) {\n    while (node.left !== SENTINEL) {\n        node = node.left;\n    }\n    return node;\n}\nexport function righttest(node) {\n    while (node.right !== SENTINEL) {\n        node = node.right;\n    }\n    return node;\n}\nfunction calculateSize(node) {\n    if (node === SENTINEL) {\n        return 0;\n    }\n    return node.size_left + node.piece.length + calculateSize(node.right);\n}\nfunction calculateLF(node) {\n    if (node === SENTINEL) {\n        return 0;\n    }\n    return node.lf_left + node.piece.lineFeedCnt + calculateLF(node.right);\n}\nfunction resetSentinel() {\n    SENTINEL.parent = SENTINEL;\n}\nexport function leftRotate(tree, x) {\n    const y = x.right;\n    // fix size_left\n    y.size_left += x.size_left + (x.piece ? x.piece.length : 0);\n    y.lf_left += x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n    x.right = y.left;\n    if (y.left !== SENTINEL) {\n        y.left.parent = x;\n    }\n    y.parent = x.parent;\n    if (x.parent === SENTINEL) {\n        tree.root = y;\n    }\n    else if (x.parent.left === x) {\n        x.parent.left = y;\n    }\n    else {\n        x.parent.right = y;\n    }\n    y.left = x;\n    x.parent = y;\n}\nexport function rightRotate(tree, y) {\n    const x = y.left;\n    y.left = x.right;\n    if (x.right !== SENTINEL) {\n        x.right.parent = y;\n    }\n    x.parent = y.parent;\n    // fix size_left\n    y.size_left -= x.size_left + (x.piece ? x.piece.length : 0);\n    y.lf_left -= x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n    if (y.parent === SENTINEL) {\n        tree.root = x;\n    }\n    else if (y === y.parent.right) {\n        y.parent.right = x;\n    }\n    else {\n        y.parent.left = x;\n    }\n    x.right = y;\n    y.parent = x;\n}\nexport function rbDelete(tree, z) {\n    let x;\n    let y;\n    if (z.left === SENTINEL) {\n        y = z;\n        x = y.right;\n    }\n    else if (z.right === SENTINEL) {\n        y = z;\n        x = y.left;\n    }\n    else {\n        y = leftest(z.right);\n        x = y.right;\n    }\n    if (y === tree.root) {\n        tree.root = x;\n        // if x is null, we are removing the only node\n        x.color = 0 /* NodeColor.Black */;\n        z.detach();\n        resetSentinel();\n        tree.root.parent = SENTINEL;\n        return;\n    }\n    const yWasRed = (y.color === 1 /* NodeColor.Red */);\n    if (y === y.parent.left) {\n        y.parent.left = x;\n    }\n    else {\n        y.parent.right = x;\n    }\n    if (y === z) {\n        x.parent = y.parent;\n        recomputeTreeMetadata(tree, x);\n    }\n    else {\n        if (y.parent === z) {\n            x.parent = y;\n        }\n        else {\n            x.parent = y.parent;\n        }\n        // as we make changes to x's hierarchy, update size_left of subtree first\n        recomputeTreeMetadata(tree, x);\n        y.left = z.left;\n        y.right = z.right;\n        y.parent = z.parent;\n        y.color = z.color;\n        if (z === tree.root) {\n            tree.root = y;\n        }\n        else {\n            if (z === z.parent.left) {\n                z.parent.left = y;\n            }\n            else {\n                z.parent.right = y;\n            }\n        }\n        if (y.left !== SENTINEL) {\n            y.left.parent = y;\n        }\n        if (y.right !== SENTINEL) {\n            y.right.parent = y;\n        }\n        // update metadata\n        // we replace z with y, so in this sub tree, the length change is z.item.length\n        y.size_left = z.size_left;\n        y.lf_left = z.lf_left;\n        recomputeTreeMetadata(tree, y);\n    }\n    z.detach();\n    if (x.parent.left === x) {\n        const newSizeLeft = calculateSize(x);\n        const newLFLeft = calculateLF(x);\n        if (newSizeLeft !== x.parent.size_left || newLFLeft !== x.parent.lf_left) {\n            const delta = newSizeLeft - x.parent.size_left;\n            const lf_delta = newLFLeft - x.parent.lf_left;\n            x.parent.size_left = newSizeLeft;\n            x.parent.lf_left = newLFLeft;\n            updateTreeMetadata(tree, x.parent, delta, lf_delta);\n        }\n    }\n    recomputeTreeMetadata(tree, x.parent);\n    if (yWasRed) {\n        resetSentinel();\n        return;\n    }\n    // RB-DELETE-FIXUP\n    let w;\n    while (x !== tree.root && x.color === 0 /* NodeColor.Black */) {\n        if (x === x.parent.left) {\n            w = x.parent.right;\n            if (w.color === 1 /* NodeColor.Red */) {\n                w.color = 0 /* NodeColor.Black */;\n                x.parent.color = 1 /* NodeColor.Red */;\n                leftRotate(tree, x.parent);\n                w = x.parent.right;\n            }\n            if (w.left.color === 0 /* NodeColor.Black */ && w.right.color === 0 /* NodeColor.Black */) {\n                w.color = 1 /* NodeColor.Red */;\n                x = x.parent;\n            }\n            else {\n                if (w.right.color === 0 /* NodeColor.Black */) {\n                    w.left.color = 0 /* NodeColor.Black */;\n                    w.color = 1 /* NodeColor.Red */;\n                    rightRotate(tree, w);\n                    w = x.parent.right;\n                }\n                w.color = x.parent.color;\n                x.parent.color = 0 /* NodeColor.Black */;\n                w.right.color = 0 /* NodeColor.Black */;\n                leftRotate(tree, x.parent);\n                x = tree.root;\n            }\n        }\n        else {\n            w = x.parent.left;\n            if (w.color === 1 /* NodeColor.Red */) {\n                w.color = 0 /* NodeColor.Black */;\n                x.parent.color = 1 /* NodeColor.Red */;\n                rightRotate(tree, x.parent);\n                w = x.parent.left;\n            }\n            if (w.left.color === 0 /* NodeColor.Black */ && w.right.color === 0 /* NodeColor.Black */) {\n                w.color = 1 /* NodeColor.Red */;\n                x = x.parent;\n            }\n            else {\n                if (w.left.color === 0 /* NodeColor.Black */) {\n                    w.right.color = 0 /* NodeColor.Black */;\n                    w.color = 1 /* NodeColor.Red */;\n                    leftRotate(tree, w);\n                    w = x.parent.left;\n                }\n                w.color = x.parent.color;\n                x.parent.color = 0 /* NodeColor.Black */;\n                w.left.color = 0 /* NodeColor.Black */;\n                rightRotate(tree, x.parent);\n                x = tree.root;\n            }\n        }\n    }\n    x.color = 0 /* NodeColor.Black */;\n    resetSentinel();\n}\nexport function fixInsert(tree, x) {\n    recomputeTreeMetadata(tree, x);\n    while (x !== tree.root && x.parent.color === 1 /* NodeColor.Red */) {\n        if (x.parent === x.parent.parent.left) {\n            const y = x.parent.parent.right;\n            if (y.color === 1 /* NodeColor.Red */) {\n                x.parent.color = 0 /* NodeColor.Black */;\n                y.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.right) {\n                    x = x.parent;\n                    leftRotate(tree, x);\n                }\n                x.parent.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                rightRotate(tree, x.parent.parent);\n            }\n        }\n        else {\n            const y = x.parent.parent.left;\n            if (y.color === 1 /* NodeColor.Red */) {\n                x.parent.color = 0 /* NodeColor.Black */;\n                y.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.left) {\n                    x = x.parent;\n                    rightRotate(tree, x);\n                }\n                x.parent.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                leftRotate(tree, x.parent.parent);\n            }\n        }\n    }\n    tree.root.color = 0 /* NodeColor.Black */;\n}\nexport function updateTreeMetadata(tree, x, delta, lineFeedCntDelta) {\n    // node length change or line feed count change\n    while (x !== tree.root && x !== SENTINEL) {\n        if (x.parent.left === x) {\n            x.parent.size_left += delta;\n            x.parent.lf_left += lineFeedCntDelta;\n        }\n        x = x.parent;\n    }\n}\nexport function recomputeTreeMetadata(tree, x) {\n    let delta = 0;\n    let lf_delta = 0;\n    if (x === tree.root) {\n        return;\n    }\n    // go upwards till the node whose left subtree is changed.\n    while (x !== tree.root && x === x.parent.right) {\n        x = x.parent;\n    }\n    if (x === tree.root) {\n        // well, it means we add a node to the end (inorder)\n        return;\n    }\n    // x is the node whose right subtree is changed.\n    x = x.parent;\n    delta = calculateSize(x.left) - x.size_left;\n    lf_delta = calculateLF(x.left) - x.lf_left;\n    x.size_left += delta;\n    x.lf_left += lf_delta;\n    // go upwards till root. O(logN)\n    while (x !== tree.root && (delta !== 0 || lf_delta !== 0)) {\n        if (x.parent.left === x) {\n            x.parent.size_left += delta;\n            x.parent.lf_left += lf_delta;\n        }\n        x = x.parent;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { FindMatch } from '../../model.js';\nimport { SENTINEL, TreeNode, fixInsert, leftest, rbDelete, righttest, updateTreeMetadata } from './rbTreeBase.js';\nimport { Searcher, createFindMatch, isValidMatch } from '../textModelSearch.js';\n// const lfRegex = new RegExp(/\\r\\n|\\r|\\n/g);\nconst AverageBufferSize = 65535;\nfunction createUintArray(arr) {\n    let r;\n    if (arr[arr.length - 1] < 65536) {\n        r = new Uint16Array(arr.length);\n    }\n    else {\n        r = new Uint32Array(arr.length);\n    }\n    r.set(arr, 0);\n    return r;\n}\nclass LineStarts {\n    constructor(lineStarts, cr, lf, crlf, isBasicASCII) {\n        this.lineStarts = lineStarts;\n        this.cr = cr;\n        this.lf = lf;\n        this.crlf = crlf;\n        this.isBasicASCII = isBasicASCII;\n    }\n}\nexport function createLineStartsFast(str, readonly = true) {\n    const r = [0];\n    let rLength = 1;\n    for (let i = 0, len = str.length; i < len; i++) {\n        const chr = str.charCodeAt(i);\n        if (chr === 13 /* CharCode.CarriageReturn */) {\n            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                // \\r\\n... case\n                r[rLength++] = i + 2;\n                i++; // skip \\n\n            }\n            else {\n                // \\r... case\n                r[rLength++] = i + 1;\n            }\n        }\n        else if (chr === 10 /* CharCode.LineFeed */) {\n            r[rLength++] = i + 1;\n        }\n    }\n    if (readonly) {\n        return createUintArray(r);\n    }\n    else {\n        return r;\n    }\n}\nexport function createLineStarts(r, str) {\n    r.length = 0;\n    r[0] = 0;\n    let rLength = 1;\n    let cr = 0, lf = 0, crlf = 0;\n    let isBasicASCII = true;\n    for (let i = 0, len = str.length; i < len; i++) {\n        const chr = str.charCodeAt(i);\n        if (chr === 13 /* CharCode.CarriageReturn */) {\n            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                // \\r\\n... case\n                crlf++;\n                r[rLength++] = i + 2;\n                i++; // skip \\n\n            }\n            else {\n                cr++;\n                // \\r... case\n                r[rLength++] = i + 1;\n            }\n        }\n        else if (chr === 10 /* CharCode.LineFeed */) {\n            lf++;\n            r[rLength++] = i + 1;\n        }\n        else {\n            if (isBasicASCII) {\n                if (chr !== 9 /* CharCode.Tab */ && (chr < 32 || chr > 126)) {\n                    isBasicASCII = false;\n                }\n            }\n        }\n    }\n    const result = new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII);\n    r.length = 0;\n    return result;\n}\nexport class Piece {\n    constructor(bufferIndex, start, end, lineFeedCnt, length) {\n        this.bufferIndex = bufferIndex;\n        this.start = start;\n        this.end = end;\n        this.lineFeedCnt = lineFeedCnt;\n        this.length = length;\n    }\n}\nexport class StringBuffer {\n    constructor(buffer, lineStarts) {\n        this.buffer = buffer;\n        this.lineStarts = lineStarts;\n    }\n}\n/**\n * Readonly snapshot for piece tree.\n * In a real multiple thread environment, to make snapshot reading always work correctly, we need to\n * 1. Make TreeNode.piece immutable, then reading and writing can run in parallel.\n * 2. TreeNode/Buffers normalization should not happen during snapshot reading.\n */\nclass PieceTreeSnapshot {\n    constructor(tree, BOM) {\n        this._pieces = [];\n        this._tree = tree;\n        this._BOM = BOM;\n        this._index = 0;\n        if (tree.root !== SENTINEL) {\n            tree.iterate(tree.root, node => {\n                if (node !== SENTINEL) {\n                    this._pieces.push(node.piece);\n                }\n                return true;\n            });\n        }\n    }\n    read() {\n        if (this._pieces.length === 0) {\n            if (this._index === 0) {\n                this._index++;\n                return this._BOM;\n            }\n            else {\n                return null;\n            }\n        }\n        if (this._index > this._pieces.length - 1) {\n            return null;\n        }\n        if (this._index === 0) {\n            return this._BOM + this._tree.getPieceContent(this._pieces[this._index++]);\n        }\n        return this._tree.getPieceContent(this._pieces[this._index++]);\n    }\n}\nclass PieceTreeSearchCache {\n    constructor(limit) {\n        this._limit = limit;\n        this._cache = [];\n    }\n    get(offset) {\n        for (let i = this._cache.length - 1; i >= 0; i--) {\n            const nodePos = this._cache[i];\n            if (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {\n                return nodePos;\n            }\n        }\n        return null;\n    }\n    get2(lineNumber) {\n        for (let i = this._cache.length - 1; i >= 0; i--) {\n            const nodePos = this._cache[i];\n            if (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {\n                return nodePos;\n            }\n        }\n        return null;\n    }\n    set(nodePosition) {\n        if (this._cache.length >= this._limit) {\n            this._cache.shift();\n        }\n        this._cache.push(nodePosition);\n    }\n    validate(offset) {\n        let hasInvalidVal = false;\n        const tmp = this._cache;\n        for (let i = 0; i < tmp.length; i++) {\n            const nodePos = tmp[i];\n            if (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {\n                tmp[i] = null;\n                hasInvalidVal = true;\n                continue;\n            }\n        }\n        if (hasInvalidVal) {\n            const newArr = [];\n            for (const entry of tmp) {\n                if (entry !== null) {\n                    newArr.push(entry);\n                }\n            }\n            this._cache = newArr;\n        }\n    }\n}\nexport class PieceTreeBase {\n    constructor(chunks, eol, eolNormalized) {\n        this.create(chunks, eol, eolNormalized);\n    }\n    create(chunks, eol, eolNormalized) {\n        this._buffers = [\n            new StringBuffer('', [0])\n        ];\n        this._lastChangeBufferPos = { line: 0, column: 0 };\n        this.root = SENTINEL;\n        this._lineCnt = 1;\n        this._length = 0;\n        this._EOL = eol;\n        this._EOLLength = eol.length;\n        this._EOLNormalized = eolNormalized;\n        let lastNode = null;\n        for (let i = 0, len = chunks.length; i < len; i++) {\n            if (chunks[i].buffer.length > 0) {\n                if (!chunks[i].lineStarts) {\n                    chunks[i].lineStarts = createLineStartsFast(chunks[i].buffer);\n                }\n                const piece = new Piece(i + 1, { line: 0, column: 0 }, { line: chunks[i].lineStarts.length - 1, column: chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1] }, chunks[i].lineStarts.length - 1, chunks[i].buffer.length);\n                this._buffers.push(chunks[i]);\n                lastNode = this.rbInsertRight(lastNode, piece);\n            }\n        }\n        this._searchCache = new PieceTreeSearchCache(1);\n        this._lastVisitedLine = { lineNumber: 0, value: '' };\n        this.computeBufferMetadata();\n    }\n    normalizeEOL(eol) {\n        const averageBufferSize = AverageBufferSize;\n        const min = averageBufferSize - Math.floor(averageBufferSize / 3);\n        const max = min * 2;\n        let tempChunk = '';\n        let tempChunkLen = 0;\n        const chunks = [];\n        this.iterate(this.root, node => {\n            const str = this.getNodeContent(node);\n            const len = str.length;\n            if (tempChunkLen <= min || tempChunkLen + len < max) {\n                tempChunk += str;\n                tempChunkLen += len;\n                return true;\n            }\n            // flush anyways\n            const text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n            chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n            tempChunk = str;\n            tempChunkLen = len;\n            return true;\n        });\n        if (tempChunkLen > 0) {\n            const text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n            chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n        }\n        this.create(chunks, eol, true);\n    }\n    // #region Buffer API\n    getEOL() {\n        return this._EOL;\n    }\n    setEOL(newEOL) {\n        this._EOL = newEOL;\n        this._EOLLength = this._EOL.length;\n        this.normalizeEOL(newEOL);\n    }\n    createSnapshot(BOM) {\n        return new PieceTreeSnapshot(this, BOM);\n    }\n    getOffsetAt(lineNumber, column) {\n        let leftLen = 0; // inorder\n        let x = this.root;\n        while (x !== SENTINEL) {\n            if (x.left !== SENTINEL && x.lf_left + 1 >= lineNumber) {\n                x = x.left;\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {\n                leftLen += x.size_left;\n                // lineNumber >= 2\n                const accumualtedValInCurrentIndex = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                return leftLen += accumualtedValInCurrentIndex + column - 1;\n            }\n            else {\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                leftLen += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        return leftLen;\n    }\n    getPositionAt(offset) {\n        offset = Math.floor(offset);\n        offset = Math.max(0, offset);\n        let x = this.root;\n        let lfCnt = 0;\n        const originalOffset = offset;\n        while (x !== SENTINEL) {\n            if (x.size_left !== 0 && x.size_left >= offset) {\n                x = x.left;\n            }\n            else if (x.size_left + x.piece.length >= offset) {\n                const out = this.getIndexOf(x, offset - x.size_left);\n                lfCnt += x.lf_left + out.index;\n                if (out.index === 0) {\n                    const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n                    const column = originalOffset - lineStartOffset;\n                    return new Position(lfCnt + 1, column + 1);\n                }\n                return new Position(lfCnt + 1, out.remainder + 1);\n            }\n            else {\n                offset -= x.size_left + x.piece.length;\n                lfCnt += x.lf_left + x.piece.lineFeedCnt;\n                if (x.right === SENTINEL) {\n                    // last node\n                    const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n                    const column = originalOffset - offset - lineStartOffset;\n                    return new Position(lfCnt + 1, column + 1);\n                }\n                else {\n                    x = x.right;\n                }\n            }\n        }\n        return new Position(1, 1);\n    }\n    getValueInRange(range, eol) {\n        if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n            return '';\n        }\n        const startPosition = this.nodeAt2(range.startLineNumber, range.startColumn);\n        const endPosition = this.nodeAt2(range.endLineNumber, range.endColumn);\n        const value = this.getValueInRange2(startPosition, endPosition);\n        if (eol) {\n            if (eol !== this._EOL || !this._EOLNormalized) {\n                return value.replace(/\\r\\n|\\r|\\n/g, eol);\n            }\n            if (eol === this.getEOL() && this._EOLNormalized) {\n                if (eol === '\\r\\n') {\n                }\n                return value;\n            }\n            return value.replace(/\\r\\n|\\r|\\n/g, eol);\n        }\n        return value;\n    }\n    getValueInRange2(startPosition, endPosition) {\n        if (startPosition.node === endPosition.node) {\n            const node = startPosition.node;\n            const buffer = this._buffers[node.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n            return buffer.substring(startOffset + startPosition.remainder, startOffset + endPosition.remainder);\n        }\n        let x = startPosition.node;\n        const buffer = this._buffers[x.piece.bufferIndex].buffer;\n        const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n        let ret = buffer.substring(startOffset + startPosition.remainder, startOffset + x.piece.length);\n        x = x.next();\n        while (x !== SENTINEL) {\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n            if (x === endPosition.node) {\n                ret += buffer.substring(startOffset, startOffset + endPosition.remainder);\n                break;\n            }\n            else {\n                ret += buffer.substr(startOffset, x.piece.length);\n            }\n            x = x.next();\n        }\n        return ret;\n    }\n    getLinesContent() {\n        const lines = [];\n        let linesLength = 0;\n        let currentLine = '';\n        let danglingCR = false;\n        this.iterate(this.root, node => {\n            if (node === SENTINEL) {\n                return true;\n            }\n            const piece = node.piece;\n            let pieceLength = piece.length;\n            if (pieceLength === 0) {\n                return true;\n            }\n            const buffer = this._buffers[piece.bufferIndex].buffer;\n            const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n            const pieceStartLine = piece.start.line;\n            const pieceEndLine = piece.end.line;\n            let pieceStartOffset = lineStarts[pieceStartLine] + piece.start.column;\n            if (danglingCR) {\n                if (buffer.charCodeAt(pieceStartOffset) === 10 /* CharCode.LineFeed */) {\n                    // pretend the \\n was in the previous piece..\n                    pieceStartOffset++;\n                    pieceLength--;\n                }\n                lines[linesLength++] = currentLine;\n                currentLine = '';\n                danglingCR = false;\n                if (pieceLength === 0) {\n                    return true;\n                }\n            }\n            if (pieceStartLine === pieceEndLine) {\n                // this piece has no new lines\n                if (!this._EOLNormalized && buffer.charCodeAt(pieceStartOffset + pieceLength - 1) === 13 /* CharCode.CarriageReturn */) {\n                    danglingCR = true;\n                    currentLine += buffer.substr(pieceStartOffset, pieceLength - 1);\n                }\n                else {\n                    currentLine += buffer.substr(pieceStartOffset, pieceLength);\n                }\n                return true;\n            }\n            // add the text before the first line start in this piece\n            currentLine += (this._EOLNormalized\n                ? buffer.substring(pieceStartOffset, Math.max(pieceStartOffset, lineStarts[pieceStartLine + 1] - this._EOLLength))\n                : buffer.substring(pieceStartOffset, lineStarts[pieceStartLine + 1]).replace(/(\\r\\n|\\r|\\n)$/, ''));\n            lines[linesLength++] = currentLine;\n            for (let line = pieceStartLine + 1; line < pieceEndLine; line++) {\n                currentLine = (this._EOLNormalized\n                    ? buffer.substring(lineStarts[line], lineStarts[line + 1] - this._EOLLength)\n                    : buffer.substring(lineStarts[line], lineStarts[line + 1]).replace(/(\\r\\n|\\r|\\n)$/, ''));\n                lines[linesLength++] = currentLine;\n            }\n            if (!this._EOLNormalized && buffer.charCodeAt(lineStarts[pieceEndLine] + piece.end.column - 1) === 13 /* CharCode.CarriageReturn */) {\n                danglingCR = true;\n                if (piece.end.column === 0) {\n                    // The last line ended with a \\r, let's undo the push, it will be pushed by next iteration\n                    linesLength--;\n                }\n                else {\n                    currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column - 1);\n                }\n            }\n            else {\n                currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column);\n            }\n            return true;\n        });\n        if (danglingCR) {\n            lines[linesLength++] = currentLine;\n            currentLine = '';\n        }\n        lines[linesLength++] = currentLine;\n        return lines;\n    }\n    getLength() {\n        return this._length;\n    }\n    getLineCount() {\n        return this._lineCnt;\n    }\n    getLineContent(lineNumber) {\n        if (this._lastVisitedLine.lineNumber === lineNumber) {\n            return this._lastVisitedLine.value;\n        }\n        this._lastVisitedLine.lineNumber = lineNumber;\n        if (lineNumber === this._lineCnt) {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber);\n        }\n        else if (this._EOLNormalized) {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber, this._EOLLength);\n        }\n        else {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber).replace(/(\\r\\n|\\r|\\n)$/, '');\n        }\n        return this._lastVisitedLine.value;\n    }\n    _getCharCode(nodePos) {\n        if (nodePos.remainder === nodePos.node.piece.length) {\n            // the char we want to fetch is at the head of next node.\n            const matchingNode = nodePos.node.next();\n            if (!matchingNode) {\n                return 0;\n            }\n            const buffer = this._buffers[matchingNode.piece.bufferIndex];\n            const startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);\n            return buffer.buffer.charCodeAt(startOffset);\n        }\n        else {\n            const buffer = this._buffers[nodePos.node.piece.bufferIndex];\n            const startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);\n            const targetOffset = startOffset + nodePos.remainder;\n            return buffer.buffer.charCodeAt(targetOffset);\n        }\n    }\n    getLineCharCode(lineNumber, index) {\n        const nodePos = this.nodeAt2(lineNumber, index + 1);\n        return this._getCharCode(nodePos);\n    }\n    getLineLength(lineNumber) {\n        if (lineNumber === this.getLineCount()) {\n            const startOffset = this.getOffsetAt(lineNumber, 1);\n            return this.getLength() - startOffset;\n        }\n        return this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;\n    }\n    findMatchesInNode(node, searcher, startLineNumber, startColumn, startCursor, endCursor, searchData, captureMatches, limitResultCount, resultLen, result) {\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n        const start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);\n        const end = this.offsetInBuffer(node.piece.bufferIndex, endCursor);\n        let m;\n        // Reset regex to search from the beginning\n        const ret = { line: 0, column: 0 };\n        let searchText;\n        let offsetInBuffer;\n        if (searcher._wordSeparators) {\n            searchText = buffer.buffer.substring(start, end);\n            offsetInBuffer = (offset) => offset + start;\n            searcher.reset(0);\n        }\n        else {\n            searchText = buffer.buffer;\n            offsetInBuffer = (offset) => offset;\n            searcher.reset(start);\n        }\n        do {\n            m = searcher.next(searchText);\n            if (m) {\n                if (offsetInBuffer(m.index) >= end) {\n                    return resultLen;\n                }\n                this.positionInBuffer(node, offsetInBuffer(m.index) - startOffsetInBuffer, ret);\n                const lineFeedCnt = this.getLineFeedCnt(node.piece.bufferIndex, startCursor, ret);\n                const retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1;\n                const retEndColumn = retStartColumn + m[0].length;\n                result[resultLen++] = createFindMatch(new Range(startLineNumber + lineFeedCnt, retStartColumn, startLineNumber + lineFeedCnt, retEndColumn), m, captureMatches);\n                if (offsetInBuffer(m.index) + m[0].length >= end) {\n                    return resultLen;\n                }\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        const result = [];\n        let resultLen = 0;\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        let startPosition = this.nodeAt2(searchRange.startLineNumber, searchRange.startColumn);\n        if (startPosition === null) {\n            return [];\n        }\n        const endPosition = this.nodeAt2(searchRange.endLineNumber, searchRange.endColumn);\n        if (endPosition === null) {\n            return [];\n        }\n        let start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n        const end = this.positionInBuffer(endPosition.node, endPosition.remainder);\n        if (startPosition.node === endPosition.node) {\n            this.findMatchesInNode(startPosition.node, searcher, searchRange.startLineNumber, searchRange.startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n            return result;\n        }\n        let startLineNumber = searchRange.startLineNumber;\n        let currentNode = startPosition.node;\n        while (currentNode !== endPosition.node) {\n            const lineBreakCnt = this.getLineFeedCnt(currentNode.piece.bufferIndex, start, currentNode.piece.end);\n            if (lineBreakCnt >= 1) {\n                // last line break position\n                const lineStarts = this._buffers[currentNode.piece.bufferIndex].lineStarts;\n                const startOffsetInBuffer = this.offsetInBuffer(currentNode.piece.bufferIndex, currentNode.piece.start);\n                const nextLineStartOffset = lineStarts[start.line + lineBreakCnt];\n                const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n                resultLen = this.findMatchesInNode(currentNode, searcher, startLineNumber, startColumn, start, this.positionInBuffer(currentNode, nextLineStartOffset - startOffsetInBuffer), searchData, captureMatches, limitResultCount, resultLen, result);\n                if (resultLen >= limitResultCount) {\n                    return result;\n                }\n                startLineNumber += lineBreakCnt;\n            }\n            const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n            // search for the remaining content\n            if (startLineNumber === searchRange.endLineNumber) {\n                const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n                resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n                return result;\n            }\n            resultLen = this._findMatchesInLine(searchData, searcher, this.getLineContent(startLineNumber).substr(startColumn), startLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n            if (resultLen >= limitResultCount) {\n                return result;\n            }\n            startLineNumber++;\n            startPosition = this.nodeAt2(startLineNumber, 1);\n            currentNode = startPosition.node;\n            start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n        }\n        if (startLineNumber === searchRange.endLineNumber) {\n            const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n            const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n            return result;\n        }\n        const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n        resultLen = this.findMatchesInNode(endPosition.node, searcher, startLineNumber, startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n        return result;\n    }\n    _findMatchesInLine(searchData, searcher, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n        const wordSeparators = searchData.wordSeparators;\n        if (!captureMatches && searchData.simpleSearch) {\n            const searchString = searchData.simpleSearch;\n            const searchStringLen = searchString.length;\n            const textLength = text.length;\n            let lastMatchIndex = -searchStringLen;\n            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n                    result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n                    if (resultLen >= limitResultCount) {\n                        return resultLen;\n                    }\n                }\n            }\n            return resultLen;\n        }\n        let m;\n        // Reset regex to search from the beginning\n        searcher.reset(0);\n        do {\n            m = searcher.next(text);\n            if (m) {\n                result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    // #endregion\n    // #region Piece Table\n    insert(offset, value, eolNormalized = false) {\n        this._EOLNormalized = this._EOLNormalized && eolNormalized;\n        this._lastVisitedLine.lineNumber = 0;\n        this._lastVisitedLine.value = '';\n        if (this.root !== SENTINEL) {\n            const { node, remainder, nodeStartOffset } = this.nodeAt(offset);\n            const piece = node.piece;\n            const bufferIndex = piece.bufferIndex;\n            const insertPosInBuffer = this.positionInBuffer(node, remainder);\n            if (node.piece.bufferIndex === 0 &&\n                piece.end.line === this._lastChangeBufferPos.line &&\n                piece.end.column === this._lastChangeBufferPos.column &&\n                (nodeStartOffset + piece.length === offset) &&\n                value.length < AverageBufferSize) {\n                // changed buffer\n                this.appendToNode(node, value);\n                this.computeBufferMetadata();\n                return;\n            }\n            if (nodeStartOffset === offset) {\n                this.insertContentToNodeLeft(value, node);\n                this._searchCache.validate(offset);\n            }\n            else if (nodeStartOffset + node.piece.length > offset) {\n                // we are inserting into the middle of a node.\n                const nodesToDel = [];\n                let newRightPiece = new Piece(piece.bufferIndex, insertPosInBuffer, piece.end, this.getLineFeedCnt(piece.bufferIndex, insertPosInBuffer, piece.end), this.offsetInBuffer(bufferIndex, piece.end) - this.offsetInBuffer(bufferIndex, insertPosInBuffer));\n                if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n                    const headOfRight = this.nodeCharCodeAt(node, remainder);\n                    if (headOfRight === 10 /** \\n */) {\n                        const newStart = { line: newRightPiece.start.line + 1, column: 0 };\n                        newRightPiece = new Piece(newRightPiece.bufferIndex, newStart, newRightPiece.end, this.getLineFeedCnt(newRightPiece.bufferIndex, newStart, newRightPiece.end), newRightPiece.length - 1);\n                        value += '\\n';\n                    }\n                }\n                // reuse node for content before insertion point.\n                if (this.shouldCheckCRLF() && this.startWithLF(value)) {\n                    const tailOfLeft = this.nodeCharCodeAt(node, remainder - 1);\n                    if (tailOfLeft === 13 /** \\r */) {\n                        const previousPos = this.positionInBuffer(node, remainder - 1);\n                        this.deleteNodeTail(node, previousPos);\n                        value = '\\r' + value;\n                        if (node.piece.length === 0) {\n                            nodesToDel.push(node);\n                        }\n                    }\n                    else {\n                        this.deleteNodeTail(node, insertPosInBuffer);\n                    }\n                }\n                else {\n                    this.deleteNodeTail(node, insertPosInBuffer);\n                }\n                const newPieces = this.createNewPieces(value);\n                if (newRightPiece.length > 0) {\n                    this.rbInsertRight(node, newRightPiece);\n                }\n                let tmpNode = node;\n                for (let k = 0; k < newPieces.length; k++) {\n                    tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n                }\n                this.deleteNodes(nodesToDel);\n            }\n            else {\n                this.insertContentToNodeRight(value, node);\n            }\n        }\n        else {\n            // insert new node\n            const pieces = this.createNewPieces(value);\n            let node = this.rbInsertLeft(null, pieces[0]);\n            for (let k = 1; k < pieces.length; k++) {\n                node = this.rbInsertRight(node, pieces[k]);\n            }\n        }\n        // todo, this is too brutal. Total line feed count should be updated the same way as lf_left.\n        this.computeBufferMetadata();\n    }\n    delete(offset, cnt) {\n        this._lastVisitedLine.lineNumber = 0;\n        this._lastVisitedLine.value = '';\n        if (cnt <= 0 || this.root === SENTINEL) {\n            return;\n        }\n        const startPosition = this.nodeAt(offset);\n        const endPosition = this.nodeAt(offset + cnt);\n        const startNode = startPosition.node;\n        const endNode = endPosition.node;\n        if (startNode === endNode) {\n            const startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n            const endSplitPosInBuffer = this.positionInBuffer(startNode, endPosition.remainder);\n            if (startPosition.nodeStartOffset === offset) {\n                if (cnt === startNode.piece.length) { // delete node\n                    const next = startNode.next();\n                    rbDelete(this, startNode);\n                    this.validateCRLFWithPrevNode(next);\n                    this.computeBufferMetadata();\n                    return;\n                }\n                this.deleteNodeHead(startNode, endSplitPosInBuffer);\n                this._searchCache.validate(offset);\n                this.validateCRLFWithPrevNode(startNode);\n                this.computeBufferMetadata();\n                return;\n            }\n            if (startPosition.nodeStartOffset + startNode.piece.length === offset + cnt) {\n                this.deleteNodeTail(startNode, startSplitPosInBuffer);\n                this.validateCRLFWithNextNode(startNode);\n                this.computeBufferMetadata();\n                return;\n            }\n            // delete content in the middle, this node will be splitted to nodes\n            this.shrinkNode(startNode, startSplitPosInBuffer, endSplitPosInBuffer);\n            this.computeBufferMetadata();\n            return;\n        }\n        const nodesToDel = [];\n        const startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n        this.deleteNodeTail(startNode, startSplitPosInBuffer);\n        this._searchCache.validate(offset);\n        if (startNode.piece.length === 0) {\n            nodesToDel.push(startNode);\n        }\n        // update last touched node\n        const endSplitPosInBuffer = this.positionInBuffer(endNode, endPosition.remainder);\n        this.deleteNodeHead(endNode, endSplitPosInBuffer);\n        if (endNode.piece.length === 0) {\n            nodesToDel.push(endNode);\n        }\n        // delete nodes in between\n        const secondNode = startNode.next();\n        for (let node = secondNode; node !== SENTINEL && node !== endNode; node = node.next()) {\n            nodesToDel.push(node);\n        }\n        const prev = startNode.piece.length === 0 ? startNode.prev() : startNode;\n        this.deleteNodes(nodesToDel);\n        this.validateCRLFWithNextNode(prev);\n        this.computeBufferMetadata();\n    }\n    insertContentToNodeLeft(value, node) {\n        // we are inserting content to the beginning of node\n        const nodesToDel = [];\n        if (this.shouldCheckCRLF() && this.endWithCR(value) && this.startWithLF(node)) {\n            // move `\\n` to new node.\n            const piece = node.piece;\n            const newStart = { line: piece.start.line + 1, column: 0 };\n            const nPiece = new Piece(piece.bufferIndex, newStart, piece.end, this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end), piece.length - 1);\n            node.piece = nPiece;\n            value += '\\n';\n            updateTreeMetadata(this, node, -1, -1);\n            if (node.piece.length === 0) {\n                nodesToDel.push(node);\n            }\n        }\n        const newPieces = this.createNewPieces(value);\n        let newNode = this.rbInsertLeft(node, newPieces[newPieces.length - 1]);\n        for (let k = newPieces.length - 2; k >= 0; k--) {\n            newNode = this.rbInsertLeft(newNode, newPieces[k]);\n        }\n        this.validateCRLFWithPrevNode(newNode);\n        this.deleteNodes(nodesToDel);\n    }\n    insertContentToNodeRight(value, node) {\n        // we are inserting to the right of this node.\n        if (this.adjustCarriageReturnFromNext(value, node)) {\n            // move \\n to the new node.\n            value += '\\n';\n        }\n        const newPieces = this.createNewPieces(value);\n        const newNode = this.rbInsertRight(node, newPieces[0]);\n        let tmpNode = newNode;\n        for (let k = 1; k < newPieces.length; k++) {\n            tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n        }\n        this.validateCRLFWithPrevNode(newNode);\n    }\n    positionInBuffer(node, remainder, ret) {\n        const piece = node.piece;\n        const bufferIndex = node.piece.bufferIndex;\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        const startOffset = lineStarts[piece.start.line] + piece.start.column;\n        const offset = startOffset + remainder;\n        // binary search offset between startOffset and endOffset\n        let low = piece.start.line;\n        let high = piece.end.line;\n        let mid = 0;\n        let midStop = 0;\n        let midStart = 0;\n        while (low <= high) {\n            mid = low + ((high - low) / 2) | 0;\n            midStart = lineStarts[mid];\n            if (mid === high) {\n                break;\n            }\n            midStop = lineStarts[mid + 1];\n            if (offset < midStart) {\n                high = mid - 1;\n            }\n            else if (offset >= midStop) {\n                low = mid + 1;\n            }\n            else {\n                break;\n            }\n        }\n        if (ret) {\n            ret.line = mid;\n            ret.column = offset - midStart;\n            return null;\n        }\n        return {\n            line: mid,\n            column: offset - midStart\n        };\n    }\n    getLineFeedCnt(bufferIndex, start, end) {\n        // we don't need to worry about start: abc\\r|\\n, or abc|\\r, or abc|\\n, or abc|\\r\\n doesn't change the fact that, there is one line break after start.\n        // now let's take care of end: abc\\r|\\n, if end is in between \\r and \\n, we need to add line feed count by 1\n        if (end.column === 0) {\n            return end.line - start.line;\n        }\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        if (end.line === lineStarts.length - 1) { // it means, there is no \\n after end, otherwise, there will be one more lineStart.\n            return end.line - start.line;\n        }\n        const nextLineStartOffset = lineStarts[end.line + 1];\n        const endOffset = lineStarts[end.line] + end.column;\n        if (nextLineStartOffset > endOffset + 1) { // there are more than 1 character after end, which means it can't be \\n\n            return end.line - start.line;\n        }\n        // endOffset + 1 === nextLineStartOffset\n        // character at endOffset is \\n, so we check the character before first\n        // if character at endOffset is \\r, end.column is 0 and we can't get here.\n        const previousCharOffset = endOffset - 1; // end.column > 0 so it's okay.\n        const buffer = this._buffers[bufferIndex].buffer;\n        if (buffer.charCodeAt(previousCharOffset) === 13) {\n            return end.line - start.line + 1;\n        }\n        else {\n            return end.line - start.line;\n        }\n    }\n    offsetInBuffer(bufferIndex, cursor) {\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        return lineStarts[cursor.line] + cursor.column;\n    }\n    deleteNodes(nodes) {\n        for (let i = 0; i < nodes.length; i++) {\n            rbDelete(this, nodes[i]);\n        }\n    }\n    createNewPieces(text) {\n        if (text.length > AverageBufferSize) {\n            // the content is large, operations like substring, charCode becomes slow\n            // so here we split it into smaller chunks, just like what we did for CR/LF normalization\n            const newPieces = [];\n            while (text.length > AverageBufferSize) {\n                const lastChar = text.charCodeAt(AverageBufferSize - 1);\n                let splitText;\n                if (lastChar === 13 /* CharCode.CarriageReturn */ || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n                    // last character is \\r or a high surrogate => keep it back\n                    splitText = text.substring(0, AverageBufferSize - 1);\n                    text = text.substring(AverageBufferSize - 1);\n                }\n                else {\n                    splitText = text.substring(0, AverageBufferSize);\n                    text = text.substring(AverageBufferSize);\n                }\n                const lineStarts = createLineStartsFast(splitText);\n                newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts.length - 1, column: splitText.length - lineStarts[lineStarts.length - 1] }, lineStarts.length - 1, splitText.length));\n                this._buffers.push(new StringBuffer(splitText, lineStarts));\n            }\n            const lineStarts = createLineStartsFast(text);\n            newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts.length - 1, column: text.length - lineStarts[lineStarts.length - 1] }, lineStarts.length - 1, text.length));\n            this._buffers.push(new StringBuffer(text, lineStarts));\n            return newPieces;\n        }\n        let startOffset = this._buffers[0].buffer.length;\n        const lineStarts = createLineStartsFast(text, false);\n        let start = this._lastChangeBufferPos;\n        if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === startOffset\n            && startOffset !== 0\n            && this.startWithLF(text)\n            && this.endWithCR(this._buffers[0].buffer) // todo, we can check this._lastChangeBufferPos's column as it's the last one\n        ) {\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1 };\n            start = this._lastChangeBufferPos;\n            for (let i = 0; i < lineStarts.length; i++) {\n                lineStarts[i] += startOffset + 1;\n            }\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n            this._buffers[0].buffer += '_' + text;\n            startOffset += 1;\n        }\n        else {\n            if (startOffset !== 0) {\n                for (let i = 0; i < lineStarts.length; i++) {\n                    lineStarts[i] += startOffset;\n                }\n            }\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n            this._buffers[0].buffer += text;\n        }\n        const endOffset = this._buffers[0].buffer.length;\n        const endIndex = this._buffers[0].lineStarts.length - 1;\n        const endColumn = endOffset - this._buffers[0].lineStarts[endIndex];\n        const endPos = { line: endIndex, column: endColumn };\n        const newPiece = new Piece(0, /** todo@peng */ start, endPos, this.getLineFeedCnt(0, start, endPos), endOffset - startOffset);\n        this._lastChangeBufferPos = endPos;\n        return [newPiece];\n    }\n    getLineRawContent(lineNumber, endOffset = 0) {\n        let x = this.root;\n        let ret = '';\n        const cache = this._searchCache.get2(lineNumber);\n        if (cache) {\n            x = cache.node;\n            const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber - 1);\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n            if (cache.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {\n                ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n            }\n            else {\n                const accumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber);\n                return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n            }\n        }\n        else {\n            let nodeStartOffset = 0;\n            const originalLineNumber = lineNumber;\n            while (x !== SENTINEL) {\n                if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n                    x = x.left;\n                }\n                else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n                    const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                    const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n                    const buffer = this._buffers[x.piece.bufferIndex].buffer;\n                    const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                    nodeStartOffset += x.size_left;\n                    this._searchCache.set({\n                        node: x,\n                        nodeStartOffset,\n                        nodeStartLineNumber: originalLineNumber - (lineNumber - 1 - x.lf_left)\n                    });\n                    return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n                }\n                else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n                    const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                    const buffer = this._buffers[x.piece.bufferIndex].buffer;\n                    const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                    ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n                    break;\n                }\n                else {\n                    lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                    nodeStartOffset += x.size_left + x.piece.length;\n                    x = x.right;\n                }\n            }\n        }\n        // search in order, to find the node contains end column\n        x = x.next();\n        while (x !== SENTINEL) {\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            if (x.piece.lineFeedCnt > 0) {\n                const accumulatedValue = this.getAccumulatedValue(x, 0);\n                const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                ret += buffer.substring(startOffset, startOffset + accumulatedValue - endOffset);\n                return ret;\n            }\n            else {\n                const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                ret += buffer.substr(startOffset, x.piece.length);\n            }\n            x = x.next();\n        }\n        return ret;\n    }\n    computeBufferMetadata() {\n        let x = this.root;\n        let lfCnt = 1;\n        let len = 0;\n        while (x !== SENTINEL) {\n            lfCnt += x.lf_left + x.piece.lineFeedCnt;\n            len += x.size_left + x.piece.length;\n            x = x.right;\n        }\n        this._lineCnt = lfCnt;\n        this._length = len;\n        this._searchCache.validate(this._length);\n    }\n    // #region node operations\n    getIndexOf(node, accumulatedValue) {\n        const piece = node.piece;\n        const pos = this.positionInBuffer(node, accumulatedValue);\n        const lineCnt = pos.line - piece.start.line;\n        if (this.offsetInBuffer(piece.bufferIndex, piece.end) - this.offsetInBuffer(piece.bufferIndex, piece.start) === accumulatedValue) {\n            // we are checking the end of this node, so a CRLF check is necessary.\n            const realLineCnt = this.getLineFeedCnt(node.piece.bufferIndex, piece.start, pos);\n            if (realLineCnt !== lineCnt) {\n                // aha yes, CRLF\n                return { index: realLineCnt, remainder: 0 };\n            }\n        }\n        return { index: lineCnt, remainder: pos.column };\n    }\n    getAccumulatedValue(node, index) {\n        if (index < 0) {\n            return 0;\n        }\n        const piece = node.piece;\n        const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n        const expectedLineStartIndex = piece.start.line + index + 1;\n        if (expectedLineStartIndex > piece.end.line) {\n            return lineStarts[piece.end.line] + piece.end.column - lineStarts[piece.start.line] - piece.start.column;\n        }\n        else {\n            return lineStarts[expectedLineStartIndex] - lineStarts[piece.start.line] - piece.start.column;\n        }\n    }\n    deleteNodeTail(node, pos) {\n        const piece = node.piece;\n        const originalLFCnt = piece.lineFeedCnt;\n        const originalEndOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const newEnd = pos;\n        const newEndOffset = this.offsetInBuffer(piece.bufferIndex, newEnd);\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n        const lf_delta = newLineFeedCnt - originalLFCnt;\n        const size_delta = newEndOffset - originalEndOffset;\n        const newLength = piece.length + size_delta;\n        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, size_delta, lf_delta);\n    }\n    deleteNodeHead(node, pos) {\n        const piece = node.piece;\n        const originalLFCnt = piece.lineFeedCnt;\n        const originalStartOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const newStart = pos;\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n        const newStartOffset = this.offsetInBuffer(piece.bufferIndex, newStart);\n        const lf_delta = newLineFeedCnt - originalLFCnt;\n        const size_delta = originalStartOffset - newStartOffset;\n        const newLength = piece.length + size_delta;\n        node.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, size_delta, lf_delta);\n    }\n    shrinkNode(node, start, end) {\n        const piece = node.piece;\n        const originalStartPos = piece.start;\n        const originalEndPos = piece.end;\n        // old piece, originalStartPos, start\n        const oldLength = piece.length;\n        const oldLFCnt = piece.lineFeedCnt;\n        const newEnd = start;\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n        const newLength = this.offsetInBuffer(piece.bufferIndex, start) - this.offsetInBuffer(piece.bufferIndex, originalStartPos);\n        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, newLength - oldLength, newLineFeedCnt - oldLFCnt);\n        // new right piece, end, originalEndPos\n        const newPiece = new Piece(piece.bufferIndex, end, originalEndPos, this.getLineFeedCnt(piece.bufferIndex, end, originalEndPos), this.offsetInBuffer(piece.bufferIndex, originalEndPos) - this.offsetInBuffer(piece.bufferIndex, end));\n        const newNode = this.rbInsertRight(node, newPiece);\n        this.validateCRLFWithPrevNode(newNode);\n    }\n    appendToNode(node, value) {\n        if (this.adjustCarriageReturnFromNext(value, node)) {\n            value += '\\n';\n        }\n        const hitCRLF = this.shouldCheckCRLF() && this.startWithLF(value) && this.endWithCR(node);\n        const startOffset = this._buffers[0].buffer.length;\n        this._buffers[0].buffer += value;\n        const lineStarts = createLineStartsFast(value, false);\n        for (let i = 0; i < lineStarts.length; i++) {\n            lineStarts[i] += startOffset;\n        }\n        if (hitCRLF) {\n            const prevStartOffset = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];\n            this._buffers[0].lineStarts.pop();\n            // _lastChangeBufferPos is already wrong\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: startOffset - prevStartOffset };\n        }\n        this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n        const endIndex = this._buffers[0].lineStarts.length - 1;\n        const endColumn = this._buffers[0].buffer.length - this._buffers[0].lineStarts[endIndex];\n        const newEnd = { line: endIndex, column: endColumn };\n        const newLength = node.piece.length + value.length;\n        const oldLineFeedCnt = node.piece.lineFeedCnt;\n        const newLineFeedCnt = this.getLineFeedCnt(0, node.piece.start, newEnd);\n        const lf_delta = newLineFeedCnt - oldLineFeedCnt;\n        node.piece = new Piece(node.piece.bufferIndex, node.piece.start, newEnd, newLineFeedCnt, newLength);\n        this._lastChangeBufferPos = newEnd;\n        updateTreeMetadata(this, node, value.length, lf_delta);\n    }\n    nodeAt(offset) {\n        let x = this.root;\n        const cache = this._searchCache.get(offset);\n        if (cache) {\n            return {\n                node: cache.node,\n                nodeStartOffset: cache.nodeStartOffset,\n                remainder: offset - cache.nodeStartOffset\n            };\n        }\n        let nodeStartOffset = 0;\n        while (x !== SENTINEL) {\n            if (x.size_left > offset) {\n                x = x.left;\n            }\n            else if (x.size_left + x.piece.length >= offset) {\n                nodeStartOffset += x.size_left;\n                const ret = {\n                    node: x,\n                    remainder: offset - x.size_left,\n                    nodeStartOffset\n                };\n                this._searchCache.set(ret);\n                return ret;\n            }\n            else {\n                offset -= x.size_left + x.piece.length;\n                nodeStartOffset += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        return null;\n    }\n    nodeAt2(lineNumber, column) {\n        let x = this.root;\n        let nodeStartOffset = 0;\n        while (x !== SENTINEL) {\n            if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n                x = x.left;\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n                const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n                nodeStartOffset += x.size_left;\n                return {\n                    node: x,\n                    remainder: Math.min(prevAccumualtedValue + column - 1, accumulatedValue),\n                    nodeStartOffset\n                };\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n                const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                if (prevAccumualtedValue + column - 1 <= x.piece.length) {\n                    return {\n                        node: x,\n                        remainder: prevAccumualtedValue + column - 1,\n                        nodeStartOffset\n                    };\n                }\n                else {\n                    column -= x.piece.length - prevAccumualtedValue;\n                    break;\n                }\n            }\n            else {\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                nodeStartOffset += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        // search in order, to find the node contains position.column\n        x = x.next();\n        while (x !== SENTINEL) {\n            if (x.piece.lineFeedCnt > 0) {\n                const accumulatedValue = this.getAccumulatedValue(x, 0);\n                const nodeStartOffset = this.offsetOfNode(x);\n                return {\n                    node: x,\n                    remainder: Math.min(column - 1, accumulatedValue),\n                    nodeStartOffset\n                };\n            }\n            else {\n                if (x.piece.length >= column - 1) {\n                    const nodeStartOffset = this.offsetOfNode(x);\n                    return {\n                        node: x,\n                        remainder: column - 1,\n                        nodeStartOffset\n                    };\n                }\n                else {\n                    column -= x.piece.length;\n                }\n            }\n            x = x.next();\n        }\n        return null;\n    }\n    nodeCharCodeAt(node, offset) {\n        if (node.piece.lineFeedCnt < 1) {\n            return -1;\n        }\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const newOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start) + offset;\n        return buffer.buffer.charCodeAt(newOffset);\n    }\n    offsetOfNode(node) {\n        if (!node) {\n            return 0;\n        }\n        let pos = node.size_left;\n        while (node !== this.root) {\n            if (node.parent.right === node) {\n                pos += node.parent.size_left + node.parent.piece.length;\n            }\n            node = node.parent;\n        }\n        return pos;\n    }\n    // #endregion\n    // #region CRLF\n    shouldCheckCRLF() {\n        return !(this._EOLNormalized && this._EOL === '\\n');\n    }\n    startWithLF(val) {\n        if (typeof val === 'string') {\n            return val.charCodeAt(0) === 10;\n        }\n        if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n            return false;\n        }\n        const piece = val.piece;\n        const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n        const line = piece.start.line;\n        const startOffset = lineStarts[line] + piece.start.column;\n        if (line === lineStarts.length - 1) {\n            // last line, so there is no line feed at the end of this line\n            return false;\n        }\n        const nextLineOffset = lineStarts[line + 1];\n        if (nextLineOffset > startOffset + 1) {\n            return false;\n        }\n        return this._buffers[piece.bufferIndex].buffer.charCodeAt(startOffset) === 10;\n    }\n    endWithCR(val) {\n        if (typeof val === 'string') {\n            return val.charCodeAt(val.length - 1) === 13;\n        }\n        if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n            return false;\n        }\n        return this.nodeCharCodeAt(val, val.piece.length - 1) === 13;\n    }\n    validateCRLFWithPrevNode(nextNode) {\n        if (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {\n            const node = nextNode.prev();\n            if (this.endWithCR(node)) {\n                this.fixCRLF(node, nextNode);\n            }\n        }\n    }\n    validateCRLFWithNextNode(node) {\n        if (this.shouldCheckCRLF() && this.endWithCR(node)) {\n            const nextNode = node.next();\n            if (this.startWithLF(nextNode)) {\n                this.fixCRLF(node, nextNode);\n            }\n        }\n    }\n    fixCRLF(prev, next) {\n        const nodesToDel = [];\n        // update node\n        const lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;\n        let newEnd;\n        if (prev.piece.end.column === 0) {\n            // it means, last line ends with \\r, not \\r\\n\n            newEnd = { line: prev.piece.end.line - 1, column: lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1 };\n        }\n        else {\n            // \\r\\n\n            newEnd = { line: prev.piece.end.line, column: prev.piece.end.column - 1 };\n        }\n        const prevNewLength = prev.piece.length - 1;\n        const prevNewLFCnt = prev.piece.lineFeedCnt - 1;\n        prev.piece = new Piece(prev.piece.bufferIndex, prev.piece.start, newEnd, prevNewLFCnt, prevNewLength);\n        updateTreeMetadata(this, prev, -1, -1);\n        if (prev.piece.length === 0) {\n            nodesToDel.push(prev);\n        }\n        // update nextNode\n        const newStart = { line: next.piece.start.line + 1, column: 0 };\n        const newLength = next.piece.length - 1;\n        const newLineFeedCnt = this.getLineFeedCnt(next.piece.bufferIndex, newStart, next.piece.end);\n        next.piece = new Piece(next.piece.bufferIndex, newStart, next.piece.end, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, next, -1, -1);\n        if (next.piece.length === 0) {\n            nodesToDel.push(next);\n        }\n        // create new piece which contains \\r\\n\n        const pieces = this.createNewPieces('\\r\\n');\n        this.rbInsertRight(prev, pieces[0]);\n        // delete empty nodes\n        for (let i = 0; i < nodesToDel.length; i++) {\n            rbDelete(this, nodesToDel[i]);\n        }\n    }\n    adjustCarriageReturnFromNext(value, node) {\n        if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n            const nextNode = node.next();\n            if (this.startWithLF(nextNode)) {\n                // move `\\n` forward\n                value += '\\n';\n                if (nextNode.piece.length === 1) {\n                    rbDelete(this, nextNode);\n                }\n                else {\n                    const piece = nextNode.piece;\n                    const newStart = { line: piece.start.line + 1, column: 0 };\n                    const newLength = piece.length - 1;\n                    const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n                    nextNode.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n                    updateTreeMetadata(this, nextNode, -1, -1);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    // #endregion\n    // #endregion\n    // #region Tree operations\n    iterate(node, callback) {\n        if (node === SENTINEL) {\n            return callback(SENTINEL);\n        }\n        const leftRet = this.iterate(node.left, callback);\n        if (!leftRet) {\n            return leftRet;\n        }\n        return callback(node) && this.iterate(node.right, callback);\n    }\n    getNodeContent(node) {\n        if (node === SENTINEL) {\n            return '';\n        }\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const piece = node.piece;\n        const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const currentContent = buffer.buffer.substring(startOffset, endOffset);\n        return currentContent;\n    }\n    getPieceContent(piece) {\n        const buffer = this._buffers[piece.bufferIndex];\n        const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const currentContent = buffer.buffer.substring(startOffset, endOffset);\n        return currentContent;\n    }\n    /**\n     *      node              node\n     *     /  \\              /  \\\n     *    a   b    <----   a    b\n     *                         /\n     *                        z\n     */\n    rbInsertRight(node, p) {\n        const z = new TreeNode(p, 1 /* NodeColor.Red */);\n        z.left = SENTINEL;\n        z.right = SENTINEL;\n        z.parent = SENTINEL;\n        z.size_left = 0;\n        z.lf_left = 0;\n        const x = this.root;\n        if (x === SENTINEL) {\n            this.root = z;\n            z.color = 0 /* NodeColor.Black */;\n        }\n        else if (node.right === SENTINEL) {\n            node.right = z;\n            z.parent = node;\n        }\n        else {\n            const nextNode = leftest(node.right);\n            nextNode.left = z;\n            z.parent = nextNode;\n        }\n        fixInsert(this, z);\n        return z;\n    }\n    /**\n     *      node              node\n     *     /  \\              /  \\\n     *    a   b     ---->   a    b\n     *                       \\\n     *                        z\n     */\n    rbInsertLeft(node, p) {\n        const z = new TreeNode(p, 1 /* NodeColor.Red */);\n        z.left = SENTINEL;\n        z.right = SENTINEL;\n        z.parent = SENTINEL;\n        z.size_left = 0;\n        z.lf_left = 0;\n        if (this.root === SENTINEL) {\n            this.root = z;\n            z.color = 0 /* NodeColor.Black */;\n        }\n        else if (node.left === SENTINEL) {\n            node.left = z;\n            z.parent = node;\n        }\n        else {\n            const prevNode = righttest(node.left); // a\n            prevNode.right = z;\n            z.parent = prevNode;\n        }\n        fixInsert(this, z);\n        return z;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { Range } from '../../core/range.js';\nimport { ApplyEditsResult } from '../../model.js';\nimport { PieceTreeBase } from './pieceTreeBase.js';\nimport { countEOL } from '../../core/eolCounter.js';\nimport { TextChange } from '../../core/textChange.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nexport class PieceTreeTextBuffer extends Disposable {\n    constructor(chunks, BOM, eol, containsRTL, containsUnusualLineTerminators, isBasicASCII, eolNormalized) {\n        super();\n        this._onDidChangeContent = this._register(new Emitter());\n        this._BOM = BOM;\n        this._mightContainNonBasicASCII = !isBasicASCII;\n        this._mightContainRTL = containsRTL;\n        this._mightContainUnusualLineTerminators = containsUnusualLineTerminators;\n        this._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);\n    }\n    mightContainRTL() {\n        return this._mightContainRTL;\n    }\n    mightContainUnusualLineTerminators() {\n        return this._mightContainUnusualLineTerminators;\n    }\n    resetMightContainUnusualLineTerminators() {\n        this._mightContainUnusualLineTerminators = false;\n    }\n    mightContainNonBasicASCII() {\n        return this._mightContainNonBasicASCII;\n    }\n    getBOM() {\n        return this._BOM;\n    }\n    getEOL() {\n        return this._pieceTree.getEOL();\n    }\n    createSnapshot(preserveBOM) {\n        return this._pieceTree.createSnapshot(preserveBOM ? this._BOM : '');\n    }\n    getOffsetAt(lineNumber, column) {\n        return this._pieceTree.getOffsetAt(lineNumber, column);\n    }\n    getPositionAt(offset) {\n        return this._pieceTree.getPositionAt(offset);\n    }\n    getRangeAt(start, length) {\n        const end = start + length;\n        const startPosition = this.getPositionAt(start);\n        const endPosition = this.getPositionAt(end);\n        return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n    }\n    getValueInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (range.isEmpty()) {\n            return '';\n        }\n        const lineEnding = this._getEndOfLine(eol);\n        return this._pieceTree.getValueInRange(range, lineEnding);\n    }\n    getValueLengthInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (range.isEmpty()) {\n            return 0;\n        }\n        if (range.startLineNumber === range.endLineNumber) {\n            return (range.endColumn - range.startColumn);\n        }\n        const startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);\n        // offsets use the text EOL, so we need to compensate for length differences\n        // if the requested EOL doesn't match the text EOL\n        let eolOffsetCompensation = 0;\n        const desiredEOL = this._getEndOfLine(eol);\n        const actualEOL = this.getEOL();\n        if (desiredEOL.length !== actualEOL.length) {\n            const delta = desiredEOL.length - actualEOL.length;\n            const eolCount = range.endLineNumber - range.startLineNumber;\n            eolOffsetCompensation = delta * eolCount;\n        }\n        return endOffset - startOffset + eolOffsetCompensation;\n    }\n    getCharacterCountInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (this._mightContainNonBasicASCII) {\n            // we must count by iterating\n            let result = 0;\n            const fromLineNumber = range.startLineNumber;\n            const toLineNumber = range.endLineNumber;\n            for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n                const lineContent = this.getLineContent(lineNumber);\n                const fromOffset = (lineNumber === fromLineNumber ? range.startColumn - 1 : 0);\n                const toOffset = (lineNumber === toLineNumber ? range.endColumn - 1 : lineContent.length);\n                for (let offset = fromOffset; offset < toOffset; offset++) {\n                    if (strings.isHighSurrogate(lineContent.charCodeAt(offset))) {\n                        result = result + 1;\n                        offset = offset + 1;\n                    }\n                    else {\n                        result = result + 1;\n                    }\n                }\n            }\n            result += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);\n            return result;\n        }\n        return this.getValueLengthInRange(range, eol);\n    }\n    getLength() {\n        return this._pieceTree.getLength();\n    }\n    getLineCount() {\n        return this._pieceTree.getLineCount();\n    }\n    getLinesContent() {\n        return this._pieceTree.getLinesContent();\n    }\n    getLineContent(lineNumber) {\n        return this._pieceTree.getLineContent(lineNumber);\n    }\n    getLineCharCode(lineNumber, index) {\n        return this._pieceTree.getLineCharCode(lineNumber, index);\n    }\n    getLineLength(lineNumber) {\n        return this._pieceTree.getLineLength(lineNumber);\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 1;\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 2;\n    }\n    _getEndOfLine(eol) {\n        switch (eol) {\n            case 1 /* EndOfLinePreference.LF */:\n                return '\\n';\n            case 2 /* EndOfLinePreference.CRLF */:\n                return '\\r\\n';\n            case 0 /* EndOfLinePreference.TextDefined */:\n                return this.getEOL();\n            default:\n                throw new Error('Unknown EOL preference');\n        }\n    }\n    setEOL(newEOL) {\n        this._pieceTree.setEOL(newEOL);\n    }\n    applyEdits(rawOperations, recordTrimAutoWhitespace, computeUndoEdits) {\n        let mightContainRTL = this._mightContainRTL;\n        let mightContainUnusualLineTerminators = this._mightContainUnusualLineTerminators;\n        let mightContainNonBasicASCII = this._mightContainNonBasicASCII;\n        let canReduceOperations = true;\n        let operations = [];\n        for (let i = 0; i < rawOperations.length; i++) {\n            const op = rawOperations[i];\n            if (canReduceOperations && op._isTracked) {\n                canReduceOperations = false;\n            }\n            const validatedRange = op.range;\n            if (op.text) {\n                let textMightContainNonBasicASCII = true;\n                if (!mightContainNonBasicASCII) {\n                    textMightContainNonBasicASCII = !strings.isBasicASCII(op.text);\n                    mightContainNonBasicASCII = textMightContainNonBasicASCII;\n                }\n                if (!mightContainRTL && textMightContainNonBasicASCII) {\n                    // check if the new inserted text contains RTL\n                    mightContainRTL = strings.containsRTL(op.text);\n                }\n                if (!mightContainUnusualLineTerminators && textMightContainNonBasicASCII) {\n                    // check if the new inserted text contains unusual line terminators\n                    mightContainUnusualLineTerminators = strings.containsUnusualLineTerminators(op.text);\n                }\n            }\n            let validText = '';\n            let eolCount = 0;\n            let firstLineLength = 0;\n            let lastLineLength = 0;\n            if (op.text) {\n                let strEOL;\n                [eolCount, firstLineLength, lastLineLength, strEOL] = countEOL(op.text);\n                const bufferEOL = this.getEOL();\n                const expectedStrEOL = (bufferEOL === '\\r\\n' ? 2 /* StringEOL.CRLF */ : 1 /* StringEOL.LF */);\n                if (strEOL === 0 /* StringEOL.Unknown */ || strEOL === expectedStrEOL) {\n                    validText = op.text;\n                }\n                else {\n                    validText = op.text.replace(/\\r\\n|\\r|\\n/g, bufferEOL);\n                }\n            }\n            operations[i] = {\n                sortIndex: i,\n                identifier: op.identifier || null,\n                range: validatedRange,\n                rangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),\n                rangeLength: this.getValueLengthInRange(validatedRange),\n                text: validText,\n                eolCount: eolCount,\n                firstLineLength: firstLineLength,\n                lastLineLength: lastLineLength,\n                forceMoveMarkers: Boolean(op.forceMoveMarkers),\n                isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false\n            };\n        }\n        // Sort operations ascending\n        operations.sort(PieceTreeTextBuffer._sortOpsAscending);\n        let hasTouchingRanges = false;\n        for (let i = 0, count = operations.length - 1; i < count; i++) {\n            const rangeEnd = operations[i].range.getEndPosition();\n            const nextRangeStart = operations[i + 1].range.getStartPosition();\n            if (nextRangeStart.isBeforeOrEqual(rangeEnd)) {\n                if (nextRangeStart.isBefore(rangeEnd)) {\n                    // overlapping ranges\n                    throw new Error('Overlapping ranges are not allowed!');\n                }\n                hasTouchingRanges = true;\n            }\n        }\n        if (canReduceOperations) {\n            operations = this._reduceOperations(operations);\n        }\n        // Delta encode operations\n        const reverseRanges = (computeUndoEdits || recordTrimAutoWhitespace ? PieceTreeTextBuffer._getInverseEditRanges(operations) : []);\n        const newTrimAutoWhitespaceCandidates = [];\n        if (recordTrimAutoWhitespace) {\n            for (let i = 0; i < operations.length; i++) {\n                const op = operations[i];\n                const reverseRange = reverseRanges[i];\n                if (op.isAutoWhitespaceEdit && op.range.isEmpty()) {\n                    // Record already the future line numbers that might be auto whitespace removal candidates on next edit\n                    for (let lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {\n                        let currentLineContent = '';\n                        if (lineNumber === reverseRange.startLineNumber) {\n                            currentLineContent = this.getLineContent(op.range.startLineNumber);\n                            if (strings.firstNonWhitespaceIndex(currentLineContent) !== -1) {\n                                continue;\n                            }\n                        }\n                        newTrimAutoWhitespaceCandidates.push({ lineNumber: lineNumber, oldContent: currentLineContent });\n                    }\n                }\n            }\n        }\n        let reverseOperations = null;\n        if (computeUndoEdits) {\n            let reverseRangeDeltaOffset = 0;\n            reverseOperations = [];\n            for (let i = 0; i < operations.length; i++) {\n                const op = operations[i];\n                const reverseRange = reverseRanges[i];\n                const bufferText = this.getValueInRange(op.range);\n                const reverseRangeOffset = op.rangeOffset + reverseRangeDeltaOffset;\n                reverseRangeDeltaOffset += (op.text.length - bufferText.length);\n                reverseOperations[i] = {\n                    sortIndex: op.sortIndex,\n                    identifier: op.identifier,\n                    range: reverseRange,\n                    text: bufferText,\n                    textChange: new TextChange(op.rangeOffset, bufferText, reverseRangeOffset, op.text)\n                };\n            }\n            // Can only sort reverse operations when the order is not significant\n            if (!hasTouchingRanges) {\n                reverseOperations.sort((a, b) => a.sortIndex - b.sortIndex);\n            }\n        }\n        this._mightContainRTL = mightContainRTL;\n        this._mightContainUnusualLineTerminators = mightContainUnusualLineTerminators;\n        this._mightContainNonBasicASCII = mightContainNonBasicASCII;\n        const contentChanges = this._doApplyEdits(operations);\n        let trimAutoWhitespaceLineNumbers = null;\n        if (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {\n            // sort line numbers auto whitespace removal candidates for next edit descending\n            newTrimAutoWhitespaceCandidates.sort((a, b) => b.lineNumber - a.lineNumber);\n            trimAutoWhitespaceLineNumbers = [];\n            for (let i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {\n                const lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;\n                if (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {\n                    // Do not have the same line number twice\n                    continue;\n                }\n                const prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;\n                const lineContent = this.getLineContent(lineNumber);\n                if (lineContent.length === 0 || lineContent === prevContent || strings.firstNonWhitespaceIndex(lineContent) !== -1) {\n                    continue;\n                }\n                trimAutoWhitespaceLineNumbers.push(lineNumber);\n            }\n        }\n        this._onDidChangeContent.fire();\n        return new ApplyEditsResult(reverseOperations, contentChanges, trimAutoWhitespaceLineNumbers);\n    }\n    /**\n     * Transform operations such that they represent the same logic edit,\n     * but that they also do not cause OOM crashes.\n     */\n    _reduceOperations(operations) {\n        if (operations.length < 1000) {\n            // We know from empirical testing that a thousand edits work fine regardless of their shape.\n            return operations;\n        }\n        // At one point, due to how events are emitted and how each operation is handled,\n        // some operations can trigger a high amount of temporary string allocations,\n        // that will immediately get edited again.\n        // e.g. a formatter inserting ridiculous ammounts of \\n on a model with a single line\n        // Therefore, the strategy is to collapse all the operations into a huge single edit operation\n        return [this._toSingleEditOperation(operations)];\n    }\n    _toSingleEditOperation(operations) {\n        let forceMoveMarkers = false;\n        const firstEditRange = operations[0].range;\n        const lastEditRange = operations[operations.length - 1].range;\n        const entireEditRange = new Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn);\n        let lastEndLineNumber = firstEditRange.startLineNumber;\n        let lastEndColumn = firstEditRange.startColumn;\n        const result = [];\n        for (let i = 0, len = operations.length; i < len; i++) {\n            const operation = operations[i];\n            const range = operation.range;\n            forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;\n            // (1) -- Push old text\n            result.push(this.getValueInRange(new Range(lastEndLineNumber, lastEndColumn, range.startLineNumber, range.startColumn)));\n            // (2) -- Push new text\n            if (operation.text.length > 0) {\n                result.push(operation.text);\n            }\n            lastEndLineNumber = range.endLineNumber;\n            lastEndColumn = range.endColumn;\n        }\n        const text = result.join('');\n        const [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n        return {\n            sortIndex: 0,\n            identifier: operations[0].identifier,\n            range: entireEditRange,\n            rangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),\n            rangeLength: this.getValueLengthInRange(entireEditRange, 0 /* EndOfLinePreference.TextDefined */),\n            text: text,\n            eolCount: eolCount,\n            firstLineLength: firstLineLength,\n            lastLineLength: lastLineLength,\n            forceMoveMarkers: forceMoveMarkers,\n            isAutoWhitespaceEdit: false\n        };\n    }\n    _doApplyEdits(operations) {\n        operations.sort(PieceTreeTextBuffer._sortOpsDescending);\n        const contentChanges = [];\n        // operations are from bottom to top\n        for (let i = 0; i < operations.length; i++) {\n            const op = operations[i];\n            const startLineNumber = op.range.startLineNumber;\n            const startColumn = op.range.startColumn;\n            const endLineNumber = op.range.endLineNumber;\n            const endColumn = op.range.endColumn;\n            if (startLineNumber === endLineNumber && startColumn === endColumn && op.text.length === 0) {\n                // no-op\n                continue;\n            }\n            if (op.text) {\n                // replacement\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n                this._pieceTree.insert(op.rangeOffset, op.text, true);\n            }\n            else {\n                // deletion\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n            }\n            const contentChangeRange = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            contentChanges.push({\n                range: contentChangeRange,\n                rangeLength: op.rangeLength,\n                text: op.text,\n                rangeOffset: op.rangeOffset,\n                forceMoveMarkers: op.forceMoveMarkers\n            });\n        }\n        return contentChanges;\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    /**\n     * Assumes `operations` are validated and sorted ascending\n     */\n    static _getInverseEditRanges(operations) {\n        const result = [];\n        let prevOpEndLineNumber = 0;\n        let prevOpEndColumn = 0;\n        let prevOp = null;\n        for (let i = 0, len = operations.length; i < len; i++) {\n            const op = operations[i];\n            let startLineNumber;\n            let startColumn;\n            if (prevOp) {\n                if (prevOp.range.endLineNumber === op.range.startLineNumber) {\n                    startLineNumber = prevOpEndLineNumber;\n                    startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);\n                }\n                else {\n                    startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);\n                    startColumn = op.range.startColumn;\n                }\n            }\n            else {\n                startLineNumber = op.range.startLineNumber;\n                startColumn = op.range.startColumn;\n            }\n            let resultRange;\n            if (op.text.length > 0) {\n                // the operation inserts something\n                const lineCount = op.eolCount + 1;\n                if (lineCount === 1) {\n                    // single line insert\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + op.firstLineLength);\n                }\n                else {\n                    // multi line insert\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, op.lastLineLength + 1);\n                }\n            }\n            else {\n                // There is nothing to insert\n                resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);\n            }\n            prevOpEndLineNumber = resultRange.endLineNumber;\n            prevOpEndColumn = resultRange.endColumn;\n            result.push(resultRange);\n            prevOp = op;\n        }\n        return result;\n    }\n    static _sortOpsAscending(a, b) {\n        const r = Range.compareRangesUsingEnds(a.range, b.range);\n        if (r === 0) {\n            return a.sortIndex - b.sortIndex;\n        }\n        return r;\n    }\n    static _sortOpsDescending(a, b) {\n        const r = Range.compareRangesUsingEnds(a.range, b.range);\n        if (r === 0) {\n            return b.sortIndex - a.sortIndex;\n        }\n        return -r;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport { StringBuffer, createLineStarts, createLineStartsFast } from './pieceTreeBase.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer.js';\nclass PieceTreeTextBufferFactory {\n    constructor(_chunks, _bom, _cr, _lf, _crlf, _containsRTL, _containsUnusualLineTerminators, _isBasicASCII, _normalizeEOL) {\n        this._chunks = _chunks;\n        this._bom = _bom;\n        this._cr = _cr;\n        this._lf = _lf;\n        this._crlf = _crlf;\n        this._containsRTL = _containsRTL;\n        this._containsUnusualLineTerminators = _containsUnusualLineTerminators;\n        this._isBasicASCII = _isBasicASCII;\n        this._normalizeEOL = _normalizeEOL;\n    }\n    _getEOL(defaultEOL) {\n        const totalEOLCount = this._cr + this._lf + this._crlf;\n        const totalCRCount = this._cr + this._crlf;\n        if (totalEOLCount === 0) {\n            // This is an empty file or a file with precisely one line\n            return (defaultEOL === 1 /* DefaultEndOfLine.LF */ ? '\\n' : '\\r\\n');\n        }\n        if (totalCRCount > totalEOLCount / 2) {\n            // More than half of the file contains \\r\\n ending lines\n            return '\\r\\n';\n        }\n        // At least one line more ends in \\n\n        return '\\n';\n    }\n    create(defaultEOL) {\n        const eol = this._getEOL(defaultEOL);\n        const chunks = this._chunks;\n        if (this._normalizeEOL &&\n            ((eol === '\\r\\n' && (this._cr > 0 || this._lf > 0))\n                || (eol === '\\n' && (this._cr > 0 || this._crlf > 0)))) {\n            // Normalize pieces\n            for (let i = 0, len = chunks.length; i < len; i++) {\n                const str = chunks[i].buffer.replace(/\\r\\n|\\r|\\n/g, eol);\n                const newLineStart = createLineStartsFast(str);\n                chunks[i] = new StringBuffer(str, newLineStart);\n            }\n        }\n        const textBuffer = new PieceTreeTextBuffer(chunks, this._bom, eol, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);\n        return { textBuffer: textBuffer, disposable: textBuffer };\n    }\n}\nexport class PieceTreeTextBufferBuilder {\n    constructor() {\n        this.chunks = [];\n        this.BOM = '';\n        this._hasPreviousChar = false;\n        this._previousChar = 0;\n        this._tmpLineStarts = [];\n        this.cr = 0;\n        this.lf = 0;\n        this.crlf = 0;\n        this.containsRTL = false;\n        this.containsUnusualLineTerminators = false;\n        this.isBasicASCII = true;\n    }\n    acceptChunk(chunk) {\n        if (chunk.length === 0) {\n            return;\n        }\n        if (this.chunks.length === 0) {\n            if (strings.startsWithUTF8BOM(chunk)) {\n                this.BOM = strings.UTF8_BOM_CHARACTER;\n                chunk = chunk.substr(1);\n            }\n        }\n        const lastChar = chunk.charCodeAt(chunk.length - 1);\n        if (lastChar === 13 /* CharCode.CarriageReturn */ || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n            // last character is \\r or a high surrogate => keep it back\n            this._acceptChunk1(chunk.substr(0, chunk.length - 1), false);\n            this._hasPreviousChar = true;\n            this._previousChar = lastChar;\n        }\n        else {\n            this._acceptChunk1(chunk, false);\n            this._hasPreviousChar = false;\n            this._previousChar = lastChar;\n        }\n    }\n    _acceptChunk1(chunk, allowEmptyStrings) {\n        if (!allowEmptyStrings && chunk.length === 0) {\n            // Nothing to do\n            return;\n        }\n        if (this._hasPreviousChar) {\n            this._acceptChunk2(String.fromCharCode(this._previousChar) + chunk);\n        }\n        else {\n            this._acceptChunk2(chunk);\n        }\n    }\n    _acceptChunk2(chunk) {\n        const lineStarts = createLineStarts(this._tmpLineStarts, chunk);\n        this.chunks.push(new StringBuffer(chunk, lineStarts.lineStarts));\n        this.cr += lineStarts.cr;\n        this.lf += lineStarts.lf;\n        this.crlf += lineStarts.crlf;\n        if (!lineStarts.isBasicASCII) {\n            // this chunk contains non basic ASCII characters\n            this.isBasicASCII = false;\n            if (!this.containsRTL) {\n                this.containsRTL = strings.containsRTL(chunk);\n            }\n            if (!this.containsUnusualLineTerminators) {\n                this.containsUnusualLineTerminators = strings.containsUnusualLineTerminators(chunk);\n            }\n        }\n    }\n    finish(normalizeEOL = true) {\n        this._finish();\n        return new PieceTreeTextBufferFactory(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.containsUnusualLineTerminators, this.isBasicASCII, normalizeEOL);\n    }\n    _finish() {\n        if (this.chunks.length === 0) {\n            this._acceptChunk1('', true);\n        }\n        if (this._hasPreviousChar) {\n            this._hasPreviousChar = false;\n            // recreate last chunk\n            const lastChunk = this.chunks[this.chunks.length - 1];\n            lastChunk.buffer += String.fromCharCode(this._previousChar);\n            const newLineStarts = createLineStartsFast(lastChunk.buffer);\n            lastChunk.lineStarts = newLineStarts;\n            if (this._previousChar === 13 /* CharCode.CarriageReturn */) {\n                this.cr++;\n            }\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { arrayInsert } from '../../../base/common/arrays.js';\n/**\n * An array that avoids being sparse by always\n * filling up unused indices with a default value.\n */\nexport class FixedArray {\n    constructor(_default) {\n        this._default = _default;\n        this._store = [];\n    }\n    get(index) {\n        if (index < this._store.length) {\n            return this._store[index];\n        }\n        return this._default;\n    }\n    set(index, value) {\n        while (index >= this._store.length) {\n            this._store[this._store.length] = this._default;\n        }\n        this._store[index] = value;\n    }\n    replace(index, oldLength, newLength) {\n        if (index >= this._store.length) {\n            return;\n        }\n        if (oldLength === 0) {\n            this.insert(index, newLength);\n            return;\n        }\n        else if (newLength === 0) {\n            this.delete(index, oldLength);\n            return;\n        }\n        const before = this._store.slice(0, index);\n        const after = this._store.slice(index + oldLength);\n        const insertArr = arrayFill(newLength, this._default);\n        this._store = before.concat(insertArr, after);\n    }\n    delete(deleteIndex, deleteCount) {\n        if (deleteCount === 0 || deleteIndex >= this._store.length) {\n            return;\n        }\n        this._store.splice(deleteIndex, deleteCount);\n    }\n    insert(insertIndex, insertCount) {\n        if (insertCount === 0 || insertIndex >= this._store.length) {\n            return;\n        }\n        const arr = [];\n        for (let i = 0; i < insertCount; i++) {\n            arr[i] = this._default;\n        }\n        this._store = arrayInsert(this._store, insertIndex, arr);\n    }\n}\nfunction arrayFill(length, value) {\n    const arr = [];\n    for (let i = 0; i < length; i++) {\n        arr[i] = value;\n    }\n    return arr;\n}\n","/**\n * Represents contiguous tokens over a contiguous range of lines.\n */\nexport class ContiguousMultilineTokens {\n    /**\n     * (Inclusive) start line number for these tokens.\n     */\n    get startLineNumber() {\n        return this._startLineNumber;\n    }\n    /**\n     * (Inclusive) end line number for these tokens.\n     */\n    get endLineNumber() {\n        return this._startLineNumber + this._tokens.length - 1;\n    }\n    constructor(startLineNumber, tokens) {\n        this._startLineNumber = startLineNumber;\n        this._tokens = tokens;\n    }\n    /**\n     * @see {@link _tokens}\n     */\n    getLineTokens(lineNumber) {\n        return this._tokens[lineNumber - this._startLineNumber];\n    }\n    appendLineTokens(lineTokens) {\n        this._tokens.push(lineTokens);\n    }\n}\n","import { ContiguousMultilineTokens } from './contiguousMultilineTokens.js';\nexport class ContiguousMultilineTokensBuilder {\n    constructor() {\n        this._tokens = [];\n    }\n    add(lineNumber, lineTokens) {\n        if (this._tokens.length > 0) {\n            const last = this._tokens[this._tokens.length - 1];\n            if (last.endLineNumber + 1 === lineNumber) {\n                // append\n                last.appendLineTokens(lineTokens);\n                return;\n            }\n        }\n        this._tokens.push(new ContiguousMultilineTokens(lineNumber, [lineTokens]));\n    }\n    finalize() {\n        return this._tokens;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { runWhenGlobalIdle } from '../../../base/common/async.js';\nimport { BugIndicatingError, onUnexpectedError } from '../../../base/common/errors.js';\nimport { setTimeout0 } from '../../../base/common/platform.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { OffsetRange } from '../core/offsetRange.js';\nimport { nullTokenizeEncoded } from '../languages/nullTokenize.js';\nimport { FixedArray } from './fixedArray.js';\nimport { ContiguousMultilineTokensBuilder } from '../tokens/contiguousMultilineTokensBuilder.js';\nimport { LineTokens } from '../tokens/lineTokens.js';\nexport class TokenizerWithStateStore {\n    constructor(lineCount, tokenizationSupport) {\n        this.tokenizationSupport = tokenizationSupport;\n        this.initialState = this.tokenizationSupport.getInitialState();\n        this.store = new TrackingTokenizationStateStore(lineCount);\n    }\n    getStartState(lineNumber) {\n        return this.store.getStartState(lineNumber, this.initialState);\n    }\n    getFirstInvalidLine() {\n        return this.store.getFirstInvalidLine(this.initialState);\n    }\n}\nexport class TokenizerWithStateStoreAndTextModel extends TokenizerWithStateStore {\n    constructor(lineCount, tokenizationSupport, _textModel, _languageIdCodec) {\n        super(lineCount, tokenizationSupport);\n        this._textModel = _textModel;\n        this._languageIdCodec = _languageIdCodec;\n    }\n    updateTokensUntilLine(builder, lineNumber) {\n        const languageId = this._textModel.getLanguageId();\n        while (true) {\n            const lineToTokenize = this.getFirstInvalidLine();\n            if (!lineToTokenize || lineToTokenize.lineNumber > lineNumber) {\n                break;\n            }\n            const text = this._textModel.getLineContent(lineToTokenize.lineNumber);\n            const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineToTokenize.startState);\n            builder.add(lineToTokenize.lineNumber, r.tokens);\n            this.store.setEndState(lineToTokenize.lineNumber, r.endState);\n        }\n    }\n    /** assumes state is up to date */\n    getTokenTypeIfInsertingCharacter(position, character) {\n        // TODO@hediet: use tokenizeLineWithEdit\n        const lineStartState = this.getStartState(position.lineNumber);\n        if (!lineStartState) {\n            return 0 /* StandardTokenType.Other */;\n        }\n        const languageId = this._textModel.getLanguageId();\n        const lineContent = this._textModel.getLineContent(position.lineNumber);\n        // Create the text as if `character` was inserted\n        const text = (lineContent.substring(0, position.column - 1)\n            + character\n            + lineContent.substring(position.column - 1));\n        const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineStartState);\n        const lineTokens = new LineTokens(r.tokens, text, this._languageIdCodec);\n        if (lineTokens.getCount() === 0) {\n            return 0 /* StandardTokenType.Other */;\n        }\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        return lineTokens.getStandardTokenType(tokenIndex);\n    }\n    /** assumes state is up to date */\n    tokenizeLineWithEdit(position, length, newText) {\n        const lineNumber = position.lineNumber;\n        const column = position.column;\n        const lineStartState = this.getStartState(lineNumber);\n        if (!lineStartState) {\n            return null;\n        }\n        const curLineContent = this._textModel.getLineContent(lineNumber);\n        const newLineContent = curLineContent.substring(0, column - 1)\n            + newText + curLineContent.substring(column - 1 + length);\n        const languageId = this._textModel.getLanguageIdAtPosition(lineNumber, 0);\n        const result = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, newLineContent, true, lineStartState);\n        const lineTokens = new LineTokens(result.tokens, newLineContent, this._languageIdCodec);\n        return lineTokens;\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        const firstInvalidLineNumber = this.store.getFirstInvalidEndStateLineNumberOrMax();\n        return (lineNumber < firstInvalidLineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        const firstInvalidLineNumber = this.store.getFirstInvalidEndStateLineNumberOrMax();\n        if (lineNumber < firstInvalidLineNumber) {\n            return true;\n        }\n        if (lineNumber === firstInvalidLineNumber\n            && this._textModel.getLineLength(lineNumber) < 2048 /* Constants.CHEAP_TOKENIZATION_LENGTH_LIMIT */) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * The result is not cached.\n     */\n    tokenizeHeuristically(builder, startLineNumber, endLineNumber) {\n        if (endLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {\n            // nothing to do\n            return { heuristicTokens: false };\n        }\n        if (startLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {\n            // tokenization has reached the viewport start...\n            this.updateTokensUntilLine(builder, endLineNumber);\n            return { heuristicTokens: false };\n        }\n        let state = this.guessStartState(startLineNumber);\n        const languageId = this._textModel.getLanguageId();\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const text = this._textModel.getLineContent(lineNumber);\n            const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, state);\n            builder.add(lineNumber, r.tokens);\n            state = r.endState;\n        }\n        return { heuristicTokens: true };\n    }\n    guessStartState(lineNumber) {\n        let nonWhitespaceColumn = this._textModel.getLineFirstNonWhitespaceColumn(lineNumber);\n        const likelyRelevantLines = [];\n        let initialState = null;\n        for (let i = lineNumber - 1; nonWhitespaceColumn > 1 && i >= 1; i--) {\n            const newNonWhitespaceIndex = this._textModel.getLineFirstNonWhitespaceColumn(i);\n            // Ignore lines full of whitespace\n            if (newNonWhitespaceIndex === 0) {\n                continue;\n            }\n            if (newNonWhitespaceIndex < nonWhitespaceColumn) {\n                likelyRelevantLines.push(this._textModel.getLineContent(i));\n                nonWhitespaceColumn = newNonWhitespaceIndex;\n                initialState = this.getStartState(i);\n                if (initialState) {\n                    break;\n                }\n            }\n        }\n        if (!initialState) {\n            initialState = this.tokenizationSupport.getInitialState();\n        }\n        likelyRelevantLines.reverse();\n        const languageId = this._textModel.getLanguageId();\n        let state = initialState;\n        for (const line of likelyRelevantLines) {\n            const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, line, false, state);\n            state = r.endState;\n        }\n        return state;\n    }\n}\n/**\n * **Invariant:**\n * If the text model is retokenized from line 1 to {@link getFirstInvalidEndStateLineNumber}() - 1,\n * then the recomputed end state for line l will be equal to {@link getEndState}(l).\n */\nexport class TrackingTokenizationStateStore {\n    constructor(lineCount) {\n        this.lineCount = lineCount;\n        this._tokenizationStateStore = new TokenizationStateStore();\n        this._invalidEndStatesLineNumbers = new RangePriorityQueueImpl();\n        this._invalidEndStatesLineNumbers.addRange(new OffsetRange(1, lineCount + 1));\n    }\n    getEndState(lineNumber) {\n        return this._tokenizationStateStore.getEndState(lineNumber);\n    }\n    /**\n     * @returns if the end state has changed.\n     */\n    setEndState(lineNumber, state) {\n        if (!state) {\n            throw new BugIndicatingError('Cannot set null/undefined state');\n        }\n        this._invalidEndStatesLineNumbers.delete(lineNumber);\n        const r = this._tokenizationStateStore.setEndState(lineNumber, state);\n        if (r && lineNumber < this.lineCount) {\n            // because the state changed, we cannot trust the next state anymore and have to invalidate it.\n            this._invalidEndStatesLineNumbers.addRange(new OffsetRange(lineNumber + 1, lineNumber + 2));\n        }\n        return r;\n    }\n    acceptChange(range, newLineCount) {\n        this.lineCount += newLineCount - range.length;\n        this._tokenizationStateStore.acceptChange(range, newLineCount);\n        this._invalidEndStatesLineNumbers.addRangeAndResize(new OffsetRange(range.startLineNumber, range.endLineNumberExclusive), newLineCount);\n    }\n    acceptChanges(changes) {\n        for (const c of changes) {\n            const [eolCount] = countEOL(c.text);\n            this.acceptChange(new LineRange(c.range.startLineNumber, c.range.endLineNumber + 1), eolCount + 1);\n        }\n    }\n    invalidateEndStateRange(range) {\n        this._invalidEndStatesLineNumbers.addRange(new OffsetRange(range.startLineNumber, range.endLineNumberExclusive));\n    }\n    getFirstInvalidEndStateLineNumber() { return this._invalidEndStatesLineNumbers.min; }\n    getFirstInvalidEndStateLineNumberOrMax() {\n        return this.getFirstInvalidEndStateLineNumber() || Number.MAX_SAFE_INTEGER;\n    }\n    allStatesValid() { return this._invalidEndStatesLineNumbers.min === null; }\n    getStartState(lineNumber, initialState) {\n        if (lineNumber === 1) {\n            return initialState;\n        }\n        return this.getEndState(lineNumber - 1);\n    }\n    getFirstInvalidLine(initialState) {\n        const lineNumber = this.getFirstInvalidEndStateLineNumber();\n        if (lineNumber === null) {\n            return null;\n        }\n        const startState = this.getStartState(lineNumber, initialState);\n        if (!startState) {\n            throw new BugIndicatingError('Start state must be defined');\n        }\n        return { lineNumber, startState };\n    }\n}\nexport class TokenizationStateStore {\n    constructor() {\n        this._lineEndStates = new FixedArray(null);\n    }\n    getEndState(lineNumber) {\n        return this._lineEndStates.get(lineNumber);\n    }\n    setEndState(lineNumber, state) {\n        const oldState = this._lineEndStates.get(lineNumber);\n        if (oldState && oldState.equals(state)) {\n            return false;\n        }\n        this._lineEndStates.set(lineNumber, state);\n        return true;\n    }\n    acceptChange(range, newLineCount) {\n        let length = range.length;\n        if (newLineCount > 0 && length > 0) {\n            // Keep the last state, even though it is unrelated.\n            // But if the new state happens to agree with this last state, then we know we can stop tokenizing.\n            length--;\n            newLineCount--;\n        }\n        this._lineEndStates.replace(range.startLineNumber, length, newLineCount);\n    }\n}\nexport class RangePriorityQueueImpl {\n    constructor() {\n        this._ranges = [];\n    }\n    get min() {\n        if (this._ranges.length === 0) {\n            return null;\n        }\n        return this._ranges[0].start;\n    }\n    delete(value) {\n        const idx = this._ranges.findIndex(r => r.contains(value));\n        if (idx !== -1) {\n            const range = this._ranges[idx];\n            if (range.start === value) {\n                if (range.endExclusive === value + 1) {\n                    this._ranges.splice(idx, 1);\n                }\n                else {\n                    this._ranges[idx] = new OffsetRange(value + 1, range.endExclusive);\n                }\n            }\n            else {\n                if (range.endExclusive === value + 1) {\n                    this._ranges[idx] = new OffsetRange(range.start, value);\n                }\n                else {\n                    this._ranges.splice(idx, 1, new OffsetRange(range.start, value), new OffsetRange(value + 1, range.endExclusive));\n                }\n            }\n        }\n    }\n    addRange(range) {\n        OffsetRange.addRange(range, this._ranges);\n    }\n    addRangeAndResize(range, newLength) {\n        let idxFirstMightBeIntersecting = 0;\n        while (!(idxFirstMightBeIntersecting >= this._ranges.length || range.start <= this._ranges[idxFirstMightBeIntersecting].endExclusive)) {\n            idxFirstMightBeIntersecting++;\n        }\n        let idxFirstIsAfter = idxFirstMightBeIntersecting;\n        while (!(idxFirstIsAfter >= this._ranges.length || range.endExclusive < this._ranges[idxFirstIsAfter].start)) {\n            idxFirstIsAfter++;\n        }\n        const delta = newLength - range.length;\n        for (let i = idxFirstIsAfter; i < this._ranges.length; i++) {\n            this._ranges[i] = this._ranges[i].delta(delta);\n        }\n        if (idxFirstMightBeIntersecting === idxFirstIsAfter) {\n            const newRange = new OffsetRange(range.start, range.start + newLength);\n            if (!newRange.isEmpty) {\n                this._ranges.splice(idxFirstMightBeIntersecting, 0, newRange);\n            }\n        }\n        else {\n            const start = Math.min(range.start, this._ranges[idxFirstMightBeIntersecting].start);\n            const endEx = Math.max(range.endExclusive, this._ranges[idxFirstIsAfter - 1].endExclusive);\n            const newRange = new OffsetRange(start, endEx + delta);\n            if (!newRange.isEmpty) {\n                this._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting, newRange);\n            }\n            else {\n                this._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting);\n            }\n        }\n    }\n    toString() {\n        return this._ranges.map(r => r.toString()).join(' + ');\n    }\n}\nfunction safeTokenize(languageIdCodec, languageId, tokenizationSupport, text, hasEOL, state) {\n    let r = null;\n    if (tokenizationSupport) {\n        try {\n            r = tokenizationSupport.tokenizeEncoded(text, hasEOL, state.clone());\n        }\n        catch (e) {\n            onUnexpectedError(e);\n        }\n    }\n    if (!r) {\n        r = nullTokenizeEncoded(languageIdCodec.encodeLanguageId(languageId), state);\n    }\n    LineTokens.convertToEndOffset(r.tokens, text.length);\n    return r;\n}\nexport class DefaultBackgroundTokenizer {\n    constructor(_tokenizerWithStateStore, _backgroundTokenStore) {\n        this._tokenizerWithStateStore = _tokenizerWithStateStore;\n        this._backgroundTokenStore = _backgroundTokenStore;\n        this._isDisposed = false;\n        this._isScheduled = false;\n    }\n    dispose() {\n        this._isDisposed = true;\n    }\n    handleChanges() {\n        this._beginBackgroundTokenization();\n    }\n    _beginBackgroundTokenization() {\n        if (this._isScheduled || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n            return;\n        }\n        this._isScheduled = true;\n        runWhenGlobalIdle((deadline) => {\n            this._isScheduled = false;\n            this._backgroundTokenizeWithDeadline(deadline);\n        });\n    }\n    /**\n     * Tokenize until the deadline occurs, but try to yield every 1-2ms.\n     */\n    _backgroundTokenizeWithDeadline(deadline) {\n        // Read the time remaining from the `deadline` immediately because it is unclear\n        // if the `deadline` object will be valid after execution leaves this function.\n        const endTime = Date.now() + deadline.timeRemaining();\n        const execute = () => {\n            if (this._isDisposed || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n                // disposed in the meantime or detached or finished\n                return;\n            }\n            this._backgroundTokenizeForAtLeast1ms();\n            if (Date.now() < endTime) {\n                // There is still time before reaching the deadline, so yield to the browser and then\n                // continue execution\n                setTimeout0(execute);\n            }\n            else {\n                // The deadline has been reached, so schedule a new idle callback if necessary\n                this._beginBackgroundTokenization();\n            }\n        };\n        execute();\n    }\n    /**\n     * Tokenize for at least 1ms.\n     */\n    _backgroundTokenizeForAtLeast1ms() {\n        const lineCount = this._tokenizerWithStateStore._textModel.getLineCount();\n        const builder = new ContiguousMultilineTokensBuilder();\n        const sw = StopWatch.create(false);\n        do {\n            if (sw.elapsed() > 1) {\n                // the comparison is intentionally > 1 and not >= 1 to ensure that\n                // a full millisecond has elapsed, given how microseconds are rounded\n                // to milliseconds\n                break;\n            }\n            const tokenizedLineNumber = this._tokenizeOneInvalidLine(builder);\n            if (tokenizedLineNumber >= lineCount) {\n                break;\n            }\n        } while (this._hasLinesToTokenize());\n        this._backgroundTokenStore.setTokens(builder.finalize());\n        this.checkFinished();\n    }\n    _hasLinesToTokenize() {\n        if (!this._tokenizerWithStateStore) {\n            return false;\n        }\n        return !this._tokenizerWithStateStore.store.allStatesValid();\n    }\n    _tokenizeOneInvalidLine(builder) {\n        const firstInvalidLine = this._tokenizerWithStateStore?.getFirstInvalidLine();\n        if (!firstInvalidLine) {\n            return this._tokenizerWithStateStore._textModel.getLineCount() + 1;\n        }\n        this._tokenizerWithStateStore.updateTokensUntilLine(builder, firstInvalidLine.lineNumber);\n        return firstInvalidLine.lineNumber;\n    }\n    checkFinished() {\n        if (this._isDisposed) {\n            return;\n        }\n        if (this._tokenizerWithStateStore.store.allStatesValid()) {\n            this._backgroundTokenStore.backgroundTokenizationFinished();\n        }\n    }\n    requestTokens(startLineNumber, endLineNumberExclusive) {\n        this._tokenizerWithStateStore.store.invalidateEndStateRange(new LineRange(startLineNumber, endLineNumberExclusive));\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { equals } from '../../../base/common/arrays.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { LineRange } from '../core/lineRange.js';\n/**\n * @internal\n */\nexport class AttachedViews {\n    constructor() {\n        this._onDidChangeVisibleRanges = new Emitter();\n        this.onDidChangeVisibleRanges = this._onDidChangeVisibleRanges.event;\n        this._views = new Set();\n    }\n    attachView() {\n        const view = new AttachedViewImpl((state) => {\n            this._onDidChangeVisibleRanges.fire({ view, state });\n        });\n        this._views.add(view);\n        return view;\n    }\n    detachView(view) {\n        this._views.delete(view);\n        this._onDidChangeVisibleRanges.fire({ view, state: undefined });\n    }\n}\nclass AttachedViewImpl {\n    constructor(handleStateChange) {\n        this.handleStateChange = handleStateChange;\n    }\n    setVisibleLines(visibleLines, stabilized) {\n        const visibleLineRanges = visibleLines.map((line) => new LineRange(line.startLineNumber, line.endLineNumber + 1));\n        this.handleStateChange({ visibleLineRanges, stabilized });\n    }\n}\nexport class AttachedViewHandler extends Disposable {\n    get lineRanges() { return this._lineRanges; }\n    constructor(_refreshTokens) {\n        super();\n        this._refreshTokens = _refreshTokens;\n        this.runner = this._register(new RunOnceScheduler(() => this.update(), 50));\n        this._computedLineRanges = [];\n        this._lineRanges = [];\n    }\n    update() {\n        if (equals(this._computedLineRanges, this._lineRanges, (a, b) => a.equals(b))) {\n            return;\n        }\n        this._computedLineRanges = this._lineRanges;\n        this._refreshTokens();\n    }\n    handleStateChange(state) {\n        this._lineRanges = state.visibleLineRanges;\n        if (state.stabilized) {\n            this.runner.cancel();\n            this.update();\n        }\n        else {\n            this.runner.schedule();\n        }\n    }\n}\nexport class AbstractTokens extends Disposable {\n    get backgroundTokenizationState() {\n        return this._backgroundTokenizationState;\n    }\n    constructor(_languageIdCodec, _textModel, getLanguageId) {\n        super();\n        this._languageIdCodec = _languageIdCodec;\n        this._textModel = _textModel;\n        this.getLanguageId = getLanguageId;\n        this._backgroundTokenizationState = 1 /* BackgroundTokenizationState.InProgress */;\n        this._onDidChangeBackgroundTokenizationState = this._register(new Emitter());\n        /** @internal, should not be exposed by the text model! */\n        this.onDidChangeBackgroundTokenizationState = this._onDidChangeBackgroundTokenizationState.event;\n        this._onDidChangeTokens = this._register(new Emitter());\n        /** @internal, should not be exposed by the text model! */\n        this.onDidChangeTokens = this._onDidChangeTokens.event;\n    }\n    tokenizeIfCheap(lineNumber) {\n        if (this.isCheapToTokenize(lineNumber)) {\n            this.forceTokenization(lineNumber);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { TreeSitterTokenizationRegistry } from '../languages.js';\nimport { LineTokens } from '../tokens/lineTokens.js';\nimport { AbstractTokens } from './tokens.js';\nexport class TreeSitterTokens extends AbstractTokens {\n    constructor(_treeSitterService, languageIdCodec, textModel, languageId) {\n        super(languageIdCodec, textModel, languageId);\n        this._treeSitterService = _treeSitterService;\n        this._tokenizationSupport = null;\n        this._initialize();\n    }\n    _initialize() {\n        const newLanguage = this.getLanguageId();\n        if (!this._tokenizationSupport || this._lastLanguageId !== newLanguage) {\n            this._lastLanguageId = newLanguage;\n            this._tokenizationSupport = TreeSitterTokenizationRegistry.get(newLanguage);\n        }\n    }\n    getLineTokens(lineNumber) {\n        const content = this._textModel.getLineContent(lineNumber);\n        if (this._tokenizationSupport) {\n            const rawTokens = this._tokenizationSupport.tokenizeEncoded(lineNumber, this._textModel);\n            if (rawTokens) {\n                return new LineTokens(rawTokens, content, this._languageIdCodec);\n            }\n        }\n        return LineTokens.createEmpty(content, this._languageIdCodec);\n    }\n    resetTokenization(fireTokenChangeEvent = true) {\n        if (fireTokenChangeEvent) {\n            this._onDidChangeTokens.fire({\n                semanticTokensApplied: false,\n                ranges: [\n                    {\n                        fromLineNumber: 1,\n                        toLineNumber: this._textModel.getLineCount(),\n                    },\n                ],\n            });\n        }\n        this._initialize();\n    }\n    handleDidChangeAttached() {\n        // TODO @alexr00 implement for background tokenization\n    }\n    handleDidChangeContent(e) {\n        if (e.isFlush) {\n            // Don't fire the event, as the view might not have got the text change event yet\n            this.resetTokenization(false);\n        }\n    }\n    forceTokenization(lineNumber) {\n        // TODO @alexr00 implement\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        // TODO @alexr00 update for background tokenization\n        return true;\n    }\n    isCheapToTokenize(lineNumber) {\n        // TODO @alexr00 update for background tokenization\n        return true;\n    }\n    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n        // TODO @alexr00 implement once we have custom parsing and don't just feed in the whole text model value\n        return 0 /* StandardTokenType.Other */;\n    }\n    tokenizeLineWithEdit(position, length, newText) {\n        // TODO @alexr00 understand what this is for and implement\n        return null;\n    }\n    get hasTokens() {\n        // TODO @alexr00 once we have a token store, implement properly\n        const hasTree = this._treeSitterService.getParseResult(this._textModel) !== undefined;\n        return hasTree;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LineTokens } from './lineTokens.js';\nexport const EMPTY_LINE_TOKENS = (new Uint32Array(0)).buffer;\nexport class ContiguousTokensEditing {\n    static deleteBeginning(lineTokens, toChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        return ContiguousTokensEditing.delete(lineTokens, 0, toChIndex);\n    }\n    static deleteEnding(lineTokens, fromChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const lineTextLength = tokens[tokens.length - 2];\n        return ContiguousTokensEditing.delete(lineTokens, fromChIndex, lineTextLength);\n    }\n    static delete(lineTokens, fromChIndex, toChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS || fromChIndex === toChIndex) {\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const tokensCount = (tokens.length >>> 1);\n        // special case: deleting everything\n        if (fromChIndex === 0 && tokens[tokens.length - 2] === toChIndex) {\n            return EMPTY_LINE_TOKENS;\n        }\n        const fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, fromChIndex);\n        const fromTokenStartOffset = (fromTokenIndex > 0 ? tokens[(fromTokenIndex - 1) << 1] : 0);\n        const fromTokenEndOffset = tokens[fromTokenIndex << 1];\n        if (toChIndex < fromTokenEndOffset) {\n            // the delete range is inside a single token\n            const delta = (toChIndex - fromChIndex);\n            for (let i = fromTokenIndex; i < tokensCount; i++) {\n                tokens[i << 1] -= delta;\n            }\n            return lineTokens;\n        }\n        let dest;\n        let lastEnd;\n        if (fromTokenStartOffset !== fromChIndex) {\n            tokens[fromTokenIndex << 1] = fromChIndex;\n            dest = ((fromTokenIndex + 1) << 1);\n            lastEnd = fromChIndex;\n        }\n        else {\n            dest = (fromTokenIndex << 1);\n            lastEnd = fromTokenStartOffset;\n        }\n        const delta = (toChIndex - fromChIndex);\n        for (let tokenIndex = fromTokenIndex + 1; tokenIndex < tokensCount; tokenIndex++) {\n            const tokenEndOffset = tokens[tokenIndex << 1] - delta;\n            if (tokenEndOffset > lastEnd) {\n                tokens[dest++] = tokenEndOffset;\n                tokens[dest++] = tokens[(tokenIndex << 1) + 1];\n                lastEnd = tokenEndOffset;\n            }\n        }\n        if (dest === tokens.length) {\n            // nothing to trim\n            return lineTokens;\n        }\n        const tmp = new Uint32Array(dest);\n        tmp.set(tokens.subarray(0, dest), 0);\n        return tmp.buffer;\n    }\n    static append(lineTokens, _otherTokens) {\n        if (_otherTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        if (lineTokens === EMPTY_LINE_TOKENS) {\n            return _otherTokens;\n        }\n        if (lineTokens === null) {\n            return lineTokens;\n        }\n        if (_otherTokens === null) {\n            // cannot determine combined line length...\n            return null;\n        }\n        const myTokens = toUint32Array(lineTokens);\n        const otherTokens = toUint32Array(_otherTokens);\n        const otherTokensCount = (otherTokens.length >>> 1);\n        const result = new Uint32Array(myTokens.length + otherTokens.length);\n        result.set(myTokens, 0);\n        let dest = myTokens.length;\n        const delta = myTokens[myTokens.length - 2];\n        for (let i = 0; i < otherTokensCount; i++) {\n            result[dest++] = otherTokens[(i << 1)] + delta;\n            result[dest++] = otherTokens[(i << 1) + 1];\n        }\n        return result.buffer;\n    }\n    static insert(lineTokens, chIndex, textLength) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            // nothing to do\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const tokensCount = (tokens.length >>> 1);\n        let fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, chIndex);\n        if (fromTokenIndex > 0) {\n            const fromTokenStartOffset = tokens[(fromTokenIndex - 1) << 1];\n            if (fromTokenStartOffset === chIndex) {\n                fromTokenIndex--;\n            }\n        }\n        for (let tokenIndex = fromTokenIndex; tokenIndex < tokensCount; tokenIndex++) {\n            tokens[tokenIndex << 1] += textLength;\n        }\n        return lineTokens;\n    }\n}\nexport function toUint32Array(arr) {\n    if (arr instanceof Uint32Array) {\n        return arr;\n    }\n    else {\n        return new Uint32Array(arr);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { Position } from '../core/position.js';\nimport { ContiguousTokensEditing, EMPTY_LINE_TOKENS, toUint32Array } from './contiguousTokensEditing.js';\nimport { LineTokens } from './lineTokens.js';\nimport { TokenMetadata } from '../encodedTokenAttributes.js';\n/**\n * Represents contiguous tokens in a text model.\n */\nexport class ContiguousTokensStore {\n    constructor(languageIdCodec) {\n        this._lineTokens = [];\n        this._len = 0;\n        this._languageIdCodec = languageIdCodec;\n    }\n    flush() {\n        this._lineTokens = [];\n        this._len = 0;\n    }\n    get hasTokens() {\n        return this._lineTokens.length > 0;\n    }\n    getTokens(topLevelLanguageId, lineIndex, lineText) {\n        let rawLineTokens = null;\n        if (lineIndex < this._len) {\n            rawLineTokens = this._lineTokens[lineIndex];\n        }\n        if (rawLineTokens !== null && rawLineTokens !== EMPTY_LINE_TOKENS) {\n            return new LineTokens(toUint32Array(rawLineTokens), lineText, this._languageIdCodec);\n        }\n        const lineTokens = new Uint32Array(2);\n        lineTokens[0] = lineText.length;\n        lineTokens[1] = getDefaultMetadata(this._languageIdCodec.encodeLanguageId(topLevelLanguageId));\n        return new LineTokens(lineTokens, lineText, this._languageIdCodec);\n    }\n    static _massageTokens(topLevelLanguageId, lineTextLength, _tokens) {\n        const tokens = _tokens ? toUint32Array(_tokens) : null;\n        if (lineTextLength === 0) {\n            let hasDifferentLanguageId = false;\n            if (tokens && tokens.length > 1) {\n                hasDifferentLanguageId = (TokenMetadata.getLanguageId(tokens[1]) !== topLevelLanguageId);\n            }\n            if (!hasDifferentLanguageId) {\n                return EMPTY_LINE_TOKENS;\n            }\n        }\n        if (!tokens || tokens.length === 0) {\n            const tokens = new Uint32Array(2);\n            tokens[0] = lineTextLength;\n            tokens[1] = getDefaultMetadata(topLevelLanguageId);\n            return tokens.buffer;\n        }\n        // Ensure the last token covers the end of the text\n        tokens[tokens.length - 2] = lineTextLength;\n        if (tokens.byteOffset === 0 && tokens.byteLength === tokens.buffer.byteLength) {\n            // Store directly the ArrayBuffer pointer to save an object\n            return tokens.buffer;\n        }\n        return tokens;\n    }\n    _ensureLine(lineIndex) {\n        while (lineIndex >= this._len) {\n            this._lineTokens[this._len] = null;\n            this._len++;\n        }\n    }\n    _deleteLines(start, deleteCount) {\n        if (deleteCount === 0) {\n            return;\n        }\n        if (start + deleteCount > this._len) {\n            deleteCount = this._len - start;\n        }\n        this._lineTokens.splice(start, deleteCount);\n        this._len -= deleteCount;\n    }\n    _insertLines(insertIndex, insertCount) {\n        if (insertCount === 0) {\n            return;\n        }\n        const lineTokens = [];\n        for (let i = 0; i < insertCount; i++) {\n            lineTokens[i] = null;\n        }\n        this._lineTokens = arrays.arrayInsert(this._lineTokens, insertIndex, lineTokens);\n        this._len += insertCount;\n    }\n    setTokens(topLevelLanguageId, lineIndex, lineTextLength, _tokens, checkEquality) {\n        const tokens = ContiguousTokensStore._massageTokens(this._languageIdCodec.encodeLanguageId(topLevelLanguageId), lineTextLength, _tokens);\n        this._ensureLine(lineIndex);\n        const oldTokens = this._lineTokens[lineIndex];\n        this._lineTokens[lineIndex] = tokens;\n        if (checkEquality) {\n            return !ContiguousTokensStore._equals(oldTokens, tokens);\n        }\n        return false;\n    }\n    static _equals(_a, _b) {\n        if (!_a || !_b) {\n            return !_a && !_b;\n        }\n        const a = toUint32Array(_a);\n        const b = toUint32Array(_b);\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (let i = 0, len = a.length; i < len; i++) {\n            if (a[i] !== b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    //#region Editing\n    acceptEdit(range, eolCount, firstLineLength) {\n        this._acceptDeleteRange(range);\n        this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength);\n    }\n    _acceptDeleteRange(range) {\n        const firstLineIndex = range.startLineNumber - 1;\n        if (firstLineIndex >= this._len) {\n            return;\n        }\n        if (range.startLineNumber === range.endLineNumber) {\n            if (range.startColumn === range.endColumn) {\n                // Nothing to delete\n                return;\n            }\n            this._lineTokens[firstLineIndex] = ContiguousTokensEditing.delete(this._lineTokens[firstLineIndex], range.startColumn - 1, range.endColumn - 1);\n            return;\n        }\n        this._lineTokens[firstLineIndex] = ContiguousTokensEditing.deleteEnding(this._lineTokens[firstLineIndex], range.startColumn - 1);\n        const lastLineIndex = range.endLineNumber - 1;\n        let lastLineTokens = null;\n        if (lastLineIndex < this._len) {\n            lastLineTokens = ContiguousTokensEditing.deleteBeginning(this._lineTokens[lastLineIndex], range.endColumn - 1);\n        }\n        // Take remaining text on last line and append it to remaining text on first line\n        this._lineTokens[firstLineIndex] = ContiguousTokensEditing.append(this._lineTokens[firstLineIndex], lastLineTokens);\n        // Delete middle lines\n        this._deleteLines(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n    }\n    _acceptInsertText(position, eolCount, firstLineLength) {\n        if (eolCount === 0 && firstLineLength === 0) {\n            // Nothing to insert\n            return;\n        }\n        const lineIndex = position.lineNumber - 1;\n        if (lineIndex >= this._len) {\n            return;\n        }\n        if (eolCount === 0) {\n            // Inserting text on one line\n            this._lineTokens[lineIndex] = ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n            return;\n        }\n        this._lineTokens[lineIndex] = ContiguousTokensEditing.deleteEnding(this._lineTokens[lineIndex], position.column - 1);\n        this._lineTokens[lineIndex] = ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n        this._insertLines(position.lineNumber, eolCount);\n    }\n    //#endregion\n    setMultilineTokens(tokens, textModel) {\n        if (tokens.length === 0) {\n            return { changes: [] };\n        }\n        const ranges = [];\n        for (let i = 0, len = tokens.length; i < len; i++) {\n            const element = tokens[i];\n            let minChangedLineNumber = 0;\n            let maxChangedLineNumber = 0;\n            let hasChange = false;\n            for (let lineNumber = element.startLineNumber; lineNumber <= element.endLineNumber; lineNumber++) {\n                if (hasChange) {\n                    this.setTokens(textModel.getLanguageId(), lineNumber - 1, textModel.getLineLength(lineNumber), element.getLineTokens(lineNumber), false);\n                    maxChangedLineNumber = lineNumber;\n                }\n                else {\n                    const lineHasChange = this.setTokens(textModel.getLanguageId(), lineNumber - 1, textModel.getLineLength(lineNumber), element.getLineTokens(lineNumber), true);\n                    if (lineHasChange) {\n                        hasChange = true;\n                        minChangedLineNumber = lineNumber;\n                        maxChangedLineNumber = lineNumber;\n                    }\n                }\n            }\n            if (hasChange) {\n                ranges.push({ fromLineNumber: minChangedLineNumber, toLineNumber: maxChangedLineNumber, });\n            }\n        }\n        return { changes: ranges };\n    }\n}\nfunction getDefaultMetadata(topLevelLanguageId) {\n    return ((topLevelLanguageId << 0 /* MetadataConsts.LANGUAGEID_OFFSET */)\n        | (0 /* StandardTokenType.Other */ << 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */)\n        | (0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n        | (1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n        | (2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */)\n        // If there is no grammar, we just take a guess and try to match brackets.\n        | (1024 /* MetadataConsts.BALANCED_BRACKETS_MASK */)) >>> 0;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { LineTokens } from './lineTokens.js';\n/**\n * Represents sparse tokens in a text model.\n */\nexport class SparseTokensStore {\n    constructor(languageIdCodec) {\n        this._pieces = [];\n        this._isComplete = false;\n        this._languageIdCodec = languageIdCodec;\n    }\n    flush() {\n        this._pieces = [];\n        this._isComplete = false;\n    }\n    isEmpty() {\n        return (this._pieces.length === 0);\n    }\n    set(pieces, isComplete) {\n        this._pieces = pieces || [];\n        this._isComplete = isComplete;\n    }\n    setPartial(_range, pieces) {\n        // console.log(`setPartial ${_range} ${pieces.map(p => p.toString()).join(', ')}`);\n        let range = _range;\n        if (pieces.length > 0) {\n            const _firstRange = pieces[0].getRange();\n            const _lastRange = pieces[pieces.length - 1].getRange();\n            if (!_firstRange || !_lastRange) {\n                return _range;\n            }\n            range = _range.plusRange(_firstRange).plusRange(_lastRange);\n        }\n        let insertPosition = null;\n        for (let i = 0, len = this._pieces.length; i < len; i++) {\n            const piece = this._pieces[i];\n            if (piece.endLineNumber < range.startLineNumber) {\n                // this piece is before the range\n                continue;\n            }\n            if (piece.startLineNumber > range.endLineNumber) {\n                // this piece is after the range, so mark the spot before this piece\n                // as a good insertion position and stop looping\n                insertPosition = insertPosition || { index: i };\n                break;\n            }\n            // this piece might intersect with the range\n            piece.removeTokens(range);\n            if (piece.isEmpty()) {\n                // remove the piece if it became empty\n                this._pieces.splice(i, 1);\n                i--;\n                len--;\n                continue;\n            }\n            if (piece.endLineNumber < range.startLineNumber) {\n                // after removal, this piece is before the range\n                continue;\n            }\n            if (piece.startLineNumber > range.endLineNumber) {\n                // after removal, this piece is after the range\n                insertPosition = insertPosition || { index: i };\n                continue;\n            }\n            // after removal, this piece contains the range\n            const [a, b] = piece.split(range);\n            if (a.isEmpty()) {\n                // this piece is actually after the range\n                insertPosition = insertPosition || { index: i };\n                continue;\n            }\n            if (b.isEmpty()) {\n                // this piece is actually before the range\n                continue;\n            }\n            this._pieces.splice(i, 1, a, b);\n            i++;\n            len++;\n            insertPosition = insertPosition || { index: i };\n        }\n        insertPosition = insertPosition || { index: this._pieces.length };\n        if (pieces.length > 0) {\n            this._pieces = arrays.arrayInsert(this._pieces, insertPosition.index, pieces);\n        }\n        // console.log(`I HAVE ${this._pieces.length} pieces`);\n        // console.log(`${this._pieces.map(p => p.toString()).join('\\n')}`);\n        return range;\n    }\n    isComplete() {\n        return this._isComplete;\n    }\n    addSparseTokens(lineNumber, aTokens) {\n        if (aTokens.getLineContent().length === 0) {\n            // Don't do anything for empty lines\n            return aTokens;\n        }\n        const pieces = this._pieces;\n        if (pieces.length === 0) {\n            return aTokens;\n        }\n        const pieceIndex = SparseTokensStore._findFirstPieceWithLine(pieces, lineNumber);\n        const bTokens = pieces[pieceIndex].getLineTokens(lineNumber);\n        if (!bTokens) {\n            return aTokens;\n        }\n        const aLen = aTokens.getCount();\n        const bLen = bTokens.getCount();\n        let aIndex = 0;\n        const result = [];\n        let resultLen = 0;\n        let lastEndOffset = 0;\n        const emitToken = (endOffset, metadata) => {\n            if (endOffset === lastEndOffset) {\n                return;\n            }\n            lastEndOffset = endOffset;\n            result[resultLen++] = endOffset;\n            result[resultLen++] = metadata;\n        };\n        for (let bIndex = 0; bIndex < bLen; bIndex++) {\n            const bStartCharacter = bTokens.getStartCharacter(bIndex);\n            const bEndCharacter = bTokens.getEndCharacter(bIndex);\n            const bMetadata = bTokens.getMetadata(bIndex);\n            const bMask = (((bMetadata & 1 /* MetadataConsts.SEMANTIC_USE_ITALIC */) ? 2048 /* MetadataConsts.ITALIC_MASK */ : 0)\n                | ((bMetadata & 2 /* MetadataConsts.SEMANTIC_USE_BOLD */) ? 4096 /* MetadataConsts.BOLD_MASK */ : 0)\n                | ((bMetadata & 4 /* MetadataConsts.SEMANTIC_USE_UNDERLINE */) ? 8192 /* MetadataConsts.UNDERLINE_MASK */ : 0)\n                | ((bMetadata & 8 /* MetadataConsts.SEMANTIC_USE_STRIKETHROUGH */) ? 16384 /* MetadataConsts.STRIKETHROUGH_MASK */ : 0)\n                | ((bMetadata & 16 /* MetadataConsts.SEMANTIC_USE_FOREGROUND */) ? 16744448 /* MetadataConsts.FOREGROUND_MASK */ : 0)\n                | ((bMetadata & 32 /* MetadataConsts.SEMANTIC_USE_BACKGROUND */) ? 4278190080 /* MetadataConsts.BACKGROUND_MASK */ : 0)) >>> 0;\n            const aMask = (~bMask) >>> 0;\n            // push any token from `a` that is before `b`\n            while (aIndex < aLen && aTokens.getEndOffset(aIndex) <= bStartCharacter) {\n                emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n                aIndex++;\n            }\n            // push the token from `a` if it intersects the token from `b`\n            if (aIndex < aLen && aTokens.getStartOffset(aIndex) < bStartCharacter) {\n                emitToken(bStartCharacter, aTokens.getMetadata(aIndex));\n            }\n            // skip any tokens from `a` that are contained inside `b`\n            while (aIndex < aLen && aTokens.getEndOffset(aIndex) < bEndCharacter) {\n                emitToken(aTokens.getEndOffset(aIndex), (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));\n                aIndex++;\n            }\n            if (aIndex < aLen) {\n                emitToken(bEndCharacter, (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));\n                if (aTokens.getEndOffset(aIndex) === bEndCharacter) {\n                    // `a` ends exactly at the same spot as `b`!\n                    aIndex++;\n                }\n            }\n            else {\n                const aMergeIndex = Math.min(Math.max(0, aIndex - 1), aLen - 1);\n                // push the token from `b`\n                emitToken(bEndCharacter, (aTokens.getMetadata(aMergeIndex) & aMask) | (bMetadata & bMask));\n            }\n        }\n        // push the remaining tokens from `a`\n        while (aIndex < aLen) {\n            emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n            aIndex++;\n        }\n        return new LineTokens(new Uint32Array(result), aTokens.getLineContent(), this._languageIdCodec);\n    }\n    static _findFirstPieceWithLine(pieces, lineNumber) {\n        let low = 0;\n        let high = pieces.length - 1;\n        while (low < high) {\n            let mid = low + Math.floor((high - low) / 2);\n            if (pieces[mid].endLineNumber < lineNumber) {\n                low = mid + 1;\n            }\n            else if (pieces[mid].startLineNumber > lineNumber) {\n                high = mid - 1;\n            }\n            else {\n                while (mid > low && pieces[mid - 1].startLineNumber <= lineNumber && lineNumber <= pieces[mid - 1].endLineNumber) {\n                    mid--;\n                }\n                return mid;\n            }\n        }\n        return low;\n    }\n    acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n        for (const piece of this._pieces) {\n            piece.acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar TokenizationTextModelPart_1;\nimport { BugIndicatingError, onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { DisposableMap, DisposableStore, MutableDisposable } from '../../../base/common/lifecycle.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { Position } from '../core/position.js';\nimport { getWordAtText } from '../core/wordHelper.js';\nimport { TokenizationRegistry, TreeSitterTokenizationRegistry } from '../languages.js';\nimport { ILanguageService } from '../languages/language.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\nimport { TextModelPart } from './textModelPart.js';\nimport { DefaultBackgroundTokenizer, TokenizerWithStateStoreAndTextModel, TrackingTokenizationStateStore } from './textModelTokens.js';\nimport { AbstractTokens, AttachedViewHandler } from './tokens.js';\nimport { TreeSitterTokens } from './treeSitterTokens.js';\nimport { ITreeSitterParserService } from '../services/treeSitterParserService.js';\nimport { ContiguousMultilineTokensBuilder } from '../tokens/contiguousMultilineTokensBuilder.js';\nimport { ContiguousTokensStore } from '../tokens/contiguousTokensStore.js';\nimport { SparseTokensStore } from '../tokens/sparseTokensStore.js';\nlet TokenizationTextModelPart = TokenizationTextModelPart_1 = class TokenizationTextModelPart extends TextModelPart {\n    constructor(_textModel, _bracketPairsTextModelPart, _languageId, _attachedViews, _languageService, _languageConfigurationService, _treeSitterService) {\n        super();\n        this._textModel = _textModel;\n        this._bracketPairsTextModelPart = _bracketPairsTextModelPart;\n        this._languageId = _languageId;\n        this._attachedViews = _attachedViews;\n        this._languageService = _languageService;\n        this._languageConfigurationService = _languageConfigurationService;\n        this._treeSitterService = _treeSitterService;\n        this._semanticTokens = new SparseTokensStore(this._languageService.languageIdCodec);\n        this._onDidChangeLanguage = this._register(new Emitter());\n        this.onDidChangeLanguage = this._onDidChangeLanguage.event;\n        this._onDidChangeLanguageConfiguration = this._register(new Emitter());\n        this.onDidChangeLanguageConfiguration = this._onDidChangeLanguageConfiguration.event;\n        this._onDidChangeTokens = this._register(new Emitter());\n        this.onDidChangeTokens = this._onDidChangeTokens.event;\n        this._tokensDisposables = this._register(new DisposableStore());\n        this._register(this._languageConfigurationService.onDidChange(e => {\n            if (e.affects(this._languageId)) {\n                this._onDidChangeLanguageConfiguration.fire({});\n            }\n        }));\n        // We just look at registry changes to determine whether to use tree sitter.\n        // This means that removing a language from the setting will not cause a switch to textmate and will require a reload.\n        // Adding a language to the setting will not need a reload, however.\n        this._register(Event.filter(TreeSitterTokenizationRegistry.onDidChange, (e) => e.changedLanguages.includes(this._languageId))(() => {\n            this.createPreferredTokenProvider();\n        }));\n        this.createPreferredTokenProvider();\n    }\n    createGrammarTokens() {\n        return this._register(new GrammarTokens(this._languageService.languageIdCodec, this._textModel, () => this._languageId, this._attachedViews));\n    }\n    createTreeSitterTokens() {\n        return this._register(new TreeSitterTokens(this._treeSitterService, this._languageService.languageIdCodec, this._textModel, () => this._languageId));\n    }\n    createTokens(useTreeSitter) {\n        const needsReset = this._tokens !== undefined;\n        this._tokens?.dispose();\n        this._tokens = useTreeSitter ? this.createTreeSitterTokens() : this.createGrammarTokens();\n        this._tokensDisposables.clear();\n        this._tokensDisposables.add(this._tokens.onDidChangeTokens(e => {\n            this._emitModelTokensChangedEvent(e);\n        }));\n        this._tokensDisposables.add(this._tokens.onDidChangeBackgroundTokenizationState(e => {\n            this._bracketPairsTextModelPart.handleDidChangeBackgroundTokenizationState();\n        }));\n        if (needsReset) {\n            // We need to reset the tokenization, as the new token provider otherwise won't have a chance to provide tokens until some action happens in the editor.\n            this._tokens.resetTokenization();\n        }\n    }\n    createPreferredTokenProvider() {\n        if (TreeSitterTokenizationRegistry.get(this._languageId)) {\n            if (!(this._tokens instanceof TreeSitterTokens)) {\n                this.createTokens(true);\n            }\n        }\n        else {\n            if (!(this._tokens instanceof GrammarTokens)) {\n                this.createTokens(false);\n            }\n        }\n    }\n    handleLanguageConfigurationServiceChange(e) {\n        if (e.affects(this._languageId)) {\n            this._onDidChangeLanguageConfiguration.fire({});\n        }\n    }\n    handleDidChangeContent(e) {\n        if (e.isFlush) {\n            this._semanticTokens.flush();\n        }\n        else if (!e.isEolChange) { // We don't have to do anything on an EOL change\n            for (const c of e.changes) {\n                const [eolCount, firstLineLength, lastLineLength] = countEOL(c.text);\n                this._semanticTokens.acceptEdit(c.range, eolCount, firstLineLength, lastLineLength, c.text.length > 0 ? c.text.charCodeAt(0) : 0 /* CharCode.Null */);\n            }\n        }\n        this._tokens.handleDidChangeContent(e);\n    }\n    handleDidChangeAttached() {\n        this._tokens.handleDidChangeAttached();\n    }\n    /**\n     * Includes grammar and semantic tokens.\n     */\n    getLineTokens(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        const syntacticTokens = this._tokens.getLineTokens(lineNumber);\n        return this._semanticTokens.addSparseTokens(lineNumber, syntacticTokens);\n    }\n    _emitModelTokensChangedEvent(e) {\n        if (!this._textModel._isDisposing()) {\n            this._bracketPairsTextModelPart.handleDidChangeTokens(e);\n            this._onDidChangeTokens.fire(e);\n        }\n    }\n    // #region Grammar Tokens\n    validateLineNumber(lineNumber) {\n        if (lineNumber < 1 || lineNumber > this._textModel.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n    }\n    get hasTokens() {\n        return this._tokens.hasTokens;\n    }\n    resetTokenization() {\n        this._tokens.resetTokenization();\n    }\n    get backgroundTokenizationState() {\n        return this._tokens.backgroundTokenizationState;\n    }\n    forceTokenization(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        this._tokens.forceTokenization(lineNumber);\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        return this._tokens.hasAccurateTokensForLine(lineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        return this._tokens.isCheapToTokenize(lineNumber);\n    }\n    tokenizeIfCheap(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        this._tokens.tokenizeIfCheap(lineNumber);\n    }\n    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n        return this._tokens.getTokenTypeIfInsertingCharacter(lineNumber, column, character);\n    }\n    tokenizeLineWithEdit(position, length, newText) {\n        return this._tokens.tokenizeLineWithEdit(position, length, newText);\n    }\n    // #endregion\n    // #region Semantic Tokens\n    setSemanticTokens(tokens, isComplete) {\n        this._semanticTokens.set(tokens, isComplete);\n        this._emitModelTokensChangedEvent({\n            semanticTokensApplied: tokens !== null,\n            ranges: [{ fromLineNumber: 1, toLineNumber: this._textModel.getLineCount() }],\n        });\n    }\n    hasCompleteSemanticTokens() {\n        return this._semanticTokens.isComplete();\n    }\n    hasSomeSemanticTokens() {\n        return !this._semanticTokens.isEmpty();\n    }\n    setPartialSemanticTokens(range, tokens) {\n        if (this.hasCompleteSemanticTokens()) {\n            return;\n        }\n        const changedRange = this._textModel.validateRange(this._semanticTokens.setPartial(range, tokens));\n        this._emitModelTokensChangedEvent({\n            semanticTokensApplied: true,\n            ranges: [\n                {\n                    fromLineNumber: changedRange.startLineNumber,\n                    toLineNumber: changedRange.endLineNumber,\n                },\n            ],\n        });\n    }\n    // #endregion\n    // #region Utility Methods\n    getWordAtPosition(_position) {\n        this.assertNotDisposed();\n        const position = this._textModel.validatePosition(_position);\n        const lineContent = this._textModel.getLineContent(position.lineNumber);\n        const lineTokens = this.getLineTokens(position.lineNumber);\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        // (1). First try checking right biased word\n        const [rbStartOffset, rbEndOffset] = TokenizationTextModelPart_1._findLanguageBoundaries(lineTokens, tokenIndex);\n        const rightBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).getWordDefinition(), lineContent.substring(rbStartOffset, rbEndOffset), rbStartOffset);\n        // Make sure the result touches the original passed in position\n        if (rightBiasedWord &&\n            rightBiasedWord.startColumn <= _position.column &&\n            _position.column <= rightBiasedWord.endColumn) {\n            return rightBiasedWord;\n        }\n        // (2). Else, if we were at a language boundary, check the left biased word\n        if (tokenIndex > 0 && rbStartOffset === position.column - 1) {\n            // edge case, where `position` sits between two tokens belonging to two different languages\n            const [lbStartOffset, lbEndOffset] = TokenizationTextModelPart_1._findLanguageBoundaries(lineTokens, tokenIndex - 1);\n            const leftBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex - 1)).getWordDefinition(), lineContent.substring(lbStartOffset, lbEndOffset), lbStartOffset);\n            // Make sure the result touches the original passed in position\n            if (leftBiasedWord &&\n                leftBiasedWord.startColumn <= _position.column &&\n                _position.column <= leftBiasedWord.endColumn) {\n                return leftBiasedWord;\n            }\n        }\n        return null;\n    }\n    getLanguageConfiguration(languageId) {\n        return this._languageConfigurationService.getLanguageConfiguration(languageId);\n    }\n    static _findLanguageBoundaries(lineTokens, tokenIndex) {\n        const languageId = lineTokens.getLanguageId(tokenIndex);\n        // go left until a different language is hit\n        let startOffset = 0;\n        for (let i = tokenIndex; i >= 0 && lineTokens.getLanguageId(i) === languageId; i--) {\n            startOffset = lineTokens.getStartOffset(i);\n        }\n        // go right until a different language is hit\n        let endOffset = lineTokens.getLineContent().length;\n        for (let i = tokenIndex, tokenCount = lineTokens.getCount(); i < tokenCount && lineTokens.getLanguageId(i) === languageId; i++) {\n            endOffset = lineTokens.getEndOffset(i);\n        }\n        return [startOffset, endOffset];\n    }\n    getWordUntilPosition(position) {\n        const wordAtPosition = this.getWordAtPosition(position);\n        if (!wordAtPosition) {\n            return { word: '', startColumn: position.column, endColumn: position.column, };\n        }\n        return {\n            word: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),\n            startColumn: wordAtPosition.startColumn,\n            endColumn: position.column,\n        };\n    }\n    // #endregion\n    // #region Language Id handling\n    getLanguageId() {\n        return this._languageId;\n    }\n    getLanguageIdAtPosition(lineNumber, column) {\n        const position = this._textModel.validatePosition(new Position(lineNumber, column));\n        const lineTokens = this.getLineTokens(position.lineNumber);\n        return lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\n    }\n    setLanguageId(languageId, source = 'api') {\n        if (this._languageId === languageId) {\n            // There's nothing to do\n            return;\n        }\n        const e = {\n            oldLanguage: this._languageId,\n            newLanguage: languageId,\n            source\n        };\n        this._languageId = languageId;\n        this._bracketPairsTextModelPart.handleDidChangeLanguage(e);\n        this._tokens.resetTokenization();\n        this.createPreferredTokenProvider();\n        this._onDidChangeLanguage.fire(e);\n        this._onDidChangeLanguageConfiguration.fire({});\n    }\n};\nTokenizationTextModelPart = TokenizationTextModelPart_1 = __decorate([\n    __param(4, ILanguageService),\n    __param(5, ILanguageConfigurationService),\n    __param(6, ITreeSitterParserService)\n], TokenizationTextModelPart);\nexport { TokenizationTextModelPart };\nclass GrammarTokens extends AbstractTokens {\n    constructor(languageIdCodec, textModel, getLanguageId, attachedViews) {\n        super(languageIdCodec, textModel, getLanguageId);\n        this._tokenizer = null;\n        this._defaultBackgroundTokenizer = null;\n        this._backgroundTokenizer = this._register(new MutableDisposable());\n        this._tokens = new ContiguousTokensStore(this._languageIdCodec);\n        this._debugBackgroundTokenizer = this._register(new MutableDisposable());\n        this._attachedViewStates = this._register(new DisposableMap());\n        this._register(TokenizationRegistry.onDidChange((e) => {\n            const languageId = this.getLanguageId();\n            if (e.changedLanguages.indexOf(languageId) === -1) {\n                return;\n            }\n            this.resetTokenization();\n        }));\n        this.resetTokenization();\n        this._register(attachedViews.onDidChangeVisibleRanges(({ view, state }) => {\n            if (state) {\n                let existing = this._attachedViewStates.get(view);\n                if (!existing) {\n                    existing = new AttachedViewHandler(() => this.refreshRanges(existing.lineRanges));\n                    this._attachedViewStates.set(view, existing);\n                }\n                existing.handleStateChange(state);\n            }\n            else {\n                this._attachedViewStates.deleteAndDispose(view);\n            }\n        }));\n    }\n    resetTokenization(fireTokenChangeEvent = true) {\n        this._tokens.flush();\n        this._debugBackgroundTokens?.flush();\n        if (this._debugBackgroundStates) {\n            this._debugBackgroundStates = new TrackingTokenizationStateStore(this._textModel.getLineCount());\n        }\n        if (fireTokenChangeEvent) {\n            this._onDidChangeTokens.fire({\n                semanticTokensApplied: false,\n                ranges: [\n                    {\n                        fromLineNumber: 1,\n                        toLineNumber: this._textModel.getLineCount(),\n                    },\n                ],\n            });\n        }\n        const initializeTokenization = () => {\n            if (this._textModel.isTooLargeForTokenization()) {\n                return [null, null];\n            }\n            const tokenizationSupport = TokenizationRegistry.get(this.getLanguageId());\n            if (!tokenizationSupport) {\n                return [null, null];\n            }\n            let initialState;\n            try {\n                initialState = tokenizationSupport.getInitialState();\n            }\n            catch (e) {\n                onUnexpectedError(e);\n                return [null, null];\n            }\n            return [tokenizationSupport, initialState];\n        };\n        const [tokenizationSupport, initialState] = initializeTokenization();\n        if (tokenizationSupport && initialState) {\n            this._tokenizer = new TokenizerWithStateStoreAndTextModel(this._textModel.getLineCount(), tokenizationSupport, this._textModel, this._languageIdCodec);\n        }\n        else {\n            this._tokenizer = null;\n        }\n        this._backgroundTokenizer.clear();\n        this._defaultBackgroundTokenizer = null;\n        if (this._tokenizer) {\n            const b = {\n                setTokens: (tokens) => {\n                    this.setTokens(tokens);\n                },\n                backgroundTokenizationFinished: () => {\n                    if (this._backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n                        // We already did a full tokenization and don't go back to progressing.\n                        return;\n                    }\n                    const newState = 2 /* BackgroundTokenizationState.Completed */;\n                    this._backgroundTokenizationState = newState;\n                    this._onDidChangeBackgroundTokenizationState.fire();\n                },\n                setEndState: (lineNumber, state) => {\n                    if (!this._tokenizer) {\n                        return;\n                    }\n                    const firstInvalidEndStateLineNumber = this._tokenizer.store.getFirstInvalidEndStateLineNumber();\n                    // Don't accept states for definitely valid states, the renderer is ahead of the worker!\n                    if (firstInvalidEndStateLineNumber !== null && lineNumber >= firstInvalidEndStateLineNumber) {\n                        this._tokenizer?.store.setEndState(lineNumber, state);\n                    }\n                },\n            };\n            if (tokenizationSupport && tokenizationSupport.createBackgroundTokenizer && !tokenizationSupport.backgroundTokenizerShouldOnlyVerifyTokens) {\n                this._backgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, b);\n            }\n            if (!this._backgroundTokenizer.value && !this._textModel.isTooLargeForTokenization()) {\n                this._backgroundTokenizer.value = this._defaultBackgroundTokenizer =\n                    new DefaultBackgroundTokenizer(this._tokenizer, b);\n                this._defaultBackgroundTokenizer.handleChanges();\n            }\n            if (tokenizationSupport?.backgroundTokenizerShouldOnlyVerifyTokens && tokenizationSupport.createBackgroundTokenizer) {\n                this._debugBackgroundTokens = new ContiguousTokensStore(this._languageIdCodec);\n                this._debugBackgroundStates = new TrackingTokenizationStateStore(this._textModel.getLineCount());\n                this._debugBackgroundTokenizer.clear();\n                this._debugBackgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, {\n                    setTokens: (tokens) => {\n                        this._debugBackgroundTokens?.setMultilineTokens(tokens, this._textModel);\n                    },\n                    backgroundTokenizationFinished() {\n                        // NO OP\n                    },\n                    setEndState: (lineNumber, state) => {\n                        this._debugBackgroundStates?.setEndState(lineNumber, state);\n                    },\n                });\n            }\n            else {\n                this._debugBackgroundTokens = undefined;\n                this._debugBackgroundStates = undefined;\n                this._debugBackgroundTokenizer.value = undefined;\n            }\n        }\n        this.refreshAllVisibleLineTokens();\n    }\n    handleDidChangeAttached() {\n        this._defaultBackgroundTokenizer?.handleChanges();\n    }\n    handleDidChangeContent(e) {\n        if (e.isFlush) {\n            // Don't fire the event, as the view might not have got the text change event yet\n            this.resetTokenization(false);\n        }\n        else if (!e.isEolChange) { // We don't have to do anything on an EOL change\n            for (const c of e.changes) {\n                const [eolCount, firstLineLength] = countEOL(c.text);\n                this._tokens.acceptEdit(c.range, eolCount, firstLineLength);\n                this._debugBackgroundTokens?.acceptEdit(c.range, eolCount, firstLineLength);\n            }\n            this._debugBackgroundStates?.acceptChanges(e.changes);\n            if (this._tokenizer) {\n                this._tokenizer.store.acceptChanges(e.changes);\n            }\n            this._defaultBackgroundTokenizer?.handleChanges();\n        }\n    }\n    setTokens(tokens) {\n        const { changes } = this._tokens.setMultilineTokens(tokens, this._textModel);\n        if (changes.length > 0) {\n            this._onDidChangeTokens.fire({ semanticTokensApplied: false, ranges: changes, });\n        }\n        return { changes: changes };\n    }\n    refreshAllVisibleLineTokens() {\n        const ranges = LineRange.joinMany([...this._attachedViewStates].map(([_, s]) => s.lineRanges));\n        this.refreshRanges(ranges);\n    }\n    refreshRanges(ranges) {\n        for (const range of ranges) {\n            this.refreshRange(range.startLineNumber, range.endLineNumberExclusive - 1);\n        }\n    }\n    refreshRange(startLineNumber, endLineNumber) {\n        if (!this._tokenizer) {\n            return;\n        }\n        startLineNumber = Math.max(1, Math.min(this._textModel.getLineCount(), startLineNumber));\n        endLineNumber = Math.min(this._textModel.getLineCount(), endLineNumber);\n        const builder = new ContiguousMultilineTokensBuilder();\n        const { heuristicTokens } = this._tokenizer.tokenizeHeuristically(builder, startLineNumber, endLineNumber);\n        const changedTokens = this.setTokens(builder.finalize());\n        if (heuristicTokens) {\n            // We overrode tokens with heuristically computed ones.\n            // Because old states might get reused (thus stopping invalidation),\n            // we have to explicitly request the tokens for the changed ranges again.\n            for (const c of changedTokens.changes) {\n                this._backgroundTokenizer.value?.requestTokens(c.fromLineNumber, c.toLineNumber + 1);\n            }\n        }\n        this._defaultBackgroundTokenizer?.checkFinished();\n    }\n    forceTokenization(lineNumber) {\n        const builder = new ContiguousMultilineTokensBuilder();\n        this._tokenizer?.updateTokensUntilLine(builder, lineNumber);\n        this.setTokens(builder.finalize());\n        this._defaultBackgroundTokenizer?.checkFinished();\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        if (!this._tokenizer) {\n            return true;\n        }\n        return this._tokenizer.hasAccurateTokensForLine(lineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        if (!this._tokenizer) {\n            return true;\n        }\n        return this._tokenizer.isCheapToTokenize(lineNumber);\n    }\n    getLineTokens(lineNumber) {\n        const lineText = this._textModel.getLineContent(lineNumber);\n        const result = this._tokens.getTokens(this._textModel.getLanguageId(), lineNumber - 1, lineText);\n        if (this._debugBackgroundTokens && this._debugBackgroundStates && this._tokenizer) {\n            if (this._debugBackgroundStates.getFirstInvalidEndStateLineNumberOrMax() > lineNumber && this._tokenizer.store.getFirstInvalidEndStateLineNumberOrMax() > lineNumber) {\n                const backgroundResult = this._debugBackgroundTokens.getTokens(this._textModel.getLanguageId(), lineNumber - 1, lineText);\n                if (!result.equals(backgroundResult) && this._debugBackgroundTokenizer.value?.reportMismatchingTokens) {\n                    this._debugBackgroundTokenizer.value.reportMismatchingTokens(lineNumber);\n                }\n            }\n        }\n        return result;\n    }\n    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n        if (!this._tokenizer) {\n            return 0 /* StandardTokenType.Other */;\n        }\n        const position = this._textModel.validatePosition(new Position(lineNumber, column));\n        this.forceTokenization(position.lineNumber);\n        return this._tokenizer.getTokenTypeIfInsertingCharacter(position, character);\n    }\n    tokenizeLineWithEdit(position, length, newText) {\n        if (!this._tokenizer) {\n            return null;\n        }\n        const validatedPosition = this._textModel.validatePosition(position);\n        this.forceTokenization(validatedPosition.lineNumber);\n        return this._tokenizer.tokenizeLineWithEdit(validatedPosition, length, newText);\n    }\n    get hasTokens() {\n        return this._tokens.hasTokens;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar TextModel_1;\nimport { ArrayQueue, pushMany } from '../../../base/common/arrays.js';\nimport { Color } from '../../../base/common/color.js';\nimport { BugIndicatingError, illegalArgument, onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, MutableDisposable, combinedDisposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { normalizeIndentation } from '../core/indentation.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../core/textModelDefaults.js';\nimport { ILanguageService } from '../languages/language.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\nimport * as model from '../model.js';\nimport { BracketPairsTextModelPart } from './bracketPairsTextModelPart/bracketPairsImpl.js';\nimport { ColorizedBracketPairsDecorationProvider } from './bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js';\nimport { EditStack } from './editStack.js';\nimport { GuidesTextModelPart } from './guidesTextModelPart.js';\nimport { guessIndentation } from './indentationGuesser.js';\nimport { IntervalNode, IntervalTree, recomputeMaxEnd } from './intervalTree.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer/pieceTreeTextBuffer.js';\nimport { PieceTreeTextBufferBuilder } from './pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js';\nimport { SearchParams, TextModelSearch } from './textModelSearch.js';\nimport { TokenizationTextModelPart } from './tokenizationTextModelPart.js';\nimport { AttachedViews } from './tokens.js';\nimport { InternalModelContentChangeEvent, LineInjectedText, ModelInjectedTextChangedEvent, ModelRawContentChangedEvent, ModelRawEOLChanged, ModelRawFlush, ModelRawLineChanged, ModelRawLinesDeleted, ModelRawLinesInserted } from '../textModelEvents.js';\nimport { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nimport { IUndoRedoService } from '../../../platform/undoRedo/common/undoRedo.js';\nexport function createTextBufferFactory(text) {\n    const builder = new PieceTreeTextBufferBuilder();\n    builder.acceptChunk(text);\n    return builder.finish();\n}\nexport function createTextBufferFactoryFromSnapshot(snapshot) {\n    const builder = new PieceTreeTextBufferBuilder();\n    let chunk;\n    while (typeof (chunk = snapshot.read()) === 'string') {\n        builder.acceptChunk(chunk);\n    }\n    return builder.finish();\n}\nexport function createTextBuffer(value, defaultEOL) {\n    let factory;\n    if (typeof value === 'string') {\n        factory = createTextBufferFactory(value);\n    }\n    else if (model.isITextSnapshot(value)) {\n        factory = createTextBufferFactoryFromSnapshot(value);\n    }\n    else {\n        factory = value;\n    }\n    return factory.create(defaultEOL);\n}\nlet MODEL_ID = 0;\nconst LIMIT_FIND_COUNT = 999;\nconst LONG_LINE_BOUNDARY = 10000;\nclass TextModelSnapshot {\n    constructor(source) {\n        this._source = source;\n        this._eos = false;\n    }\n    read() {\n        if (this._eos) {\n            return null;\n        }\n        const result = [];\n        let resultCnt = 0;\n        let resultLength = 0;\n        do {\n            const tmp = this._source.read();\n            if (tmp === null) {\n                // end-of-stream\n                this._eos = true;\n                if (resultCnt === 0) {\n                    return null;\n                }\n                else {\n                    return result.join('');\n                }\n            }\n            if (tmp.length > 0) {\n                result[resultCnt++] = tmp;\n                resultLength += tmp.length;\n            }\n            if (resultLength >= 64 * 1024) {\n                return result.join('');\n            }\n        } while (true);\n    }\n}\nconst invalidFunc = () => { throw new Error(`Invalid change accessor`); };\nlet TextModel = class TextModel extends Disposable {\n    static { TextModel_1 = this; }\n    static { this._MODEL_SYNC_LIMIT = 50 * 1024 * 1024; } // 50 MB,  // used in tests\n    static { this.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024; } // 20 MB;\n    static { this.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1000; } // 300K lines\n    static { this.LARGE_FILE_HEAP_OPERATION_THRESHOLD = 256 * 1024 * 1024; } // 256M characters, usually ~> 512MB memory usage\n    static { this.DEFAULT_CREATION_OPTIONS = {\n        isForSimpleWidget: false,\n        tabSize: EDITOR_MODEL_DEFAULTS.tabSize,\n        indentSize: EDITOR_MODEL_DEFAULTS.indentSize,\n        insertSpaces: EDITOR_MODEL_DEFAULTS.insertSpaces,\n        detectIndentation: false,\n        defaultEOL: 1 /* model.DefaultEndOfLine.LF */,\n        trimAutoWhitespace: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,\n        largeFileOptimizations: EDITOR_MODEL_DEFAULTS.largeFileOptimizations,\n        bracketPairColorizationOptions: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions,\n    }; }\n    static resolveOptions(textBuffer, options) {\n        if (options.detectIndentation) {\n            const guessedIndentation = guessIndentation(textBuffer, options.tabSize, options.insertSpaces);\n            return new model.TextModelResolvedOptions({\n                tabSize: guessedIndentation.tabSize,\n                indentSize: 'tabSize', // TODO@Alex: guess indentSize independent of tabSize\n                insertSpaces: guessedIndentation.insertSpaces,\n                trimAutoWhitespace: options.trimAutoWhitespace,\n                defaultEOL: options.defaultEOL,\n                bracketPairColorizationOptions: options.bracketPairColorizationOptions,\n            });\n        }\n        return new model.TextModelResolvedOptions(options);\n    }\n    get onDidChangeLanguage() { return this._tokenizationTextModelPart.onDidChangeLanguage; }\n    get onDidChangeLanguageConfiguration() { return this._tokenizationTextModelPart.onDidChangeLanguageConfiguration; }\n    get onDidChangeTokens() { return this._tokenizationTextModelPart.onDidChangeTokens; }\n    onDidChangeContent(listener) {\n        return this._eventEmitter.slowEvent((e) => listener(e.contentChangedEvent));\n    }\n    onDidChangeContentOrInjectedText(listener) {\n        return combinedDisposable(this._eventEmitter.fastEvent(e => listener(e)), this._onDidChangeInjectedText.event(e => listener(e)));\n    }\n    _isDisposing() { return this.__isDisposing; }\n    get tokenization() { return this._tokenizationTextModelPart; }\n    get bracketPairs() { return this._bracketPairs; }\n    get guides() { return this._guidesTextModelPart; }\n    constructor(source, languageIdOrSelection, creationOptions, associatedResource = null, _undoRedoService, _languageService, _languageConfigurationService, instantiationService) {\n        super();\n        this._undoRedoService = _undoRedoService;\n        this._languageService = _languageService;\n        this._languageConfigurationService = _languageConfigurationService;\n        this.instantiationService = instantiationService;\n        //#region Events\n        this._onWillDispose = this._register(new Emitter());\n        this.onWillDispose = this._onWillDispose.event;\n        this._onDidChangeDecorations = this._register(new DidChangeDecorationsEmitter(affectedInjectedTextLines => this.handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines)));\n        this.onDidChangeDecorations = this._onDidChangeDecorations.event;\n        this._onDidChangeOptions = this._register(new Emitter());\n        this.onDidChangeOptions = this._onDidChangeOptions.event;\n        this._onDidChangeAttached = this._register(new Emitter());\n        this.onDidChangeAttached = this._onDidChangeAttached.event;\n        this._onDidChangeInjectedText = this._register(new Emitter());\n        this._eventEmitter = this._register(new DidChangeContentEmitter());\n        this._languageSelectionListener = this._register(new MutableDisposable());\n        this._deltaDecorationCallCnt = 0;\n        this._attachedViews = new AttachedViews();\n        // Generate a new unique model id\n        MODEL_ID++;\n        this.id = '$model' + MODEL_ID;\n        this.isForSimpleWidget = creationOptions.isForSimpleWidget;\n        if (typeof associatedResource === 'undefined' || associatedResource === null) {\n            this._associatedResource = URI.parse('inmemory://model/' + MODEL_ID);\n        }\n        else {\n            this._associatedResource = associatedResource;\n        }\n        this._attachedEditorCount = 0;\n        const { textBuffer, disposable } = createTextBuffer(source, creationOptions.defaultEOL);\n        this._buffer = textBuffer;\n        this._bufferDisposable = disposable;\n        this._options = TextModel_1.resolveOptions(this._buffer, creationOptions);\n        const languageId = (typeof languageIdOrSelection === 'string' ? languageIdOrSelection : languageIdOrSelection.languageId);\n        if (typeof languageIdOrSelection !== 'string') {\n            this._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId));\n        }\n        this._bracketPairs = this._register(new BracketPairsTextModelPart(this, this._languageConfigurationService));\n        this._guidesTextModelPart = this._register(new GuidesTextModelPart(this, this._languageConfigurationService));\n        this._decorationProvider = this._register(new ColorizedBracketPairsDecorationProvider(this));\n        this._tokenizationTextModelPart = this.instantiationService.createInstance(TokenizationTextModelPart, this, this._bracketPairs, languageId, this._attachedViews);\n        const bufferLineCount = this._buffer.getLineCount();\n        const bufferTextLength = this._buffer.getValueLengthInRange(new Range(1, 1, bufferLineCount, this._buffer.getLineLength(bufferLineCount) + 1), 0 /* model.EndOfLinePreference.TextDefined */);\n        // !!! Make a decision in the ctor and permanently respect this decision !!!\n        // If a model is too large at construction time, it will never get tokenized,\n        // under no circumstances.\n        if (creationOptions.largeFileOptimizations) {\n            this._isTooLargeForTokenization = ((bufferTextLength > TextModel_1.LARGE_FILE_SIZE_THRESHOLD)\n                || (bufferLineCount > TextModel_1.LARGE_FILE_LINE_COUNT_THRESHOLD));\n            this._isTooLargeForHeapOperation = bufferTextLength > TextModel_1.LARGE_FILE_HEAP_OPERATION_THRESHOLD;\n        }\n        else {\n            this._isTooLargeForTokenization = false;\n            this._isTooLargeForHeapOperation = false;\n        }\n        this._isTooLargeForSyncing = (bufferTextLength > TextModel_1._MODEL_SYNC_LIMIT);\n        this._versionId = 1;\n        this._alternativeVersionId = 1;\n        this._initialUndoRedoSnapshot = null;\n        this._isDisposed = false;\n        this.__isDisposing = false;\n        this._instanceId = strings.singleLetterHash(MODEL_ID);\n        this._lastDecorationId = 0;\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        this._commandManager = new EditStack(this, this._undoRedoService);\n        this._isUndoing = false;\n        this._isRedoing = false;\n        this._trimAutoWhitespaceLines = null;\n        this._register(this._decorationProvider.onDidChange(() => {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._onDidChangeDecorations.fire();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }));\n        this._languageService.requestRichLanguageFeatures(languageId);\n        this._register(this._languageConfigurationService.onDidChange(e => {\n            this._bracketPairs.handleLanguageConfigurationServiceChange(e);\n            this._tokenizationTextModelPart.handleLanguageConfigurationServiceChange(e);\n        }));\n    }\n    dispose() {\n        this.__isDisposing = true;\n        this._onWillDispose.fire();\n        this._tokenizationTextModelPart.dispose();\n        this._isDisposed = true;\n        super.dispose();\n        this._bufferDisposable.dispose();\n        this.__isDisposing = false;\n        // Manually release reference to previous text buffer to avoid large leaks\n        // in case someone leaks a TextModel reference\n        const emptyDisposedTextBuffer = new PieceTreeTextBuffer([], '', '\\n', false, false, true, true);\n        emptyDisposedTextBuffer.dispose();\n        this._buffer = emptyDisposedTextBuffer;\n        this._bufferDisposable = Disposable.None;\n    }\n    _assertNotDisposed() {\n        if (this._isDisposed) {\n            throw new BugIndicatingError('Model is disposed!');\n        }\n    }\n    _emitContentChangedEvent(rawChange, change) {\n        if (this.__isDisposing) {\n            // Do not confuse listeners by emitting any event after disposing\n            return;\n        }\n        this._tokenizationTextModelPart.handleDidChangeContent(change);\n        this._bracketPairs.handleDidChangeContent(change);\n        this._eventEmitter.fire(new InternalModelContentChangeEvent(rawChange, change));\n    }\n    setValue(value) {\n        this._assertNotDisposed();\n        if (value === null || value === undefined) {\n            throw illegalArgument();\n        }\n        const { textBuffer, disposable } = createTextBuffer(value, this._options.defaultEOL);\n        this._setValueFromTextBuffer(textBuffer, disposable);\n    }\n    _createContentChanged2(range, rangeOffset, rangeLength, text, isUndoing, isRedoing, isFlush, isEolChange) {\n        return {\n            changes: [{\n                    range: range,\n                    rangeOffset: rangeOffset,\n                    rangeLength: rangeLength,\n                    text: text,\n                }],\n            eol: this._buffer.getEOL(),\n            isEolChange: isEolChange,\n            versionId: this.getVersionId(),\n            isUndoing: isUndoing,\n            isRedoing: isRedoing,\n            isFlush: isFlush\n        };\n    }\n    _setValueFromTextBuffer(textBuffer, textBufferDisposable) {\n        this._assertNotDisposed();\n        const oldFullModelRange = this.getFullModelRange();\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        const endLineNumber = this.getLineCount();\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        this._buffer = textBuffer;\n        this._bufferDisposable.dispose();\n        this._bufferDisposable = textBufferDisposable;\n        this._increaseVersionId();\n        // Destroy all my decorations\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        // Destroy my edit history and settings\n        this._commandManager.clear();\n        this._trimAutoWhitespaceLines = null;\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\n            new ModelRawFlush()\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, true, false));\n    }\n    setEOL(eol) {\n        this._assertNotDisposed();\n        const newEOL = (eol === 1 /* model.EndOfLineSequence.CRLF */ ? '\\r\\n' : '\\n');\n        if (this._buffer.getEOL() === newEOL) {\n            // Nothing to do\n            return;\n        }\n        const oldFullModelRange = this.getFullModelRange();\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        const endLineNumber = this.getLineCount();\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        this._onBeforeEOLChange();\n        this._buffer.setEOL(newEOL);\n        this._increaseVersionId();\n        this._onAfterEOLChange();\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\n            new ModelRawEOLChanged()\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, false, true));\n    }\n    _onBeforeEOLChange() {\n        // Ensure all decorations get their `range` set.\n        this._decorationsTree.ensureAllNodesHaveRanges(this);\n    }\n    _onAfterEOLChange() {\n        // Transform back `range` to offsets\n        const versionId = this.getVersionId();\n        const allDecorations = this._decorationsTree.collectNodesPostOrder();\n        for (let i = 0, len = allDecorations.length; i < len; i++) {\n            const node = allDecorations[i];\n            const range = node.range; // the range is defined due to `_onBeforeEOLChange`\n            const delta = node.cachedAbsoluteStart - node.start;\n            const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n            const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n            node.cachedAbsoluteStart = startOffset;\n            node.cachedAbsoluteEnd = endOffset;\n            node.cachedVersionId = versionId;\n            node.start = startOffset - delta;\n            node.end = endOffset - delta;\n            recomputeMaxEnd(node);\n        }\n    }\n    onBeforeAttached() {\n        this._attachedEditorCount++;\n        if (this._attachedEditorCount === 1) {\n            this._tokenizationTextModelPart.handleDidChangeAttached();\n            this._onDidChangeAttached.fire(undefined);\n        }\n        return this._attachedViews.attachView();\n    }\n    onBeforeDetached(view) {\n        this._attachedEditorCount--;\n        if (this._attachedEditorCount === 0) {\n            this._tokenizationTextModelPart.handleDidChangeAttached();\n            this._onDidChangeAttached.fire(undefined);\n        }\n        this._attachedViews.detachView(view);\n    }\n    isAttachedToEditor() {\n        return this._attachedEditorCount > 0;\n    }\n    getAttachedEditorCount() {\n        return this._attachedEditorCount;\n    }\n    isTooLargeForSyncing() {\n        return this._isTooLargeForSyncing;\n    }\n    isTooLargeForTokenization() {\n        return this._isTooLargeForTokenization;\n    }\n    isTooLargeForHeapOperation() {\n        return this._isTooLargeForHeapOperation;\n    }\n    isDisposed() {\n        return this._isDisposed;\n    }\n    isDominatedByLongLines() {\n        this._assertNotDisposed();\n        if (this.isTooLargeForTokenization()) {\n            // Cannot word wrap huge files anyways, so it doesn't really matter\n            return false;\n        }\n        let smallLineCharCount = 0;\n        let longLineCharCount = 0;\n        const lineCount = this._buffer.getLineCount();\n        for (let lineNumber = 1; lineNumber <= lineCount; lineNumber++) {\n            const lineLength = this._buffer.getLineLength(lineNumber);\n            if (lineLength >= LONG_LINE_BOUNDARY) {\n                longLineCharCount += lineLength;\n            }\n            else {\n                smallLineCharCount += lineLength;\n            }\n        }\n        return (longLineCharCount > smallLineCharCount);\n    }\n    get uri() {\n        return this._associatedResource;\n    }\n    //#region Options\n    getOptions() {\n        this._assertNotDisposed();\n        return this._options;\n    }\n    getFormattingOptions() {\n        return {\n            tabSize: this._options.indentSize,\n            insertSpaces: this._options.insertSpaces\n        };\n    }\n    updateOptions(_newOpts) {\n        this._assertNotDisposed();\n        const tabSize = (typeof _newOpts.tabSize !== 'undefined') ? _newOpts.tabSize : this._options.tabSize;\n        const indentSize = (typeof _newOpts.indentSize !== 'undefined') ? _newOpts.indentSize : this._options.originalIndentSize;\n        const insertSpaces = (typeof _newOpts.insertSpaces !== 'undefined') ? _newOpts.insertSpaces : this._options.insertSpaces;\n        const trimAutoWhitespace = (typeof _newOpts.trimAutoWhitespace !== 'undefined') ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;\n        const bracketPairColorizationOptions = (typeof _newOpts.bracketColorizationOptions !== 'undefined') ? _newOpts.bracketColorizationOptions : this._options.bracketPairColorizationOptions;\n        const newOpts = new model.TextModelResolvedOptions({\n            tabSize: tabSize,\n            indentSize: indentSize,\n            insertSpaces: insertSpaces,\n            defaultEOL: this._options.defaultEOL,\n            trimAutoWhitespace: trimAutoWhitespace,\n            bracketPairColorizationOptions,\n        });\n        if (this._options.equals(newOpts)) {\n            return;\n        }\n        const e = this._options.createChangeEvent(newOpts);\n        this._options = newOpts;\n        this._bracketPairs.handleDidChangeOptions(e);\n        this._decorationProvider.handleDidChangeOptions(e);\n        this._onDidChangeOptions.fire(e);\n    }\n    detectIndentation(defaultInsertSpaces, defaultTabSize) {\n        this._assertNotDisposed();\n        const guessedIndentation = guessIndentation(this._buffer, defaultTabSize, defaultInsertSpaces);\n        this.updateOptions({\n            insertSpaces: guessedIndentation.insertSpaces,\n            tabSize: guessedIndentation.tabSize,\n            indentSize: guessedIndentation.tabSize, // TODO@Alex: guess indentSize independent of tabSize\n        });\n    }\n    normalizeIndentation(str) {\n        this._assertNotDisposed();\n        return normalizeIndentation(str, this._options.indentSize, this._options.insertSpaces);\n    }\n    //#endregion\n    //#region Reading\n    getVersionId() {\n        this._assertNotDisposed();\n        return this._versionId;\n    }\n    mightContainRTL() {\n        return this._buffer.mightContainRTL();\n    }\n    mightContainUnusualLineTerminators() {\n        return this._buffer.mightContainUnusualLineTerminators();\n    }\n    removeUnusualLineTerminators(selections = null) {\n        const matches = this.findMatches(strings.UNUSUAL_LINE_TERMINATORS.source, false, true, false, null, false, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */);\n        this._buffer.resetMightContainUnusualLineTerminators();\n        this.pushEditOperations(selections, matches.map(m => ({ range: m.range, text: null })), () => null);\n    }\n    mightContainNonBasicASCII() {\n        return this._buffer.mightContainNonBasicASCII();\n    }\n    getAlternativeVersionId() {\n        this._assertNotDisposed();\n        return this._alternativeVersionId;\n    }\n    getInitialUndoRedoSnapshot() {\n        this._assertNotDisposed();\n        return this._initialUndoRedoSnapshot;\n    }\n    getOffsetAt(rawPosition) {\n        this._assertNotDisposed();\n        const position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, 0 /* StringOffsetValidationType.Relaxed */);\n        return this._buffer.getOffsetAt(position.lineNumber, position.column);\n    }\n    getPositionAt(rawOffset) {\n        this._assertNotDisposed();\n        const offset = (Math.min(this._buffer.getLength(), Math.max(0, rawOffset)));\n        return this._buffer.getPositionAt(offset);\n    }\n    _increaseVersionId() {\n        this._versionId = this._versionId + 1;\n        this._alternativeVersionId = this._versionId;\n    }\n    _overwriteVersionId(versionId) {\n        this._versionId = versionId;\n    }\n    _overwriteAlternativeVersionId(newAlternativeVersionId) {\n        this._alternativeVersionId = newAlternativeVersionId;\n    }\n    _overwriteInitialUndoRedoSnapshot(newInitialUndoRedoSnapshot) {\n        this._initialUndoRedoSnapshot = newInitialUndoRedoSnapshot;\n    }\n    getValue(eol, preserveBOM = false) {\n        this._assertNotDisposed();\n        if (this.isTooLargeForHeapOperation()) {\n            throw new BugIndicatingError('Operation would exceed heap memory limits');\n        }\n        const fullModelRange = this.getFullModelRange();\n        const fullModelValue = this.getValueInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM() + fullModelValue;\n        }\n        return fullModelValue;\n    }\n    createSnapshot(preserveBOM = false) {\n        return new TextModelSnapshot(this._buffer.createSnapshot(preserveBOM));\n    }\n    getValueLength(eol, preserveBOM = false) {\n        this._assertNotDisposed();\n        const fullModelRange = this.getFullModelRange();\n        const fullModelValue = this.getValueLengthInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM().length + fullModelValue;\n        }\n        return fullModelValue;\n    }\n    getValueInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getValueInRange(this.validateRange(rawRange), eol);\n    }\n    getValueLengthInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);\n    }\n    getCharacterCountInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getCharacterCountInRange(this.validateRange(rawRange), eol);\n    }\n    getLineCount() {\n        this._assertNotDisposed();\n        return this._buffer.getLineCount();\n    }\n    getLineContent(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineContent(lineNumber);\n    }\n    getLineLength(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber);\n    }\n    getLinesContent() {\n        this._assertNotDisposed();\n        if (this.isTooLargeForHeapOperation()) {\n            throw new BugIndicatingError('Operation would exceed heap memory limits');\n        }\n        return this._buffer.getLinesContent();\n    }\n    getEOL() {\n        this._assertNotDisposed();\n        return this._buffer.getEOL();\n    }\n    getEndOfLineSequence() {\n        this._assertNotDisposed();\n        return (this._buffer.getEOL() === '\\n'\n            ? 0 /* model.EndOfLineSequence.LF */\n            : 1 /* model.EndOfLineSequence.CRLF */);\n    }\n    getLineMinColumn(lineNumber) {\n        this._assertNotDisposed();\n        return 1;\n    }\n    getLineMaxColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber) + 1;\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLastNonWhitespaceColumn(lineNumber);\n    }\n    /**\n     * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.\n     * Will try to not allocate if possible.\n     */\n    _validateRangeRelaxedNoAllocations(range) {\n        const linesCount = this._buffer.getLineCount();\n        const initialStartLineNumber = range.startLineNumber;\n        const initialStartColumn = range.startColumn;\n        let startLineNumber = Math.floor((typeof initialStartLineNumber === 'number' && !isNaN(initialStartLineNumber)) ? initialStartLineNumber : 1);\n        let startColumn = Math.floor((typeof initialStartColumn === 'number' && !isNaN(initialStartColumn)) ? initialStartColumn : 1);\n        if (startLineNumber < 1) {\n            startLineNumber = 1;\n            startColumn = 1;\n        }\n        else if (startLineNumber > linesCount) {\n            startLineNumber = linesCount;\n            startColumn = this.getLineMaxColumn(startLineNumber);\n        }\n        else {\n            if (startColumn <= 1) {\n                startColumn = 1;\n            }\n            else {\n                const maxColumn = this.getLineMaxColumn(startLineNumber);\n                if (startColumn >= maxColumn) {\n                    startColumn = maxColumn;\n                }\n            }\n        }\n        const initialEndLineNumber = range.endLineNumber;\n        const initialEndColumn = range.endColumn;\n        let endLineNumber = Math.floor((typeof initialEndLineNumber === 'number' && !isNaN(initialEndLineNumber)) ? initialEndLineNumber : 1);\n        let endColumn = Math.floor((typeof initialEndColumn === 'number' && !isNaN(initialEndColumn)) ? initialEndColumn : 1);\n        if (endLineNumber < 1) {\n            endLineNumber = 1;\n            endColumn = 1;\n        }\n        else if (endLineNumber > linesCount) {\n            endLineNumber = linesCount;\n            endColumn = this.getLineMaxColumn(endLineNumber);\n        }\n        else {\n            if (endColumn <= 1) {\n                endColumn = 1;\n            }\n            else {\n                const maxColumn = this.getLineMaxColumn(endLineNumber);\n                if (endColumn >= maxColumn) {\n                    endColumn = maxColumn;\n                }\n            }\n        }\n        if (initialStartLineNumber === startLineNumber\n            && initialStartColumn === startColumn\n            && initialEndLineNumber === endLineNumber\n            && initialEndColumn === endColumn\n            && range instanceof Range\n            && !(range instanceof Selection)) {\n            return range;\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    _isValidPosition(lineNumber, column, validationType) {\n        if (typeof lineNumber !== 'number' || typeof column !== 'number') {\n            return false;\n        }\n        if (isNaN(lineNumber) || isNaN(column)) {\n            return false;\n        }\n        if (lineNumber < 1 || column < 1) {\n            return false;\n        }\n        if ((lineNumber | 0) !== lineNumber || (column | 0) !== column) {\n            return false;\n        }\n        const lineCount = this._buffer.getLineCount();\n        if (lineNumber > lineCount) {\n            return false;\n        }\n        if (column === 1) {\n            return true;\n        }\n        const maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column > maxColumn) {\n            return false;\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            // !!At this point, column > 1\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    _validatePosition(_lineNumber, _column, validationType) {\n        const lineNumber = Math.floor((typeof _lineNumber === 'number' && !isNaN(_lineNumber)) ? _lineNumber : 1);\n        const column = Math.floor((typeof _column === 'number' && !isNaN(_column)) ? _column : 1);\n        const lineCount = this._buffer.getLineCount();\n        if (lineNumber < 1) {\n            return new Position(1, 1);\n        }\n        if (lineNumber > lineCount) {\n            return new Position(lineCount, this.getLineMaxColumn(lineCount));\n        }\n        if (column <= 1) {\n            return new Position(lineNumber, 1);\n        }\n        const maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column >= maxColumn) {\n            return new Position(lineNumber, maxColumn);\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            // If the position would end up in the middle of a high-low surrogate pair,\n            // we move it to before the pair\n            // !!At this point, column > 1\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n                return new Position(lineNumber, column - 1);\n            }\n        }\n        return new Position(lineNumber, column);\n    }\n    validatePosition(position) {\n        const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if (position instanceof Position) {\n            if (this._isValidPosition(position.lineNumber, position.column, validationType)) {\n                return position;\n            }\n        }\n        return this._validatePosition(position.lineNumber, position.column, validationType);\n    }\n    _isValidRange(range, validationType) {\n        const startLineNumber = range.startLineNumber;\n        const startColumn = range.startColumn;\n        const endLineNumber = range.endLineNumber;\n        const endColumn = range.endColumn;\n        if (!this._isValidPosition(startLineNumber, startColumn, 0 /* StringOffsetValidationType.Relaxed */)) {\n            return false;\n        }\n        if (!this._isValidPosition(endLineNumber, endColumn, 0 /* StringOffsetValidationType.Relaxed */)) {\n            return false;\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    }\n    validateRange(_range) {\n        const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if ((_range instanceof Range) && !(_range instanceof Selection)) {\n            if (this._isValidRange(_range, validationType)) {\n                return _range;\n            }\n        }\n        const start = this._validatePosition(_range.startLineNumber, _range.startColumn, 0 /* StringOffsetValidationType.Relaxed */);\n        const end = this._validatePosition(_range.endLineNumber, _range.endColumn, 0 /* StringOffsetValidationType.Relaxed */);\n        const startLineNumber = start.lineNumber;\n        const startColumn = start.column;\n        const endLineNumber = end.lineNumber;\n        const endColumn = end.column;\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            }\n            if (startLineNumber === endLineNumber && startColumn === endColumn) {\n                // do not expand a collapsed range, simply move it to a valid location\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);\n            }\n            if (startInsideSurrogatePair && endInsideSurrogatePair) {\n                // expand range at both ends\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);\n            }\n            if (startInsideSurrogatePair) {\n                // only expand range at the start\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);\n            }\n            // only expand range at the end\n            return new Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    modifyPosition(rawPosition, offset) {\n        this._assertNotDisposed();\n        const candidate = this.getOffsetAt(rawPosition) + offset;\n        return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, candidate)));\n    }\n    getFullModelRange() {\n        this._assertNotDisposed();\n        const lineCount = this.getLineCount();\n        return new Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        return this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    findMatches(searchString, rawSearchScope, isRegex, matchCase, wordSeparators, captureMatches, limitResultCount = LIMIT_FIND_COUNT) {\n        this._assertNotDisposed();\n        let searchRanges = null;\n        if (rawSearchScope !== null) {\n            if (!Array.isArray(rawSearchScope)) {\n                rawSearchScope = [rawSearchScope];\n            }\n            if (rawSearchScope.every((searchScope) => Range.isIRange(searchScope))) {\n                searchRanges = rawSearchScope.map((searchScope) => this.validateRange(searchScope));\n            }\n        }\n        if (searchRanges === null) {\n            searchRanges = [this.getFullModelRange()];\n        }\n        searchRanges = searchRanges.sort((d1, d2) => d1.startLineNumber - d2.startLineNumber || d1.startColumn - d2.startColumn);\n        const uniqueSearchRanges = [];\n        uniqueSearchRanges.push(searchRanges.reduce((prev, curr) => {\n            if (Range.areIntersecting(prev, curr)) {\n                return prev.plusRange(curr);\n            }\n            uniqueSearchRanges.push(prev);\n            return curr;\n        }));\n        let matchMapper;\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            // not regex, not multi line\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return [];\n            }\n            matchMapper = (searchRange) => this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n        }\n        else {\n            matchMapper = (searchRange) => TextModelSearch.findMatches(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchRange, captureMatches, limitResultCount);\n        }\n        return uniqueSearchRanges.map(matchMapper).reduce((arr, matches) => arr.concat(matches), []);\n    }\n    findNextMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        const searchStart = this.validatePosition(rawSearchStart);\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return null;\n            }\n            const lineCount = this.getLineCount();\n            let searchRange = new Range(searchStart.lineNumber, searchStart.column, lineCount, this.getLineMaxColumn(lineCount));\n            let ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            searchRange = new Range(1, 1, searchStart.lineNumber, this.getLineMaxColumn(searchStart.lineNumber));\n            ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            return null;\n        }\n        return TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n    findPreviousMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        const searchStart = this.validatePosition(rawSearchStart);\n        return TextModelSearch.findPreviousMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n    //#endregion\n    //#region Editing\n    pushStackElement() {\n        this._commandManager.pushStackElement();\n    }\n    popStackElement() {\n        this._commandManager.popStackElement();\n    }\n    pushEOL(eol) {\n        const currentEOL = (this.getEOL() === '\\n' ? 0 /* model.EndOfLineSequence.LF */ : 1 /* model.EndOfLineSequence.CRLF */);\n        if (currentEOL === eol) {\n            return;\n        }\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            if (this._initialUndoRedoSnapshot === null) {\n                this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n            }\n            this._commandManager.pushEOL(eol);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _validateEditOperation(rawOperation) {\n        if (rawOperation instanceof model.ValidAnnotatedEditOperation) {\n            return rawOperation;\n        }\n        return new model.ValidAnnotatedEditOperation(rawOperation.identifier || null, this.validateRange(rawOperation.range), rawOperation.text, rawOperation.forceMoveMarkers || false, rawOperation.isAutoWhitespaceEdit || false, rawOperation._isTracked || false);\n    }\n    _validateEditOperations(rawOperations) {\n        const result = [];\n        for (let i = 0, len = rawOperations.length; i < len; i++) {\n            result[i] = this._validateEditOperation(rawOperations[i]);\n        }\n        return result;\n    }\n    pushEditOperations(beforeCursorState, editOperations, cursorStateComputer, group) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            return this._pushEditOperations(beforeCursorState, this._validateEditOperations(editOperations), cursorStateComputer, group);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _pushEditOperations(beforeCursorState, editOperations, cursorStateComputer, group) {\n        if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {\n            // Go through each saved line number and insert a trim whitespace edit\n            // if it is safe to do so (no conflicts with other edits).\n            const incomingEdits = editOperations.map((op) => {\n                return {\n                    range: this.validateRange(op.range),\n                    text: op.text\n                };\n            });\n            // Sometimes, auto-formatters change ranges automatically which can cause undesired auto whitespace trimming near the cursor\n            // We'll use the following heuristic: if the edits occur near the cursor, then it's ok to trim auto whitespace\n            let editsAreNearCursors = true;\n            if (beforeCursorState) {\n                for (let i = 0, len = beforeCursorState.length; i < len; i++) {\n                    const sel = beforeCursorState[i];\n                    let foundEditNearSel = false;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        const editRange = incomingEdits[j].range;\n                        const selIsAbove = editRange.startLineNumber > sel.endLineNumber;\n                        const selIsBelow = sel.startLineNumber > editRange.endLineNumber;\n                        if (!selIsAbove && !selIsBelow) {\n                            foundEditNearSel = true;\n                            break;\n                        }\n                    }\n                    if (!foundEditNearSel) {\n                        editsAreNearCursors = false;\n                        break;\n                    }\n                }\n            }\n            if (editsAreNearCursors) {\n                for (let i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {\n                    const trimLineNumber = this._trimAutoWhitespaceLines[i];\n                    const maxLineColumn = this.getLineMaxColumn(trimLineNumber);\n                    let allowTrimLine = true;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        const editRange = incomingEdits[j].range;\n                        const editText = incomingEdits[j].text;\n                        if (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {\n                            // `trimLine` is completely outside this edit\n                            continue;\n                        }\n                        // At this point:\n                        //   editRange.startLineNumber <= trimLine <= editRange.endLineNumber\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) after `trimLine`\n                            continue;\n                        }\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === 1\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(editText.length - 1) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) before `trimLine`\n                            continue;\n                        }\n                        // Looks like we can't trim this line as it would interfere with an incoming edit\n                        allowTrimLine = false;\n                        break;\n                    }\n                    if (allowTrimLine) {\n                        const trimRange = new Range(trimLineNumber, 1, trimLineNumber, maxLineColumn);\n                        editOperations.push(new model.ValidAnnotatedEditOperation(null, trimRange, null, false, false, false));\n                    }\n                }\n            }\n            this._trimAutoWhitespaceLines = null;\n        }\n        if (this._initialUndoRedoSnapshot === null) {\n            this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n        }\n        return this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer, group);\n    }\n    _applyUndo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n        const edits = changes.map((change) => {\n            const rangeStart = this.getPositionAt(change.newPosition);\n            const rangeEnd = this.getPositionAt(change.newEnd);\n            return {\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n                text: change.oldText\n            };\n        });\n        this._applyUndoRedoEdits(edits, eol, true, false, resultingAlternativeVersionId, resultingSelection);\n    }\n    _applyRedo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n        const edits = changes.map((change) => {\n            const rangeStart = this.getPositionAt(change.oldPosition);\n            const rangeEnd = this.getPositionAt(change.oldEnd);\n            return {\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n                text: change.newText\n            };\n        });\n        this._applyUndoRedoEdits(edits, eol, false, true, resultingAlternativeVersionId, resultingSelection);\n    }\n    _applyUndoRedoEdits(edits, eol, isUndoing, isRedoing, resultingAlternativeVersionId, resultingSelection) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            this._isUndoing = isUndoing;\n            this._isRedoing = isRedoing;\n            this.applyEdits(edits, false);\n            this.setEOL(eol);\n            this._overwriteAlternativeVersionId(resultingAlternativeVersionId);\n        }\n        finally {\n            this._isUndoing = false;\n            this._isRedoing = false;\n            this._eventEmitter.endDeferredEmit(resultingSelection);\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    applyEdits(rawOperations, computeUndoEdits = false) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            const operations = this._validateEditOperations(rawOperations);\n            return this._doApplyEdits(operations, computeUndoEdits);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _doApplyEdits(rawOperations, computeUndoEdits) {\n        const oldLineCount = this._buffer.getLineCount();\n        const result = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace, computeUndoEdits);\n        const newLineCount = this._buffer.getLineCount();\n        const contentChanges = result.changes;\n        this._trimAutoWhitespaceLines = result.trimAutoWhitespaceLineNumbers;\n        if (contentChanges.length !== 0) {\n            // We do a first pass to update decorations\n            // because we want to read decorations in the second pass\n            // where we will emit content change events\n            // and we want to read the final decorations\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\n                const change = contentChanges[i];\n                this._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);\n            }\n            const rawContentChanges = [];\n            this._increaseVersionId();\n            let lineCount = oldLineCount;\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\n                const change = contentChanges[i];\n                const [eolCount] = countEOL(change.text);\n                this._onDidChangeDecorations.fire();\n                const startLineNumber = change.range.startLineNumber;\n                const endLineNumber = change.range.endLineNumber;\n                const deletingLinesCnt = endLineNumber - startLineNumber;\n                const insertingLinesCnt = eolCount;\n                const editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n                const changeLineCountDelta = (insertingLinesCnt - deletingLinesCnt);\n                const currentEditStartLineNumber = newLineCount - lineCount - changeLineCountDelta + startLineNumber;\n                const firstEditLineNumber = currentEditStartLineNumber;\n                const lastInsertedLineNumber = currentEditStartLineNumber + insertingLinesCnt;\n                const decorationsWithInjectedTextInEditedRange = this._decorationsTree.getInjectedTextInInterval(this, this.getOffsetAt(new Position(firstEditLineNumber, 1)), this.getOffsetAt(new Position(lastInsertedLineNumber, this.getLineMaxColumn(lastInsertedLineNumber))), 0);\n                const injectedTextInEditedRange = LineInjectedText.fromDecorations(decorationsWithInjectedTextInEditedRange);\n                const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n                for (let j = editingLinesCnt; j >= 0; j--) {\n                    const editLineNumber = startLineNumber + j;\n                    const currentEditLineNumber = currentEditStartLineNumber + j;\n                    injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber > currentEditLineNumber);\n                    const decorationsInCurrentLine = injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber === currentEditLineNumber);\n                    rawContentChanges.push(new ModelRawLineChanged(editLineNumber, this.getLineContent(currentEditLineNumber), decorationsInCurrentLine));\n                }\n                if (editingLinesCnt < deletingLinesCnt) {\n                    // Must delete some lines\n                    const spliceStartLineNumber = startLineNumber + editingLinesCnt;\n                    rawContentChanges.push(new ModelRawLinesDeleted(spliceStartLineNumber + 1, endLineNumber));\n                }\n                if (editingLinesCnt < insertingLinesCnt) {\n                    const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n                    // Must insert some lines\n                    const spliceLineNumber = startLineNumber + editingLinesCnt;\n                    const cnt = insertingLinesCnt - editingLinesCnt;\n                    const fromLineNumber = newLineCount - lineCount - cnt + spliceLineNumber + 1;\n                    const injectedTexts = [];\n                    const newLines = [];\n                    for (let i = 0; i < cnt; i++) {\n                        const lineNumber = fromLineNumber + i;\n                        newLines[i] = this.getLineContent(lineNumber);\n                        injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber < lineNumber);\n                        injectedTexts[i] = injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber === lineNumber);\n                    }\n                    rawContentChanges.push(new ModelRawLinesInserted(spliceLineNumber + 1, startLineNumber + insertingLinesCnt, newLines, injectedTexts));\n                }\n                lineCount += changeLineCountDelta;\n            }\n            this._emitContentChangedEvent(new ModelRawContentChangedEvent(rawContentChanges, this.getVersionId(), this._isUndoing, this._isRedoing), {\n                changes: contentChanges,\n                eol: this._buffer.getEOL(),\n                isEolChange: false,\n                versionId: this.getVersionId(),\n                isUndoing: this._isUndoing,\n                isRedoing: this._isRedoing,\n                isFlush: false\n            });\n        }\n        return (result.reverseEdits === null ? undefined : result.reverseEdits);\n    }\n    undo() {\n        return this._undoRedoService.undo(this.uri);\n    }\n    canUndo() {\n        return this._undoRedoService.canUndo(this.uri);\n    }\n    redo() {\n        return this._undoRedoService.redo(this.uri);\n    }\n    canRedo() {\n        return this._undoRedoService.canRedo(this.uri);\n    }\n    //#endregion\n    //#region Decorations\n    handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines) {\n        // This is called before the decoration changed event is fired.\n        if (affectedInjectedTextLines === null || affectedInjectedTextLines.size === 0) {\n            return;\n        }\n        const affectedLines = Array.from(affectedInjectedTextLines);\n        const lineChangeEvents = affectedLines.map(lineNumber => new ModelRawLineChanged(lineNumber, this.getLineContent(lineNumber), this._getInjectedTextInLine(lineNumber)));\n        this._onDidChangeInjectedText.fire(new ModelInjectedTextChangedEvent(lineChangeEvents));\n    }\n    changeDecorations(callback, ownerId = 0) {\n        this._assertNotDisposed();\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._changeDecorations(ownerId, callback);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _changeDecorations(ownerId, callback) {\n        const changeAccessor = {\n            addDecoration: (range, options) => {\n                return this._deltaDecorationsImpl(ownerId, [], [{ range: range, options: options }])[0];\n            },\n            changeDecoration: (id, newRange) => {\n                this._changeDecorationImpl(id, newRange);\n            },\n            changeDecorationOptions: (id, options) => {\n                this._changeDecorationOptionsImpl(id, _normalizeOptions(options));\n            },\n            removeDecoration: (id) => {\n                this._deltaDecorationsImpl(ownerId, [id], []);\n            },\n            deltaDecorations: (oldDecorations, newDecorations) => {\n                if (oldDecorations.length === 0 && newDecorations.length === 0) {\n                    // nothing to do\n                    return [];\n                }\n                return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n            }\n        };\n        let result = null;\n        try {\n            result = callback(changeAccessor);\n        }\n        catch (e) {\n            onUnexpectedError(e);\n        }\n        // Invalidate change accessor\n        changeAccessor.addDecoration = invalidFunc;\n        changeAccessor.changeDecoration = invalidFunc;\n        changeAccessor.changeDecorationOptions = invalidFunc;\n        changeAccessor.removeDecoration = invalidFunc;\n        changeAccessor.deltaDecorations = invalidFunc;\n        return result;\n    }\n    deltaDecorations(oldDecorations, newDecorations, ownerId = 0) {\n        this._assertNotDisposed();\n        if (!oldDecorations) {\n            oldDecorations = [];\n        }\n        if (oldDecorations.length === 0 && newDecorations.length === 0) {\n            // nothing to do\n            return [];\n        }\n        try {\n            this._deltaDecorationCallCnt++;\n            if (this._deltaDecorationCallCnt > 1) {\n                console.warn(`Invoking deltaDecorations recursively could lead to leaking decorations.`);\n                onUnexpectedError(new Error(`Invoking deltaDecorations recursively could lead to leaking decorations.`));\n            }\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n            this._deltaDecorationCallCnt--;\n        }\n    }\n    _getTrackedRange(id) {\n        return this.getDecorationRange(id);\n    }\n    _setTrackedRange(id, newRange, newStickiness) {\n        const node = (id ? this._decorations[id] : null);\n        if (!node) {\n            if (!newRange) {\n                // node doesn't exist, the request is to delete => nothing to do\n                return null;\n            }\n            // node doesn't exist, the request is to set => add the tracked range\n            return this._deltaDecorationsImpl(0, [], [{ range: newRange, options: TRACKED_RANGE_OPTIONS[newStickiness] }], true)[0];\n        }\n        if (!newRange) {\n            // node exists, the request is to delete => delete node\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n            return null;\n        }\n        // node exists, the request is to set => change the tracked range and its options\n        const range = this._validateRangeRelaxedNoAllocations(newRange);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        node.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);\n        this._decorationsTree.insert(node);\n        return node.id;\n    }\n    removeAllDecorationsWithOwnerId(ownerId) {\n        if (this._isDisposed) {\n            return;\n        }\n        const nodes = this._decorationsTree.collectNodesFromOwner(ownerId);\n        for (let i = 0, len = nodes.length; i < len; i++) {\n            const node = nodes[i];\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n        }\n    }\n    getDecorationOptions(decorationId) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        return node.options;\n    }\n    getDecorationRange(decorationId) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        return this._decorationsTree.getNodeRange(this, node);\n    }\n    getLineDecorations(lineNumber, ownerId = 0, filterOutValidation = false) {\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            return [];\n        }\n        return this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation);\n    }\n    getLinesDecorations(_startLineNumber, _endLineNumber, ownerId = 0, filterOutValidation = false, onlyMarginDecorations = false) {\n        const lineCount = this.getLineCount();\n        const startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));\n        const endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        const range = new Range(startLineNumber, 1, endLineNumber, endColumn);\n        const decorations = this._getDecorationsInRange(range, ownerId, filterOutValidation, onlyMarginDecorations);\n        pushMany(decorations, this._decorationProvider.getDecorationsInRange(range, ownerId, filterOutValidation));\n        return decorations;\n    }\n    getDecorationsInRange(range, ownerId = 0, filterOutValidation = false, onlyMinimapDecorations = false, onlyMarginDecorations = false) {\n        const validatedRange = this.validateRange(range);\n        const decorations = this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation, onlyMarginDecorations);\n        pushMany(decorations, this._decorationProvider.getDecorationsInRange(validatedRange, ownerId, filterOutValidation, onlyMinimapDecorations));\n        return decorations;\n    }\n    getOverviewRulerDecorations(ownerId = 0, filterOutValidation = false) {\n        return this._decorationsTree.getAll(this, ownerId, filterOutValidation, true, false);\n    }\n    getInjectedTextDecorations(ownerId = 0) {\n        return this._decorationsTree.getAllInjectedText(this, ownerId);\n    }\n    _getInjectedTextInLine(lineNumber) {\n        const startOffset = this._buffer.getOffsetAt(lineNumber, 1);\n        const endOffset = startOffset + this._buffer.getLineLength(lineNumber);\n        const result = this._decorationsTree.getInjectedTextInInterval(this, startOffset, endOffset, 0);\n        return LineInjectedText.fromDecorations(result).filter(t => t.lineNumber === lineNumber);\n    }\n    getAllDecorations(ownerId = 0, filterOutValidation = false) {\n        let result = this._decorationsTree.getAll(this, ownerId, filterOutValidation, false, false);\n        result = result.concat(this._decorationProvider.getAllDecorations(ownerId, filterOutValidation));\n        return result;\n    }\n    getAllMarginDecorations(ownerId = 0) {\n        return this._decorationsTree.getAll(this, ownerId, false, false, true);\n    }\n    _getDecorationsInRange(filterRange, filterOwnerId, filterOutValidation, onlyMarginDecorations) {\n        const startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);\n        const endOffset = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);\n        return this._decorationsTree.getAllInInterval(this, startOffset, endOffset, filterOwnerId, filterOutValidation, onlyMarginDecorations);\n    }\n    getRangeAt(start, end) {\n        return this._buffer.getRangeAt(start, end - start);\n    }\n    _changeDecorationImpl(decorationId, _range) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        if (node.options.after) {\n            const oldRange = this.getDecorationRange(decorationId);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.endLineNumber);\n        }\n        if (node.options.before) {\n            const oldRange = this.getDecorationRange(decorationId);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.startLineNumber);\n        }\n        const range = this._validateRangeRelaxedNoAllocations(_range);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        this._decorationsTree.insert(node);\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        if (node.options.after) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n        }\n        if (node.options.before) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n        }\n    }\n    _changeDecorationOptionsImpl(decorationId, options) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        const nodeWasInOverviewRuler = (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n        const nodeIsInOverviewRuler = (options.overviewRuler && options.overviewRuler.color ? true : false);\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        this._onDidChangeDecorations.checkAffectedAndFire(options);\n        if (node.options.after || options.after) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n        }\n        if (node.options.before || options.before) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n        }\n        const movedInOverviewRuler = nodeWasInOverviewRuler !== nodeIsInOverviewRuler;\n        const changedWhetherInjectedText = isOptionsInjectedText(options) !== isNodeInjectedText(node);\n        if (movedInOverviewRuler || changedWhetherInjectedText) {\n            this._decorationsTree.delete(node);\n            node.setOptions(options);\n            this._decorationsTree.insert(node);\n        }\n        else {\n            node.setOptions(options);\n        }\n    }\n    _deltaDecorationsImpl(ownerId, oldDecorationsIds, newDecorations, suppressEvents = false) {\n        const versionId = this.getVersionId();\n        const oldDecorationsLen = oldDecorationsIds.length;\n        let oldDecorationIndex = 0;\n        const newDecorationsLen = newDecorations.length;\n        let newDecorationIndex = 0;\n        this._onDidChangeDecorations.beginDeferredEmit();\n        try {\n            const result = new Array(newDecorationsLen);\n            while (oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen) {\n                let node = null;\n                if (oldDecorationIndex < oldDecorationsLen) {\n                    // (1) get ourselves an old node\n                    do {\n                        node = this._decorations[oldDecorationsIds[oldDecorationIndex++]];\n                    } while (!node && oldDecorationIndex < oldDecorationsLen);\n                    // (2) remove the node from the tree (if it exists)\n                    if (node) {\n                        if (node.options.after) {\n                            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n                            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n                        }\n                        if (node.options.before) {\n                            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n                            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n                        }\n                        this._decorationsTree.delete(node);\n                        if (!suppressEvents) {\n                            this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n                        }\n                    }\n                }\n                if (newDecorationIndex < newDecorationsLen) {\n                    // (3) create a new node if necessary\n                    if (!node) {\n                        const internalDecorationId = (++this._lastDecorationId);\n                        const decorationId = `${this._instanceId};${internalDecorationId}`;\n                        node = new IntervalNode(decorationId, 0, 0);\n                        this._decorations[decorationId] = node;\n                    }\n                    // (4) initialize node\n                    const newDecoration = newDecorations[newDecorationIndex];\n                    const range = this._validateRangeRelaxedNoAllocations(newDecoration.range);\n                    const options = _normalizeOptions(newDecoration.options);\n                    const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n                    const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n                    node.ownerId = ownerId;\n                    node.reset(versionId, startOffset, endOffset, range);\n                    node.setOptions(options);\n                    if (node.options.after) {\n                        this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n                    }\n                    if (node.options.before) {\n                        this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n                    }\n                    if (!suppressEvents) {\n                        this._onDidChangeDecorations.checkAffectedAndFire(options);\n                    }\n                    this._decorationsTree.insert(node);\n                    result[newDecorationIndex] = node.id;\n                    newDecorationIndex++;\n                }\n                else {\n                    if (node) {\n                        delete this._decorations[node.id];\n                    }\n                }\n            }\n            return result;\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    //#endregion\n    //#region Tokenization\n    // TODO move them to the tokenization part.\n    getLanguageId() {\n        return this.tokenization.getLanguageId();\n    }\n    setLanguage(languageIdOrSelection, source) {\n        if (typeof languageIdOrSelection === 'string') {\n            this._languageSelectionListener.clear();\n            this._setLanguage(languageIdOrSelection, source);\n        }\n        else {\n            this._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId, source));\n            this._setLanguage(languageIdOrSelection.languageId, source);\n        }\n    }\n    _setLanguage(languageId, source) {\n        this.tokenization.setLanguageId(languageId, source);\n        this._languageService.requestRichLanguageFeatures(languageId);\n    }\n    getLanguageIdAtPosition(lineNumber, column) {\n        return this.tokenization.getLanguageIdAtPosition(lineNumber, column);\n    }\n    getWordAtPosition(position) {\n        return this._tokenizationTextModelPart.getWordAtPosition(position);\n    }\n    getWordUntilPosition(position) {\n        return this._tokenizationTextModelPart.getWordUntilPosition(position);\n    }\n    //#endregion\n    normalizePosition(position, affinity) {\n        return position;\n    }\n    /**\n     * Gets the column at which indentation stops at a given line.\n     * @internal\n    */\n    getLineIndentColumn(lineNumber) {\n        // Columns start with 1.\n        return indentOfLine(this.getLineContent(lineNumber)) + 1;\n    }\n};\nTextModel = TextModel_1 = __decorate([\n    __param(4, IUndoRedoService),\n    __param(5, ILanguageService),\n    __param(6, ILanguageConfigurationService),\n    __param(7, IInstantiationService)\n], TextModel);\nexport { TextModel };\nexport function indentOfLine(line) {\n    let indent = 0;\n    for (const c of line) {\n        if (c === ' ' || c === '\\t') {\n            indent++;\n        }\n        else {\n            break;\n        }\n    }\n    return indent;\n}\n//#region Decorations\nfunction isNodeInOverviewRuler(node) {\n    return (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n}\nfunction isOptionsInjectedText(options) {\n    return !!options.after || !!options.before;\n}\nfunction isNodeInjectedText(node) {\n    return !!node.options.after || !!node.options.before;\n}\nclass DecorationsTrees {\n    constructor() {\n        this._decorationsTree0 = new IntervalTree();\n        this._decorationsTree1 = new IntervalTree();\n        this._injectedTextDecorationsTree = new IntervalTree();\n    }\n    ensureAllNodesHaveRanges(host) {\n        this.getAll(host, 0, false, false, false);\n    }\n    _ensureNodesHaveRanges(host, nodes) {\n        for (const node of nodes) {\n            if (node.range === null) {\n                node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n            }\n        }\n        return nodes;\n    }\n    getAllInInterval(host, start, end, filterOwnerId, filterOutValidation, onlyMarginDecorations) {\n        const versionId = host.getVersionId();\n        const result = this._intervalSearch(start, end, filterOwnerId, filterOutValidation, versionId, onlyMarginDecorations);\n        return this._ensureNodesHaveRanges(host, result);\n    }\n    _intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n        const r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        const r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        const r2 = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        return r0.concat(r1).concat(r2);\n    }\n    getInjectedTextInInterval(host, start, end, filterOwnerId) {\n        const versionId = host.getVersionId();\n        const result = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, false, versionId, false);\n        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n    }\n    getAllInjectedText(host, filterOwnerId) {\n        const versionId = host.getVersionId();\n        const result = this._injectedTextDecorationsTree.search(filterOwnerId, false, versionId, false);\n        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n    }\n    getAll(host, filterOwnerId, filterOutValidation, overviewRulerOnly, onlyMarginDecorations) {\n        const versionId = host.getVersionId();\n        const result = this._search(filterOwnerId, filterOutValidation, overviewRulerOnly, versionId, onlyMarginDecorations);\n        return this._ensureNodesHaveRanges(host, result);\n    }\n    _search(filterOwnerId, filterOutValidation, overviewRulerOnly, cachedVersionId, onlyMarginDecorations) {\n        if (overviewRulerOnly) {\n            return this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        }\n        else {\n            const r0 = this._decorationsTree0.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n            const r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n            const r2 = this._injectedTextDecorationsTree.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n            return r0.concat(r1).concat(r2);\n        }\n    }\n    collectNodesFromOwner(ownerId) {\n        const r0 = this._decorationsTree0.collectNodesFromOwner(ownerId);\n        const r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);\n        const r2 = this._injectedTextDecorationsTree.collectNodesFromOwner(ownerId);\n        return r0.concat(r1).concat(r2);\n    }\n    collectNodesPostOrder() {\n        const r0 = this._decorationsTree0.collectNodesPostOrder();\n        const r1 = this._decorationsTree1.collectNodesPostOrder();\n        const r2 = this._injectedTextDecorationsTree.collectNodesPostOrder();\n        return r0.concat(r1).concat(r2);\n    }\n    insert(node) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.insert(node);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.insert(node);\n        }\n        else {\n            this._decorationsTree0.insert(node);\n        }\n    }\n    delete(node) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.delete(node);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.delete(node);\n        }\n        else {\n            this._decorationsTree0.delete(node);\n        }\n    }\n    getNodeRange(host, node) {\n        const versionId = host.getVersionId();\n        if (node.cachedVersionId !== versionId) {\n            this._resolveNode(node, versionId);\n        }\n        if (node.range === null) {\n            node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n        }\n        return node.range;\n    }\n    _resolveNode(node, cachedVersionId) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.resolveNode(node, cachedVersionId);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.resolveNode(node, cachedVersionId);\n        }\n        else {\n            this._decorationsTree0.resolveNode(node, cachedVersionId);\n        }\n    }\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\n        this._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        this._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        this._injectedTextDecorationsTree.acceptReplace(offset, length, textLength, forceMoveMarkers);\n    }\n}\nfunction cleanClassName(className) {\n    return className.replace(/[^a-z0-9\\-_]/gi, ' ');\n}\nclass DecorationOptions {\n    constructor(options) {\n        this.color = options.color || '';\n        this.darkColor = options.darkColor || '';\n    }\n}\nexport class ModelDecorationOverviewRulerOptions extends DecorationOptions {\n    constructor(options) {\n        super(options);\n        this._resolvedColor = null;\n        this.position = (typeof options.position === 'number' ? options.position : model.OverviewRulerLane.Center);\n    }\n    getColor(theme) {\n        if (!this._resolvedColor) {\n            if (theme.type !== 'light' && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    }\n    invalidateCachedColor() {\n        this._resolvedColor = null;\n    }\n    _resolveColor(color, theme) {\n        if (typeof color === 'string') {\n            return color;\n        }\n        const c = color ? theme.getColor(color.id) : null;\n        if (!c) {\n            return '';\n        }\n        return c.toString();\n    }\n}\nexport class ModelDecorationGlyphMarginOptions {\n    constructor(options) {\n        this.position = options?.position ?? model.GlyphMarginLane.Center;\n        this.persistLane = options?.persistLane;\n    }\n}\nexport class ModelDecorationMinimapOptions extends DecorationOptions {\n    constructor(options) {\n        super(options);\n        this.position = options.position;\n        this.sectionHeaderStyle = options.sectionHeaderStyle ?? null;\n        this.sectionHeaderText = options.sectionHeaderText ?? null;\n    }\n    getColor(theme) {\n        if (!this._resolvedColor) {\n            if (theme.type !== 'light' && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    }\n    invalidateCachedColor() {\n        this._resolvedColor = undefined;\n    }\n    _resolveColor(color, theme) {\n        if (typeof color === 'string') {\n            return Color.fromHex(color);\n        }\n        return theme.getColor(color.id);\n    }\n}\nexport class ModelDecorationInjectedTextOptions {\n    static from(options) {\n        if (options instanceof ModelDecorationInjectedTextOptions) {\n            return options;\n        }\n        return new ModelDecorationInjectedTextOptions(options);\n    }\n    constructor(options) {\n        this.content = options.content || '';\n        this.inlineClassName = options.inlineClassName || null;\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n        this.attachedData = options.attachedData || null;\n        this.cursorStops = options.cursorStops || null;\n    }\n}\nexport class ModelDecorationOptions {\n    static register(options) {\n        return new ModelDecorationOptions(options);\n    }\n    static createDynamic(options) {\n        return new ModelDecorationOptions(options);\n    }\n    constructor(options) {\n        this.description = options.description;\n        this.blockClassName = options.blockClassName ? cleanClassName(options.blockClassName) : null;\n        this.blockDoesNotCollapse = options.blockDoesNotCollapse ?? null;\n        this.blockIsAfterEnd = options.blockIsAfterEnd ?? null;\n        this.blockPadding = options.blockPadding ?? null;\n        this.stickiness = options.stickiness || 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */;\n        this.zIndex = options.zIndex || 0;\n        this.className = options.className ? cleanClassName(options.className) : null;\n        this.shouldFillLineOnLineBreak = options.shouldFillLineOnLineBreak ?? null;\n        this.hoverMessage = options.hoverMessage || null;\n        this.glyphMarginHoverMessage = options.glyphMarginHoverMessage || null;\n        this.lineNumberHoverMessage = options.lineNumberHoverMessage || null;\n        this.isWholeLine = options.isWholeLine || false;\n        this.showIfCollapsed = options.showIfCollapsed || false;\n        this.collapseOnReplaceEdit = options.collapseOnReplaceEdit || false;\n        this.overviewRuler = options.overviewRuler ? new ModelDecorationOverviewRulerOptions(options.overviewRuler) : null;\n        this.minimap = options.minimap ? new ModelDecorationMinimapOptions(options.minimap) : null;\n        this.glyphMargin = options.glyphMarginClassName ? new ModelDecorationGlyphMarginOptions(options.glyphMargin) : null;\n        this.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : null;\n        this.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : null;\n        this.lineNumberClassName = options.lineNumberClassName ? cleanClassName(options.lineNumberClassName) : null;\n        this.linesDecorationsTooltip = options.linesDecorationsTooltip ? strings.htmlAttributeEncodeValue(options.linesDecorationsTooltip) : null;\n        this.firstLineDecorationClassName = options.firstLineDecorationClassName ? cleanClassName(options.firstLineDecorationClassName) : null;\n        this.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : null;\n        this.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : null;\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n        this.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : null;\n        this.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : null;\n        this.after = options.after ? ModelDecorationInjectedTextOptions.from(options.after) : null;\n        this.before = options.before ? ModelDecorationInjectedTextOptions.from(options.before) : null;\n        this.hideInCommentTokens = options.hideInCommentTokens ?? false;\n        this.hideInStringTokens = options.hideInStringTokens ?? false;\n    }\n}\nModelDecorationOptions.EMPTY = ModelDecorationOptions.register({ description: 'empty' });\n/**\n * The order carefully matches the values of the enum.\n */\nconst TRACKED_RANGE_OPTIONS = [\n    ModelDecorationOptions.register({ description: 'tracked-range-always-grows-when-typing-at-edges', stickiness: 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-never-grows-when-typing-at-edges', stickiness: 1 /* model.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-before', stickiness: 2 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-after', stickiness: 3 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */ }),\n];\nfunction _normalizeOptions(options) {\n    if (options instanceof ModelDecorationOptions) {\n        return options;\n    }\n    return ModelDecorationOptions.createDynamic(options);\n}\nclass DidChangeDecorationsEmitter extends Disposable {\n    constructor(handleBeforeFire) {\n        super();\n        this.handleBeforeFire = handleBeforeFire;\n        this._actual = this._register(new Emitter());\n        this.event = this._actual.event;\n        this._affectedInjectedTextLines = null;\n        this._deferredCnt = 0;\n        this._shouldFireDeferred = false;\n        this._affectsMinimap = false;\n        this._affectsOverviewRuler = false;\n        this._affectsGlyphMargin = false;\n        this._affectsLineNumber = false;\n    }\n    beginDeferredEmit() {\n        this._deferredCnt++;\n    }\n    endDeferredEmit() {\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._shouldFireDeferred) {\n                this.doFire();\n            }\n            this._affectedInjectedTextLines?.clear();\n            this._affectedInjectedTextLines = null;\n        }\n    }\n    recordLineAffectedByInjectedText(lineNumber) {\n        if (!this._affectedInjectedTextLines) {\n            this._affectedInjectedTextLines = new Set();\n        }\n        this._affectedInjectedTextLines.add(lineNumber);\n    }\n    checkAffectedAndFire(options) {\n        this._affectsMinimap ||= !!options.minimap?.position;\n        this._affectsOverviewRuler ||= !!options.overviewRuler?.color;\n        this._affectsGlyphMargin ||= !!options.glyphMarginClassName;\n        this._affectsLineNumber ||= !!options.lineNumberClassName;\n        this.tryFire();\n    }\n    fire() {\n        this._affectsMinimap = true;\n        this._affectsOverviewRuler = true;\n        this._affectsGlyphMargin = true;\n        this.tryFire();\n    }\n    tryFire() {\n        if (this._deferredCnt === 0) {\n            this.doFire();\n        }\n        else {\n            this._shouldFireDeferred = true;\n        }\n    }\n    doFire() {\n        this.handleBeforeFire(this._affectedInjectedTextLines);\n        const event = {\n            affectsMinimap: this._affectsMinimap,\n            affectsOverviewRuler: this._affectsOverviewRuler,\n            affectsGlyphMargin: this._affectsGlyphMargin,\n            affectsLineNumber: this._affectsLineNumber,\n        };\n        this._shouldFireDeferred = false;\n        this._affectsMinimap = false;\n        this._affectsOverviewRuler = false;\n        this._affectsGlyphMargin = false;\n        this._actual.fire(event);\n    }\n}\n//#endregion\nclass DidChangeContentEmitter extends Disposable {\n    constructor() {\n        super();\n        /**\n         * Both `fastEvent` and `slowEvent` work the same way and contain the same events, but first we invoke `fastEvent` and then `slowEvent`.\n         */\n        this._fastEmitter = this._register(new Emitter());\n        this.fastEvent = this._fastEmitter.event;\n        this._slowEmitter = this._register(new Emitter());\n        this.slowEvent = this._slowEmitter.event;\n        this._deferredCnt = 0;\n        this._deferredEvent = null;\n    }\n    beginDeferredEmit() {\n        this._deferredCnt++;\n    }\n    endDeferredEmit(resultingSelection = null) {\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._deferredEvent !== null) {\n                this._deferredEvent.rawContentChangedEvent.resultingSelection = resultingSelection;\n                const e = this._deferredEvent;\n                this._deferredEvent = null;\n                this._fastEmitter.fire(e);\n                this._slowEmitter.fire(e);\n            }\n        }\n    }\n    fire(e) {\n        if (this._deferredCnt > 0) {\n            if (this._deferredEvent) {\n                this._deferredEvent = this._deferredEvent.merge(e);\n            }\n            else {\n                this._deferredEvent = e;\n            }\n            return;\n        }\n        this._fastEmitter.fire(e);\n        this._slowEmitter.fire(e);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Disposable } from '../../../base/common/lifecycle.js';\nexport class TextModelPart extends Disposable {\n    constructor() {\n        super(...arguments);\n        this._isDisposed = false;\n    }\n    dispose() {\n        super.dispose();\n        this._isDisposed = true;\n    }\n    assertNotDisposed() {\n        if (this._isDisposed) {\n            throw new Error('TextModelPart is disposed!');\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Returns:\n *  - -1 => the line consists of whitespace\n *  - otherwise => the indent level is returned value\n */\nexport function computeIndentLevel(line, tabSize) {\n    let indent = 0;\n    let i = 0;\n    const len = line.length;\n    while (i < len) {\n        const chCode = line.charCodeAt(i);\n        if (chCode === 32 /* CharCode.Space */) {\n            indent++;\n        }\n        else if (chCode === 9 /* CharCode.Tab */) {\n            indent = indent - indent % tabSize + tabSize;\n        }\n        else {\n            break;\n        }\n        i++;\n    }\n    if (i === len) {\n        return -1; // line only consists of whitespace\n    }\n    return indent;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar ModelService_1;\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, DisposableStore } from '../../../base/common/lifecycle.js';\nimport * as platform from '../../../base/common/platform.js';\nimport { TextModel } from '../model/textModel.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../core/textModelDefaults.js';\nimport { PLAINTEXT_LANGUAGE_ID } from '../languages/modesRegistry.js';\nimport { ITextResourcePropertiesService } from './textResourceConfiguration.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { IUndoRedoService } from '../../../platform/undoRedo/common/undoRedo.js';\nimport { StringSHA1 } from '../../../base/common/hash.js';\nimport { isEditStackElement } from '../model/editStack.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { equals } from '../../../base/common/objects.js';\nimport { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nfunction MODEL_ID(resource) {\n    return resource.toString();\n}\nclass ModelData {\n    constructor(model, onWillDispose, onDidChangeLanguage) {\n        this.model = model;\n        this._modelEventListeners = new DisposableStore();\n        this.model = model;\n        this._modelEventListeners.add(model.onWillDispose(() => onWillDispose(model)));\n        this._modelEventListeners.add(model.onDidChangeLanguage((e) => onDidChangeLanguage(model, e)));\n    }\n    dispose() {\n        this._modelEventListeners.dispose();\n    }\n}\nconst DEFAULT_EOL = (platform.isLinux || platform.isMacintosh) ? 1 /* DefaultEndOfLine.LF */ : 2 /* DefaultEndOfLine.CRLF */;\nclass DisposedModelInfo {\n    constructor(uri, initialUndoRedoSnapshot, time, sharesUndoRedoStack, heapSize, sha1, versionId, alternativeVersionId) {\n        this.uri = uri;\n        this.initialUndoRedoSnapshot = initialUndoRedoSnapshot;\n        this.time = time;\n        this.sharesUndoRedoStack = sharesUndoRedoStack;\n        this.heapSize = heapSize;\n        this.sha1 = sha1;\n        this.versionId = versionId;\n        this.alternativeVersionId = alternativeVersionId;\n    }\n}\nlet ModelService = class ModelService extends Disposable {\n    static { ModelService_1 = this; }\n    static { this.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK = 20 * 1024 * 1024; }\n    constructor(_configurationService, _resourcePropertiesService, _undoRedoService, _instantiationService) {\n        super();\n        this._configurationService = _configurationService;\n        this._resourcePropertiesService = _resourcePropertiesService;\n        this._undoRedoService = _undoRedoService;\n        this._instantiationService = _instantiationService;\n        this._onModelAdded = this._register(new Emitter());\n        this.onModelAdded = this._onModelAdded.event;\n        this._onModelRemoved = this._register(new Emitter());\n        this.onModelRemoved = this._onModelRemoved.event;\n        this._onModelModeChanged = this._register(new Emitter());\n        this.onModelLanguageChanged = this._onModelModeChanged.event;\n        this._modelCreationOptionsByLanguageAndResource = Object.create(null);\n        this._models = {};\n        this._disposedModels = new Map();\n        this._disposedModelsHeapSize = 0;\n        this._register(this._configurationService.onDidChangeConfiguration(e => this._updateModelOptions(e)));\n        this._updateModelOptions(undefined);\n    }\n    static _readModelOptions(config, isForSimpleWidget) {\n        let tabSize = EDITOR_MODEL_DEFAULTS.tabSize;\n        if (config.editor && typeof config.editor.tabSize !== 'undefined') {\n            const parsedTabSize = parseInt(config.editor.tabSize, 10);\n            if (!isNaN(parsedTabSize)) {\n                tabSize = parsedTabSize;\n            }\n            if (tabSize < 1) {\n                tabSize = 1;\n            }\n        }\n        let indentSize = 'tabSize';\n        if (config.editor && typeof config.editor.indentSize !== 'undefined' && config.editor.indentSize !== 'tabSize') {\n            const parsedIndentSize = parseInt(config.editor.indentSize, 10);\n            if (!isNaN(parsedIndentSize)) {\n                indentSize = Math.max(parsedIndentSize, 1);\n            }\n        }\n        let insertSpaces = EDITOR_MODEL_DEFAULTS.insertSpaces;\n        if (config.editor && typeof config.editor.insertSpaces !== 'undefined') {\n            insertSpaces = (config.editor.insertSpaces === 'false' ? false : Boolean(config.editor.insertSpaces));\n        }\n        let newDefaultEOL = DEFAULT_EOL;\n        const eol = config.eol;\n        if (eol === '\\r\\n') {\n            newDefaultEOL = 2 /* DefaultEndOfLine.CRLF */;\n        }\n        else if (eol === '\\n') {\n            newDefaultEOL = 1 /* DefaultEndOfLine.LF */;\n        }\n        let trimAutoWhitespace = EDITOR_MODEL_DEFAULTS.trimAutoWhitespace;\n        if (config.editor && typeof config.editor.trimAutoWhitespace !== 'undefined') {\n            trimAutoWhitespace = (config.editor.trimAutoWhitespace === 'false' ? false : Boolean(config.editor.trimAutoWhitespace));\n        }\n        let detectIndentation = EDITOR_MODEL_DEFAULTS.detectIndentation;\n        if (config.editor && typeof config.editor.detectIndentation !== 'undefined') {\n            detectIndentation = (config.editor.detectIndentation === 'false' ? false : Boolean(config.editor.detectIndentation));\n        }\n        let largeFileOptimizations = EDITOR_MODEL_DEFAULTS.largeFileOptimizations;\n        if (config.editor && typeof config.editor.largeFileOptimizations !== 'undefined') {\n            largeFileOptimizations = (config.editor.largeFileOptimizations === 'false' ? false : Boolean(config.editor.largeFileOptimizations));\n        }\n        let bracketPairColorizationOptions = EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions;\n        if (config.editor?.bracketPairColorization && typeof config.editor.bracketPairColorization === 'object') {\n            bracketPairColorizationOptions = {\n                enabled: !!config.editor.bracketPairColorization.enabled,\n                independentColorPoolPerBracketType: !!config.editor.bracketPairColorization.independentColorPoolPerBracketType\n            };\n        }\n        return {\n            isForSimpleWidget: isForSimpleWidget,\n            tabSize: tabSize,\n            indentSize: indentSize,\n            insertSpaces: insertSpaces,\n            detectIndentation: detectIndentation,\n            defaultEOL: newDefaultEOL,\n            trimAutoWhitespace: trimAutoWhitespace,\n            largeFileOptimizations: largeFileOptimizations,\n            bracketPairColorizationOptions\n        };\n    }\n    _getEOL(resource, language) {\n        if (resource) {\n            return this._resourcePropertiesService.getEOL(resource, language);\n        }\n        const eol = this._configurationService.getValue('files.eol', { overrideIdentifier: language });\n        if (eol && typeof eol === 'string' && eol !== 'auto') {\n            return eol;\n        }\n        return platform.OS === 3 /* platform.OperatingSystem.Linux */ || platform.OS === 2 /* platform.OperatingSystem.Macintosh */ ? '\\n' : '\\r\\n';\n    }\n    _shouldRestoreUndoStack() {\n        const result = this._configurationService.getValue('files.restoreUndoStack');\n        if (typeof result === 'boolean') {\n            return result;\n        }\n        return true;\n    }\n    getCreationOptions(languageIdOrSelection, resource, isForSimpleWidget) {\n        const language = (typeof languageIdOrSelection === 'string' ? languageIdOrSelection : languageIdOrSelection.languageId);\n        let creationOptions = this._modelCreationOptionsByLanguageAndResource[language + resource];\n        if (!creationOptions) {\n            const editor = this._configurationService.getValue('editor', { overrideIdentifier: language, resource });\n            const eol = this._getEOL(resource, language);\n            creationOptions = ModelService_1._readModelOptions({ editor, eol }, isForSimpleWidget);\n            this._modelCreationOptionsByLanguageAndResource[language + resource] = creationOptions;\n        }\n        return creationOptions;\n    }\n    _updateModelOptions(e) {\n        const oldOptionsByLanguageAndResource = this._modelCreationOptionsByLanguageAndResource;\n        this._modelCreationOptionsByLanguageAndResource = Object.create(null);\n        // Update options on all models\n        const keys = Object.keys(this._models);\n        for (let i = 0, len = keys.length; i < len; i++) {\n            const modelId = keys[i];\n            const modelData = this._models[modelId];\n            const language = modelData.model.getLanguageId();\n            const uri = modelData.model.uri;\n            if (e && !e.affectsConfiguration('editor', { overrideIdentifier: language, resource: uri }) && !e.affectsConfiguration('files.eol', { overrideIdentifier: language, resource: uri })) {\n                continue; // perf: skip if this model is not affected by configuration change\n            }\n            const oldOptions = oldOptionsByLanguageAndResource[language + uri];\n            const newOptions = this.getCreationOptions(language, uri, modelData.model.isForSimpleWidget);\n            ModelService_1._setModelOptionsForModel(modelData.model, newOptions, oldOptions);\n        }\n    }\n    static _setModelOptionsForModel(model, newOptions, currentOptions) {\n        if (currentOptions && currentOptions.defaultEOL !== newOptions.defaultEOL && model.getLineCount() === 1) {\n            model.setEOL(newOptions.defaultEOL === 1 /* DefaultEndOfLine.LF */ ? 0 /* EndOfLineSequence.LF */ : 1 /* EndOfLineSequence.CRLF */);\n        }\n        if (currentOptions\n            && (currentOptions.detectIndentation === newOptions.detectIndentation)\n            && (currentOptions.insertSpaces === newOptions.insertSpaces)\n            && (currentOptions.tabSize === newOptions.tabSize)\n            && (currentOptions.indentSize === newOptions.indentSize)\n            && (currentOptions.trimAutoWhitespace === newOptions.trimAutoWhitespace)\n            && equals(currentOptions.bracketPairColorizationOptions, newOptions.bracketPairColorizationOptions)) {\n            // Same indent opts, no need to touch the model\n            return;\n        }\n        if (newOptions.detectIndentation) {\n            model.detectIndentation(newOptions.insertSpaces, newOptions.tabSize);\n            model.updateOptions({\n                trimAutoWhitespace: newOptions.trimAutoWhitespace,\n                bracketColorizationOptions: newOptions.bracketPairColorizationOptions\n            });\n        }\n        else {\n            model.updateOptions({\n                insertSpaces: newOptions.insertSpaces,\n                tabSize: newOptions.tabSize,\n                indentSize: newOptions.indentSize,\n                trimAutoWhitespace: newOptions.trimAutoWhitespace,\n                bracketColorizationOptions: newOptions.bracketPairColorizationOptions\n            });\n        }\n    }\n    // --- begin IModelService\n    _insertDisposedModel(disposedModelData) {\n        this._disposedModels.set(MODEL_ID(disposedModelData.uri), disposedModelData);\n        this._disposedModelsHeapSize += disposedModelData.heapSize;\n    }\n    _removeDisposedModel(resource) {\n        const disposedModelData = this._disposedModels.get(MODEL_ID(resource));\n        if (disposedModelData) {\n            this._disposedModelsHeapSize -= disposedModelData.heapSize;\n        }\n        this._disposedModels.delete(MODEL_ID(resource));\n        return disposedModelData;\n    }\n    _ensureDisposedModelsHeapSize(maxModelsHeapSize) {\n        if (this._disposedModelsHeapSize > maxModelsHeapSize) {\n            // we must remove some old undo stack elements to free up some memory\n            const disposedModels = [];\n            this._disposedModels.forEach(entry => {\n                if (!entry.sharesUndoRedoStack) {\n                    disposedModels.push(entry);\n                }\n            });\n            disposedModels.sort((a, b) => a.time - b.time);\n            while (disposedModels.length > 0 && this._disposedModelsHeapSize > maxModelsHeapSize) {\n                const disposedModel = disposedModels.shift();\n                this._removeDisposedModel(disposedModel.uri);\n                if (disposedModel.initialUndoRedoSnapshot !== null) {\n                    this._undoRedoService.restoreSnapshot(disposedModel.initialUndoRedoSnapshot);\n                }\n            }\n        }\n    }\n    _createModelData(value, languageIdOrSelection, resource, isForSimpleWidget) {\n        // create & save the model\n        const options = this.getCreationOptions(languageIdOrSelection, resource, isForSimpleWidget);\n        const model = this._instantiationService.createInstance(TextModel, value, languageIdOrSelection, options, resource);\n        if (resource && this._disposedModels.has(MODEL_ID(resource))) {\n            const disposedModelData = this._removeDisposedModel(resource);\n            const elements = this._undoRedoService.getElements(resource);\n            const sha1Computer = this._getSHA1Computer();\n            const sha1IsEqual = (sha1Computer.canComputeSHA1(model)\n                ? sha1Computer.computeSHA1(model) === disposedModelData.sha1\n                : false);\n            if (sha1IsEqual || disposedModelData.sharesUndoRedoStack) {\n                for (const element of elements.past) {\n                    if (isEditStackElement(element) && element.matchesResource(resource)) {\n                        element.setModel(model);\n                    }\n                }\n                for (const element of elements.future) {\n                    if (isEditStackElement(element) && element.matchesResource(resource)) {\n                        element.setModel(model);\n                    }\n                }\n                this._undoRedoService.setElementsValidFlag(resource, true, (element) => (isEditStackElement(element) && element.matchesResource(resource)));\n                if (sha1IsEqual) {\n                    model._overwriteVersionId(disposedModelData.versionId);\n                    model._overwriteAlternativeVersionId(disposedModelData.alternativeVersionId);\n                    model._overwriteInitialUndoRedoSnapshot(disposedModelData.initialUndoRedoSnapshot);\n                }\n            }\n            else {\n                if (disposedModelData.initialUndoRedoSnapshot !== null) {\n                    this._undoRedoService.restoreSnapshot(disposedModelData.initialUndoRedoSnapshot);\n                }\n            }\n        }\n        const modelId = MODEL_ID(model.uri);\n        if (this._models[modelId]) {\n            // There already exists a model with this id => this is a programmer error\n            throw new Error('ModelService: Cannot add model because it already exists!');\n        }\n        const modelData = new ModelData(model, (model) => this._onWillDispose(model), (model, e) => this._onDidChangeLanguage(model, e));\n        this._models[modelId] = modelData;\n        return modelData;\n    }\n    createModel(value, languageSelection, resource, isForSimpleWidget = false) {\n        let modelData;\n        if (languageSelection) {\n            modelData = this._createModelData(value, languageSelection, resource, isForSimpleWidget);\n        }\n        else {\n            modelData = this._createModelData(value, PLAINTEXT_LANGUAGE_ID, resource, isForSimpleWidget);\n        }\n        this._onModelAdded.fire(modelData.model);\n        return modelData.model;\n    }\n    getModels() {\n        const ret = [];\n        const keys = Object.keys(this._models);\n        for (let i = 0, len = keys.length; i < len; i++) {\n            const modelId = keys[i];\n            ret.push(this._models[modelId].model);\n        }\n        return ret;\n    }\n    getModel(resource) {\n        const modelId = MODEL_ID(resource);\n        const modelData = this._models[modelId];\n        if (!modelData) {\n            return null;\n        }\n        return modelData.model;\n    }\n    // --- end IModelService\n    _schemaShouldMaintainUndoRedoElements(resource) {\n        return (resource.scheme === Schemas.file\n            || resource.scheme === Schemas.vscodeRemote\n            || resource.scheme === Schemas.vscodeUserData\n            || resource.scheme === Schemas.vscodeNotebookCell\n            || resource.scheme === 'fake-fs' // for tests\n        );\n    }\n    _onWillDispose(model) {\n        const modelId = MODEL_ID(model.uri);\n        const modelData = this._models[modelId];\n        const sharesUndoRedoStack = (this._undoRedoService.getUriComparisonKey(model.uri) !== model.uri.toString());\n        let maintainUndoRedoStack = false;\n        let heapSize = 0;\n        if (sharesUndoRedoStack || (this._shouldRestoreUndoStack() && this._schemaShouldMaintainUndoRedoElements(model.uri))) {\n            const elements = this._undoRedoService.getElements(model.uri);\n            if (elements.past.length > 0 || elements.future.length > 0) {\n                for (const element of elements.past) {\n                    if (isEditStackElement(element) && element.matchesResource(model.uri)) {\n                        maintainUndoRedoStack = true;\n                        heapSize += element.heapSize(model.uri);\n                        element.setModel(model.uri); // remove reference from text buffer instance\n                    }\n                }\n                for (const element of elements.future) {\n                    if (isEditStackElement(element) && element.matchesResource(model.uri)) {\n                        maintainUndoRedoStack = true;\n                        heapSize += element.heapSize(model.uri);\n                        element.setModel(model.uri); // remove reference from text buffer instance\n                    }\n                }\n            }\n        }\n        const maxMemory = ModelService_1.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK;\n        const sha1Computer = this._getSHA1Computer();\n        if (!maintainUndoRedoStack) {\n            if (!sharesUndoRedoStack) {\n                const initialUndoRedoSnapshot = modelData.model.getInitialUndoRedoSnapshot();\n                if (initialUndoRedoSnapshot !== null) {\n                    this._undoRedoService.restoreSnapshot(initialUndoRedoSnapshot);\n                }\n            }\n        }\n        else if (!sharesUndoRedoStack && (heapSize > maxMemory || !sha1Computer.canComputeSHA1(model))) {\n            // the undo stack for this file would never fit in the configured memory or the file is very large, so don't bother with it.\n            const initialUndoRedoSnapshot = modelData.model.getInitialUndoRedoSnapshot();\n            if (initialUndoRedoSnapshot !== null) {\n                this._undoRedoService.restoreSnapshot(initialUndoRedoSnapshot);\n            }\n        }\n        else {\n            this._ensureDisposedModelsHeapSize(maxMemory - heapSize);\n            // We only invalidate the elements, but they remain in the undo-redo service.\n            this._undoRedoService.setElementsValidFlag(model.uri, false, (element) => (isEditStackElement(element) && element.matchesResource(model.uri)));\n            this._insertDisposedModel(new DisposedModelInfo(model.uri, modelData.model.getInitialUndoRedoSnapshot(), Date.now(), sharesUndoRedoStack, heapSize, sha1Computer.computeSHA1(model), model.getVersionId(), model.getAlternativeVersionId()));\n        }\n        delete this._models[modelId];\n        modelData.dispose();\n        // clean up cache\n        delete this._modelCreationOptionsByLanguageAndResource[model.getLanguageId() + model.uri];\n        this._onModelRemoved.fire(model);\n    }\n    _onDidChangeLanguage(model, e) {\n        const oldLanguageId = e.oldLanguage;\n        const newLanguageId = model.getLanguageId();\n        const oldOptions = this.getCreationOptions(oldLanguageId, model.uri, model.isForSimpleWidget);\n        const newOptions = this.getCreationOptions(newLanguageId, model.uri, model.isForSimpleWidget);\n        ModelService_1._setModelOptionsForModel(model, newOptions, oldOptions);\n        this._onModelModeChanged.fire({ model, oldLanguageId: oldLanguageId });\n    }\n    _getSHA1Computer() {\n        return new DefaultModelSHA1Computer();\n    }\n};\nModelService = ModelService_1 = __decorate([\n    __param(0, IConfigurationService),\n    __param(1, ITextResourcePropertiesService),\n    __param(2, IUndoRedoService),\n    __param(3, IInstantiationService)\n], ModelService);\nexport { ModelService };\nexport class DefaultModelSHA1Computer {\n    static { this.MAX_MODEL_SIZE = 10 * 1024 * 1024; } // takes 200ms to compute a sha1 on a 10MB model on a new machine\n    canComputeSHA1(model) {\n        return (model.getValueLength() <= DefaultModelSHA1Computer.MAX_MODEL_SIZE);\n    }\n    computeSHA1(model) {\n        // compute the sha1\n        const shaComputer = new StringSHA1();\n        const snapshot = model.createSnapshot();\n        let text;\n        while ((text = snapshot.read())) {\n            shaComputer.update(text);\n        }\n        return shaComputer.digest();\n    }\n}\n","import { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nexport const ITextResourceConfigurationService = createDecorator('textResourceConfigurationService');\nexport const ITextResourcePropertiesService = createDecorator('textResourcePropertiesService');\n","import { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nexport const ITreeSitterParserService = createDecorator('treeSitterParserService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * An event describing that a model has been reset to a new value.\n * @internal\n */\nexport class ModelRawFlush {\n    constructor() {\n        this.changeType = 1 /* RawContentChangedType.Flush */;\n    }\n}\n/**\n * Represents text injected on a line\n * @internal\n */\nexport class LineInjectedText {\n    static applyInjectedText(lineText, injectedTexts) {\n        if (!injectedTexts || injectedTexts.length === 0) {\n            return lineText;\n        }\n        let result = '';\n        let lastOriginalOffset = 0;\n        for (const injectedText of injectedTexts) {\n            result += lineText.substring(lastOriginalOffset, injectedText.column - 1);\n            lastOriginalOffset = injectedText.column - 1;\n            result += injectedText.options.content;\n        }\n        result += lineText.substring(lastOriginalOffset);\n        return result;\n    }\n    static fromDecorations(decorations) {\n        const result = [];\n        for (const decoration of decorations) {\n            if (decoration.options.before && decoration.options.before.content.length > 0) {\n                result.push(new LineInjectedText(decoration.ownerId, decoration.range.startLineNumber, decoration.range.startColumn, decoration.options.before, 0));\n            }\n            if (decoration.options.after && decoration.options.after.content.length > 0) {\n                result.push(new LineInjectedText(decoration.ownerId, decoration.range.endLineNumber, decoration.range.endColumn, decoration.options.after, 1));\n            }\n        }\n        result.sort((a, b) => {\n            if (a.lineNumber === b.lineNumber) {\n                if (a.column === b.column) {\n                    return a.order - b.order;\n                }\n                return a.column - b.column;\n            }\n            return a.lineNumber - b.lineNumber;\n        });\n        return result;\n    }\n    constructor(ownerId, lineNumber, column, options, order) {\n        this.ownerId = ownerId;\n        this.lineNumber = lineNumber;\n        this.column = column;\n        this.options = options;\n        this.order = order;\n    }\n}\n/**\n * An event describing that a line has changed in a model.\n * @internal\n */\nexport class ModelRawLineChanged {\n    constructor(lineNumber, detail, injectedText) {\n        this.changeType = 2 /* RawContentChangedType.LineChanged */;\n        this.lineNumber = lineNumber;\n        this.detail = detail;\n        this.injectedText = injectedText;\n    }\n}\n/**\n * An event describing that line(s) have been deleted in a model.\n * @internal\n */\nexport class ModelRawLinesDeleted {\n    constructor(fromLineNumber, toLineNumber) {\n        this.changeType = 3 /* RawContentChangedType.LinesDeleted */;\n        this.fromLineNumber = fromLineNumber;\n        this.toLineNumber = toLineNumber;\n    }\n}\n/**\n * An event describing that line(s) have been inserted in a model.\n * @internal\n */\nexport class ModelRawLinesInserted {\n    constructor(fromLineNumber, toLineNumber, detail, injectedTexts) {\n        this.changeType = 4 /* RawContentChangedType.LinesInserted */;\n        this.injectedTexts = injectedTexts;\n        this.fromLineNumber = fromLineNumber;\n        this.toLineNumber = toLineNumber;\n        this.detail = detail;\n    }\n}\n/**\n * An event describing that a model has had its EOL changed.\n * @internal\n */\nexport class ModelRawEOLChanged {\n    constructor() {\n        this.changeType = 5 /* RawContentChangedType.EOLChanged */;\n    }\n}\n/**\n * An event describing a change in the text of a model.\n * @internal\n */\nexport class ModelRawContentChangedEvent {\n    constructor(changes, versionId, isUndoing, isRedoing) {\n        this.changes = changes;\n        this.versionId = versionId;\n        this.isUndoing = isUndoing;\n        this.isRedoing = isRedoing;\n        this.resultingSelection = null;\n    }\n    containsEvent(type) {\n        for (let i = 0, len = this.changes.length; i < len; i++) {\n            const change = this.changes[i];\n            if (change.changeType === type) {\n                return true;\n            }\n        }\n        return false;\n    }\n    static merge(a, b) {\n        const changes = [].concat(a.changes).concat(b.changes);\n        const versionId = b.versionId;\n        const isUndoing = (a.isUndoing || b.isUndoing);\n        const isRedoing = (a.isRedoing || b.isRedoing);\n        return new ModelRawContentChangedEvent(changes, versionId, isUndoing, isRedoing);\n    }\n}\n/**\n * An event describing a change in injected text.\n * @internal\n */\nexport class ModelInjectedTextChangedEvent {\n    constructor(changes) {\n        this.changes = changes;\n    }\n}\n/**\n * @internal\n */\nexport class InternalModelContentChangeEvent {\n    constructor(rawContentChangedEvent, contentChangedEvent) {\n        this.rawContentChangedEvent = rawContentChangedEvent;\n        this.contentChangedEvent = contentChangedEvent;\n    }\n    merge(other) {\n        const rawContentChangedEvent = ModelRawContentChangedEvent.merge(this.rawContentChangedEvent, other.rawContentChangedEvent);\n        const contentChangedEvent = InternalModelContentChangeEvent._mergeChangeEvents(this.contentChangedEvent, other.contentChangedEvent);\n        return new InternalModelContentChangeEvent(rawContentChangedEvent, contentChangedEvent);\n    }\n    static _mergeChangeEvents(a, b) {\n        const changes = [].concat(a.changes).concat(b.changes);\n        const eol = b.eol;\n        const versionId = b.versionId;\n        const isUndoing = (a.isUndoing || b.isUndoing);\n        const isRedoing = (a.isRedoing || b.isRedoing);\n        const isFlush = (a.isFlush || b.isFlush);\n        const isEolChange = a.isEolChange && b.isEolChange; // both must be true to not confuse listeners who skip such edits\n        return {\n            changes: changes,\n            eol: eol,\n            isEolChange: isEolChange,\n            versionId: versionId,\n            isUndoing: isUndoing,\n            isRedoing: isRedoing,\n            isFlush: isFlush,\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport var HorizontalGuidesState;\n(function (HorizontalGuidesState) {\n    HorizontalGuidesState[HorizontalGuidesState[\"Disabled\"] = 0] = \"Disabled\";\n    HorizontalGuidesState[HorizontalGuidesState[\"EnabledForActive\"] = 1] = \"EnabledForActive\";\n    HorizontalGuidesState[HorizontalGuidesState[\"Enabled\"] = 2] = \"Enabled\";\n})(HorizontalGuidesState || (HorizontalGuidesState = {}));\nexport class IndentGuide {\n    constructor(visibleColumn, column, className, \n    /**\n     * If set, this indent guide is a horizontal guide (no vertical part).\n     * It starts at visibleColumn and continues until endColumn.\n    */\n    horizontalLine, \n    /**\n     * If set (!= -1), only show this guide for wrapped lines that don't contain this model column, but are after it.\n    */\n    forWrappedLinesAfterColumn, forWrappedLinesBeforeOrAtColumn) {\n        this.visibleColumn = visibleColumn;\n        this.column = column;\n        this.className = className;\n        this.horizontalLine = horizontalLine;\n        this.forWrappedLinesAfterColumn = forWrappedLinesAfterColumn;\n        this.forWrappedLinesBeforeOrAtColumn = forWrappedLinesBeforeOrAtColumn;\n        if ((visibleColumn !== -1) === (column !== -1)) {\n            throw new Error();\n        }\n    }\n}\nexport class IndentGuideHorizontalLine {\n    constructor(top, endColumn) {\n        this.top = top;\n        this.endColumn = endColumn;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { TokenMetadata } from '../encodedTokenAttributes.js';\nexport class LineTokens {\n    static { this.defaultTokenMetadata = ((0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n        | (1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n        | (2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0; }\n    static createEmpty(lineContent, decoder) {\n        const defaultMetadata = LineTokens.defaultTokenMetadata;\n        const tokens = new Uint32Array(2);\n        tokens[0] = lineContent.length;\n        tokens[1] = defaultMetadata;\n        return new LineTokens(tokens, lineContent, decoder);\n    }\n    static createFromTextAndMetadata(data, decoder) {\n        let offset = 0;\n        let fullText = '';\n        const tokens = new Array();\n        for (const { text, metadata } of data) {\n            tokens.push(offset + text.length, metadata);\n            offset += text.length;\n            fullText += text;\n        }\n        return new LineTokens(new Uint32Array(tokens), fullText, decoder);\n    }\n    constructor(tokens, text, decoder) {\n        this._lineTokensBrand = undefined;\n        this._tokens = tokens;\n        this._tokensCount = (this._tokens.length >>> 1);\n        this._text = text;\n        this.languageIdCodec = decoder;\n    }\n    equals(other) {\n        if (other instanceof LineTokens) {\n            return this.slicedEquals(other, 0, this._tokensCount);\n        }\n        return false;\n    }\n    slicedEquals(other, sliceFromTokenIndex, sliceTokenCount) {\n        if (this._text !== other._text) {\n            return false;\n        }\n        if (this._tokensCount !== other._tokensCount) {\n            return false;\n        }\n        const from = (sliceFromTokenIndex << 1);\n        const to = from + (sliceTokenCount << 1);\n        for (let i = from; i < to; i++) {\n            if (this._tokens[i] !== other._tokens[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    getLineContent() {\n        return this._text;\n    }\n    getCount() {\n        return this._tokensCount;\n    }\n    getStartOffset(tokenIndex) {\n        if (tokenIndex > 0) {\n            return this._tokens[(tokenIndex - 1) << 1];\n        }\n        return 0;\n    }\n    getMetadata(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return metadata;\n    }\n    getLanguageId(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        const languageId = TokenMetadata.getLanguageId(metadata);\n        return this.languageIdCodec.decodeLanguageId(languageId);\n    }\n    getStandardTokenType(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getTokenType(metadata);\n    }\n    getForeground(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getForeground(metadata);\n    }\n    getClassName(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getClassNameFromMetadata(metadata);\n    }\n    getInlineStyle(tokenIndex, colorMap) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getInlineStyleFromMetadata(metadata, colorMap);\n    }\n    getPresentation(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getPresentationFromMetadata(metadata);\n    }\n    getEndOffset(tokenIndex) {\n        return this._tokens[tokenIndex << 1];\n    }\n    /**\n     * Find the token containing offset `offset`.\n     * @param offset The search offset\n     * @return The index of the token containing the offset.\n     */\n    findTokenIndexAtOffset(offset) {\n        return LineTokens.findIndexInTokensArray(this._tokens, offset);\n    }\n    inflate() {\n        return this;\n    }\n    sliceAndInflate(startOffset, endOffset, deltaOffset) {\n        return new SliceLineTokens(this, startOffset, endOffset, deltaOffset);\n    }\n    static convertToEndOffset(tokens, lineTextLength) {\n        const tokenCount = (tokens.length >>> 1);\n        const lastTokenIndex = tokenCount - 1;\n        for (let tokenIndex = 0; tokenIndex < lastTokenIndex; tokenIndex++) {\n            tokens[tokenIndex << 1] = tokens[(tokenIndex + 1) << 1];\n        }\n        tokens[lastTokenIndex << 1] = lineTextLength;\n    }\n    static findIndexInTokensArray(tokens, desiredIndex) {\n        if (tokens.length <= 2) {\n            return 0;\n        }\n        let low = 0;\n        let high = (tokens.length >>> 1) - 1;\n        while (low < high) {\n            const mid = low + Math.floor((high - low) / 2);\n            const endOffset = tokens[(mid << 1)];\n            if (endOffset === desiredIndex) {\n                return mid + 1;\n            }\n            else if (endOffset < desiredIndex) {\n                low = mid + 1;\n            }\n            else if (endOffset > desiredIndex) {\n                high = mid;\n            }\n        }\n        return low;\n    }\n    /**\n     * @pure\n     * @param insertTokens Must be sorted by offset.\n    */\n    withInserted(insertTokens) {\n        if (insertTokens.length === 0) {\n            return this;\n        }\n        let nextOriginalTokenIdx = 0;\n        let nextInsertTokenIdx = 0;\n        let text = '';\n        const newTokens = new Array();\n        let originalEndOffset = 0;\n        while (true) {\n            const nextOriginalTokenEndOffset = nextOriginalTokenIdx < this._tokensCount ? this._tokens[nextOriginalTokenIdx << 1] : -1;\n            const nextInsertToken = nextInsertTokenIdx < insertTokens.length ? insertTokens[nextInsertTokenIdx] : null;\n            if (nextOriginalTokenEndOffset !== -1 && (nextInsertToken === null || nextOriginalTokenEndOffset <= nextInsertToken.offset)) {\n                // original token ends before next insert token\n                text += this._text.substring(originalEndOffset, nextOriginalTokenEndOffset);\n                const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n                newTokens.push(text.length, metadata);\n                nextOriginalTokenIdx++;\n                originalEndOffset = nextOriginalTokenEndOffset;\n            }\n            else if (nextInsertToken) {\n                if (nextInsertToken.offset > originalEndOffset) {\n                    // insert token is in the middle of the next token.\n                    text += this._text.substring(originalEndOffset, nextInsertToken.offset);\n                    const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n                    newTokens.push(text.length, metadata);\n                    originalEndOffset = nextInsertToken.offset;\n                }\n                text += nextInsertToken.text;\n                newTokens.push(text.length, nextInsertToken.tokenMetadata);\n                nextInsertTokenIdx++;\n            }\n            else {\n                break;\n            }\n        }\n        return new LineTokens(new Uint32Array(newTokens), text, this.languageIdCodec);\n    }\n    getTokenText(tokenIndex) {\n        const startOffset = this.getStartOffset(tokenIndex);\n        const endOffset = this.getEndOffset(tokenIndex);\n        const text = this._text.substring(startOffset, endOffset);\n        return text;\n    }\n    forEach(callback) {\n        const tokenCount = this.getCount();\n        for (let tokenIndex = 0; tokenIndex < tokenCount; tokenIndex++) {\n            callback(tokenIndex);\n        }\n    }\n}\nclass SliceLineTokens {\n    constructor(source, startOffset, endOffset, deltaOffset) {\n        this._source = source;\n        this._startOffset = startOffset;\n        this._endOffset = endOffset;\n        this._deltaOffset = deltaOffset;\n        this._firstTokenIndex = source.findTokenIndexAtOffset(startOffset);\n        this.languageIdCodec = source.languageIdCodec;\n        this._tokensCount = 0;\n        for (let i = this._firstTokenIndex, len = source.getCount(); i < len; i++) {\n            const tokenStartOffset = source.getStartOffset(i);\n            if (tokenStartOffset >= endOffset) {\n                break;\n            }\n            this._tokensCount++;\n        }\n    }\n    getMetadata(tokenIndex) {\n        return this._source.getMetadata(this._firstTokenIndex + tokenIndex);\n    }\n    getLanguageId(tokenIndex) {\n        return this._source.getLanguageId(this._firstTokenIndex + tokenIndex);\n    }\n    getLineContent() {\n        return this._source.getLineContent().substring(this._startOffset, this._endOffset);\n    }\n    equals(other) {\n        if (other instanceof SliceLineTokens) {\n            return (this._startOffset === other._startOffset\n                && this._endOffset === other._endOffset\n                && this._deltaOffset === other._deltaOffset\n                && this._source.slicedEquals(other._source, this._firstTokenIndex, this._tokensCount));\n        }\n        return false;\n    }\n    getCount() {\n        return this._tokensCount;\n    }\n    getStandardTokenType(tokenIndex) {\n        return this._source.getStandardTokenType(this._firstTokenIndex + tokenIndex);\n    }\n    getForeground(tokenIndex) {\n        return this._source.getForeground(this._firstTokenIndex + tokenIndex);\n    }\n    getEndOffset(tokenIndex) {\n        const tokenEndOffset = this._source.getEndOffset(this._firstTokenIndex + tokenIndex);\n        return Math.min(this._endOffset, tokenEndOffset) - this._startOffset + this._deltaOffset;\n    }\n    getClassName(tokenIndex) {\n        return this._source.getClassName(this._firstTokenIndex + tokenIndex);\n    }\n    getInlineStyle(tokenIndex, colorMap) {\n        return this._source.getInlineStyle(this._firstTokenIndex + tokenIndex, colorMap);\n    }\n    getPresentation(tokenIndex) {\n        return this._source.getPresentation(this._firstTokenIndex + tokenIndex);\n    }\n    findTokenIndexAtOffset(offset) {\n        return this._source.findTokenIndexAtOffset(offset + this._startOffset - this._deltaOffset) - this._firstTokenIndex;\n    }\n    getTokenText(tokenIndex) {\n        const adjustedTokenIndex = this._firstTokenIndex + tokenIndex;\n        const tokenStartOffset = this._source.getStartOffset(adjustedTokenIndex);\n        const tokenEndOffset = this._source.getEndOffset(adjustedTokenIndex);\n        let text = this._source.getTokenText(adjustedTokenIndex);\n        if (tokenStartOffset < this._startOffset) {\n            text = text.substring(this._startOffset - tokenStartOffset);\n        }\n        if (tokenEndOffset > this._endOffset) {\n            text = text.substring(0, text.length - (tokenEndOffset - this._endOffset));\n        }\n        return text;\n    }\n    forEach(callback) {\n        for (let tokenIndex = 0; tokenIndex < this.getCount(); tokenIndex++) {\n            callback(tokenIndex);\n        }\n    }\n}\nexport function getStandardTokenTypeAtPosition(model, position) {\n    const lineNumber = position.lineNumber;\n    if (!model.tokenization.isCheapToTokenize(lineNumber)) {\n        return undefined;\n    }\n    model.tokenization.forceTokenization(lineNumber);\n    const lineTokens = model.tokenization.getLineTokens(lineNumber);\n    const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n    const tokenType = lineTokens.getStandardTokenType(tokenIndex);\n    return tokenType;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class SyncDescriptor {\n    constructor(ctor, staticArguments = [], supportsDelayedInstantiation = false) {\n        this.ctor = ctor;\n        this.staticArguments = staticArguments;\n        this.supportsDelayedInstantiation = supportsDelayedInstantiation;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SyncDescriptor } from './descriptors.js';\nconst _registry = [];\nexport function registerSingleton(id, ctorOrDescriptor, supportsDelayedInstantiation) {\n    if (!(ctorOrDescriptor instanceof SyncDescriptor)) {\n        ctorOrDescriptor = new SyncDescriptor(ctorOrDescriptor, [], Boolean(supportsDelayedInstantiation));\n    }\n    _registry.push([id, ctorOrDescriptor]);\n}\nexport function getSingletonServiceDescriptors() {\n    return _registry;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nexport const IUndoRedoService = createDecorator('undoRedoService');\nexport class ResourceEditStackSnapshot {\n    constructor(resource, elements) {\n        this.resource = resource;\n        this.elements = elements;\n    }\n}\nexport class UndoRedoGroup {\n    static { this._ID = 0; }\n    constructor() {\n        this.id = UndoRedoGroup._ID++;\n        this.order = 1;\n    }\n    nextOrder() {\n        if (this.id === 0) {\n            return 0;\n        }\n        return this.order++;\n    }\n    static { this.None = new UndoRedoGroup(); }\n}\nexport class UndoRedoSource {\n    static { this._ID = 0; }\n    constructor() {\n        this.id = UndoRedoSource._ID++;\n        this.order = 1;\n    }\n    nextOrder() {\n        if (this.id === 0) {\n            return 0;\n        }\n        return this.order++;\n    }\n    static { this.None = new UndoRedoSource(); }\n}\n"],"names":["hasBuffer","Buffer","Lazy","Uint8Array","textDecoder","VSBuffer","wrap","actual","isBuffer","from","buffer","byteOffset","byteLength","constructor","this","toString","TextDecoder","decode","readUInt16LE","source","offset","writeUInt16LE","destination","value","readUInt32BE","writeUInt32BE","readUInt8","writeUInt8","CursorColumns","_nextVisibleColumn","codePoint","visibleColumn","tabSize","nextRenderTabStop","strings","visibleColumnFromColumn","lineContent","column","textLen","Math","min","length","text","substring","iterator","result","eol","nextGraphemeLength","columnFromVisibleColumn","lineContentLength","beforeVisibleColumn","beforeColumn","afterVisibleColumn","afterColumn","nextIndentTabStop","indentSize","prevRenderTabStop","max","prevIndentTabStop","editorLineHighlight","registerColor","nls","editorLineHighlightBorder","dark","light","hcDark","hcLight","contrastBorder","editorCursorForeground","activeContrastBorder","editorFindMatchHighlight","Color","black","white","editorCursorBackground","editorMultiCursorPrimaryForeground","editorMultiCursorPrimaryBackground","editorMultiCursorSecondaryForeground","editorMultiCursorSecondaryBackground","editorWhitespaces","editorLineNumbers","deprecatedEditorIndentGuides","deprecatedEditorActiveIndentGuides","editorIndentGuide1","editorIndentGuide2","editorIndentGuide3","editorIndentGuide4","editorIndentGuide5","editorIndentGuide6","editorActiveIndentGuide1","editorActiveIndentGuide2","editorActiveIndentGuide3","editorActiveIndentGuide4","editorActiveIndentGuide5","editorActiveIndentGuide6","deprecatedEditorActiveLineNumber","editorDimmedLineNumber","editorOverviewRulerBorder","lightgrey","editorOverviewRulerBackground","editorUnnecessaryCodeOpacity","editorBackground","fromHex","transparent","ghostTextForeground","rulerRangeDefault","RGBA","overviewRulerRangeHighlight","overviewRulerError","overviewRulerWarning","editorWarningForeground","editorWarningBorder","overviewRulerInfo","editorInfoForeground","editorInfoBorder","editorBracketHighlightingForeground1","editorBracketHighlightingForeground2","editorBracketHighlightingForeground3","editorBracketHighlightingForeground4","editorBracketHighlightingForeground5","editorBracketHighlightingForeground6","editorBracketHighlightingUnexpectedBracketForeground","editorBracketPairGuideBackground1","editorBracketPairGuideBackground2","editorBracketPairGuideBackground3","editorBracketPairGuideBackground4","editorBracketPairGuideBackground5","editorBracketPairGuideBackground6","editorBracketPairGuideActiveBackground1","editorBracketPairGuideActiveBackground2","editorBracketPairGuideActiveBackground3","editorBracketPairGuideActiveBackground4","editorBracketPairGuideActiveBackground5","editorBracketPairGuideActiveBackground6","editorWarningBackground","registerThemingParticipant","theme","collector","background","getColor","lineHighlight","imeBackground","isTransparent","addRule","concat","normalizeIndentation","str","insertSpaces","firstNonWhitespaceIndex","spacesCnt","i","charAt","tabsCnt","floor","_normalizeIndentationFromWhitespace","_utf16LE_TextDecoder","_utf16BE_TextDecoder","_platformTextDecoder","getUTF16LE_TextDecoder","getPlatformTextDecoder","platform","decodeUTF16LE","len","view","Uint16Array","resultLen","charCode","String","fromCharCode","join","compatDecodeUTF16LE","StringBuilder","capacity","_capacity","_buffer","_completedStrings","_bufferLength","reset","build","_flushBuffer","_buildBuffer","bufferString","appendCharCode","remainingSpace","appendASCIICharCode","appendString","strLen","charCodeAt","escapeNewLine","replace","TextChange","oldLength","oldText","oldEnd","oldPosition","newLength","newText","newEnd","newPosition","_writeStringSize","_writeString","b","_readString","writeSize","write","read","dest","push","compressConsecutiveTextChanges","prevEdits","currEdits","TextChangeCompressor","compress","_prevEdits","_currEdits","_result","_resultLen","_prevLen","_prevDeltaOffset","_currLen","_currDeltaOffset","prevIndex","currIndex","prevEdit","_getPrev","currEdit","_getCurr","_acceptCurr","_acceptPrev","e1","e2","_splitCurr","_splitPrev","mergePrev","mergeCurr","merged","_merge","_removeNoOps","_rebaseCurr","_rebasePrev","prevDeltaOffset","currDeltaOffset","edit","preText","substr","postText","edits","prev","curr","EDITOR_MODEL_DEFAULTS","detectIndentation","trimAutoWhitespace","largeFileOptimizations","bracketPairColorizationOptions","enabled","independentColorPoolPerBracketType","IndentAction","StandardAutoClosingPairConditional","_neutralCharacter","_neutralCharacterSearched","open","close","_inString","_inComment","_inRegEx","Array","isArray","notIn","isOK","standardToken","shouldAutoClose","context","getTokenCount","tokenIndex","findTokenIndexAtOffset","standardTokenType","getStandardTokenType","_findNeutralCharacterInRange","toCharCode","character","includes","findNeutralCharacter","AutoClosingPairs","autoClosingPairs","autoClosingPairsOpenByStart","Map","autoClosingPairsOpenByEnd","autoClosingPairsCloseByStart","autoClosingPairsCloseByEnd","autoClosingPairsCloseSingleChar","pair","appendEntry","target","key","has","get","set","CharacterPairSupport","config","_autoClosingPairs","map","el","brackets","__electricCharacterSupport","docComment","_autoCloseBeforeForQuotes","autoCloseBefore","DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES","_autoCloseBeforeForBrackets","DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS","_surroundingPairs","surroundingPairs","getAutoClosingPairs","getAutoCloseBeforeSet","forQuotes","getSurroundingPairs","_CharacterPairSupport","BracketElectricCharacterSupport","richEditBrackets","_richEditBrackets","getElectricCharacters","bracket","lastChar","distinct","onElectricCharacter","ignoreBracketsInToken","reversedBracketRegex","reversedRegex","getLineContent","r","BracketsUtils","findPrevBracketInRange","bracketText","startColumn","endColumn","toLowerCase","textIsOpenBracket","textBeforeBracket","getActualLineContentBefore","test","matchOpenBracket","resetGlobalRegex","reg","global","lastIndex","IndentRulesSupport","indentationRules","_indentationRules","shouldIncrease","increaseIndentPattern","shouldDecrease","decreaseIndentPattern","shouldIndentNextLine","indentNextLinePattern","shouldIgnore","unIndentedLinePattern","getIndentMetadata","ret","OnEnterSupport","opts","_brackets","forEach","openRegExp","_createOpenBracketRegExp","closeRegExp","_createCloseBracketRegExp","_regExpRules","onEnterRules","onEnter","autoIndent","previousLineText","beforeEnterText","afterEnterText","rule","beforeText","afterText","every","obj","action","indentAction","IndentOutdent","Indent","_safeRegExp","def","RegExp","err","onUnexpectedError","LanguageBracketsConfiguration","languageId","bracketPairs","filterValidBrackets","openingBracketInfos","CachedFunction","closing","Set","info","OpeningBracketKind","closingBracketInfos","opening","openingColorized","ClosingBracketKind","add","colorizedBracketPairs","filter","p","_openingBrackets","cachedValues","_ref","k","v","_closingBrackets","_ref2","openingBrackets","values","closingBrackets","getOpeningBracketInfo","getClosingBracketInfo","getBracketInfo","getBracketRegExp","options","keys","createBracketOrRegExp","_ref3","BracketKindBase","openedBrackets","super","isOpeningBracket","openingColorizedBrackets","closes","other","closesColorized","getOpeningBrackets","__decorate","decorators","desc","d","c","arguments","Object","getOwnPropertyDescriptor","Reflect","decorate","defineProperty","__param","paramIndex","decorator","LanguageConfigurationServiceChangeEvent","affects","ILanguageConfigurationService","createDecorator","LanguageConfigurationService","Disposable","configurationService","languageService","_registry","_register","LanguageConfigurationRegistry","onDidChangeEmitter","Emitter","onDidChange","event","configurations","languageConfigKeys","customizedLanguageConfigKeys","onDidChangeConfiguration","e","globalConfigChanged","change","some","localConfigChanged","overrides","overrideLangName","clear","fire","undefined","isRegisteredLanguageId","delete","register","configuration","priority","getLanguageConfiguration","registry","languageConfig","ResolvedLanguageConfiguration","customizedConfig","getValue","overrideIdentifier","validateBracketPairs","getCustomizedLanguageConfig","data","combineLanguageConfigurations","underlyingConfig","computeConfig","IConfigurationService","ILanguageService","getIndentationAtPosition","model","lineNumber","lineText","indentation","ComposedLanguageConfiguration","_resolved","_entries","_order","entry","LanguageConfigurationContribution","toDisposable","splice","getResolvedConfiguration","_resolve","sort","cmp","configs","comments","wordPattern","folding","order","a","LanguageConfigurationChangeEvent","_onDidChange","PLAINTEXT_LANGUAGE_ID","offSide","entries","disposable","dispose","_electricCharacter","_onEnterSupport","_handleComments","characterPair","wordDefinition","DEFAULT_WORD_REGEXP","indentRulesSupport","foldingRules","bracketsNew","getWordDefinition","ensureValidWordDefinition","RichEditBrackets","electricCharacter","conf","commentRule","lineComment","lineCommentToken","blockComment","blockStart","blockEnd","blockCommentStartToken","blockCommentEndToken","registerSingleton","NullState","clone","equals","nullTokenize","state","TokenizationResult","Token","nullTokenizeEncoded","tokens","Uint32Array","EncodedTokenizationResult","createScopedLineTokens","tokenCount","getCount","desiredLanguageId","getLanguageId","lastTokenIndex","firstTokenIndex","ScopedLineTokens","getStartOffset","getEndOffset","firstCharOffset","lastCharOffset","_scopedLineTokensBrand","_actual","_firstTokenIndex","_lastTokenIndex","_lastCharOffset","languageIdCodec","getLineLength","toIViewLineTokens","sliceAndInflate","RichEditBracket","index","forwardRegex","_richEditBracketBrand","_openSet","_toSet","_closeSet","isOpen","isClose","arr","element","_richEditBracketsBrand","N","group","areOverlapping","aOpen","aClose","bOpen","bClose","mergeGroups","g1","g2","newG","oldG","j","g","currentOpen","currentClose","groupFuzzyBrackets","currentIndex","pieces","collectSuperstrings","unique","lengthcmp","reverse","getRegexForBracketPair","toReversedString","getReversedRegexForBracketPair","getRegexForBrackets","getReversedRegexForBrackets","textIsBracket","maxBracketLength","indexOf","seen","prepareBracketForRegExp","insertWordBoundaries","regexStr","lastInput","lastOutput","stringBuilder","_findPrevBracketInText","reversedText","m","match","matchOffset","matchLength","absoluteMatchOffset","Range","startOffset","endOffset","reversedSubstr","findNextBracketInText","bracketRegex","findNextBracketInRange","BaseAstNode","_length","PairAstNode","create","openingBracket","child","closingBracket","lengthAdd","missingOpeningBracketIds","SmallImmutableSet","getEmpty","kind","listHeight","childrenLength","getChild","idx","Error","children","canBeReused","openBracketIds","intersects","deepClone","computeMinIndentation","textModel","Number","MAX_SAFE_INTEGER","ListAstNode","create23","item1","item2","item3","immutable","missingBracketIds","merge","Immutable23ListAstNode","TwoThreeListAstNode","ImmutableArrayListAstNode","lengthZero","_missingOpeningBracketIds","cachedMinIndentation","throwIfImmutable","makeLastElementMutable","childCount","lastChild","mutable","toMutable","setChild","makeFirstElementMutable","firstChild","lastLength","BugIndicatingError","handleChildrenChanged","count","unopenedBrackets","minIndentation","childOffset","_item3","_item1","_item2","node","appendChildOfSameHeight","unappendChild","prependChildOfSameHeight","unprependChild","ArrayListAstNode","_children","item","pop","unshift","shift","emptyArray","ImmutableLeafAstNode","TextAstNode","_openedBracketIds","start","lengthToObj","startLineNumber","columnCount","lineCount","endLineNumber","lengthGetLineCount","firstNonWsColumn","getLineFirstNonWhitespaceColumn","getOptions","BracketAstNode","bracketInfo","bracketIds","InvalidBracketAstNode","openedBracketIds","TextEditInfo","fromModelContentChanges","changes","range","lift","positionToLength","getStartPosition","getEndPosition","lengthOfString","BeforeEditPositionMapper","nextEditIdx","deltaOldToNewLineCount","deltaOldToNewColumnCount","deltaLineIdxInOld","TextEditInfoCache","getOffsetBeforeChange","adjustNextEdit","translateCurToOld","getDistanceToNextChange","nextEdit","nextChangeOffset","translateOldToCur","offsetObj","lengthDiffNonNegative","oldOffsetObj","toLength","newOffset","nextEditEndOffsetInCur","endOffsetAfterObj","lengthLessThanEqual","nextEditEndOffsetInCurObj","nextEditEndOffsetBeforeInCurObj","endOffsetBeforeObj","lineDelta","previousColumnDelta","columnDelta","textLength","BracketTokens","createFromLanguage","denseKeyProvider","getId","getKey","openingTextId","identityKeyProvider","hasRegExp","_regExpGlobal","getRegExpStr","isEmpty","escaped","escapeRegExpCharacters","regExpGlobal","regExpStr","getToken","findClosingTokenText","openingBracketIds","closingText","size","LanguageAgnosticBracketTokens","languageIdToBracketTokens","didLanguageChange","getSingleLanguageBracketTokens","singleLanguageBracketTokens","combineTextEditInfos","textEditInfoFirst","textEditInfoSecond","s0ToS1Map","ArrayQueue","toLengthMapping","s1ToS2Map","modified","lengthBefore","lengthAfter","curItem","dequeue","nextS0ToS1MapWithS1LengthOf","s1Length","takeWhile","lengthIsZero","remainingItem","splitAt","LengthMapping","pushEdit","lengthEquals","lastResult","s0offset","s1ToS2","s0Length","sumLengths","s","s0EndOffset","s1","s0startOffset","remainingLengthAfter","textEditInfos","lastOffset","textEditInfo","spaceLength","lengthDiff","startLineCount","startColumnCount","endLineCount","endColumnCount","factor","l","TextLength","lengthGetColumnCountIfZeroLineCount","l1","l2","items","lengthFn","reduce","length1","length2","lineCount1","lineCount2","colCount2","lengthLessThan","lengthGreaterThanEqual","position","lengthsToRange","lengthStart","lengthEnd","colCount","lines","splitLines","concat23TreesOfSameHeight","createImmutableLists","heightDiff","node1","node2","abs","list","nodeToAppend","curNode","parents","nodeToAppendOfCorrectHeight","parent","append","nodeToPrependOfCorrectHeight","prepend","NodeReader","nextNodes","offsets","idxs","readLongestNodeAt","predicate","lastOrUndefined","curNodeOffset","nextNodeAfterCurrent","nextChildIdx","getNextChildIdx","currentOffset","currentNode","curIdx","parseDocument","tokenizer","oldNode","Parser","_itemsConstructed","_itemsFromCache","oldNodeReader","positionMapper","parseList","level","tryReadChildFromCache","token","peek","parseChild","readNode","height","slice","first","second","concat23Trees","maxCacheableLength","cachedNode","skip","astNode","nextToken","bracketId","emptyArr","additionalItems","cached","cache","empty","keyProvider","newItem","newItems","_SmallImmutableSet","DenseKeyProvider","existing","TextBufferTokenizer","bracketTokens","reader","NonPeekableTextBufferTokenizer","_offset","didPeek","peeked","textBufferLineCount","getLineCount","textBufferLastLineLength","setPosition","lineIdx","line","lineCharOffset","lineTokens","lineTokenOffset","peekedToken","tokenization","getLineTokens","startLineIdx","startLineCharOffset","lengthHeuristic","peekedBracketToken","tokenMetadata","getMetadata","isOther","TokenMetadata","getTokenType","containsBracketType","containsBalancedBrackets","regexp","exec","FastTokenizer","curLineCount","lastLineBreakOffset","lastTokenEndOffset","lastTokenEndLine","smallTextTokens0Line","smallTextTokens1Line","curOffset","NotSupportedError","uriGetComparisonKey","resource","SingleModelEditStackData","beforeCursorState","alternativeVersionId","getAlternativeVersionId","getModelEOL","beforeVersionId","afterVersionId","beforeEOL","afterEOL","afterCursorState","textChanges","_writeSelectionsSize","selections","_writeSelections","selection","selectionStartLineNumber","selectionStartColumn","positionLineNumber","positionColumn","_readSelections","Selection","serialize","necessarySize","deserialize","changeCount","SingleModelEditStackElement","type","URI","isUri","uri","label","code","_data","matchesResource","setModel","canAppend","undo","_applyUndo","redo","_applyRedo","heapSize","MultiModelEditStackElement","resources","_editStackElementsArr","editStackElement","editStackElements","_isOpen","_editStackElementsMap","_delegate","prepareUndoRedo","split","basename","getEOL","isEditStackElement","EditStack","undoRedoService","_model","_undoRedoService","pushStackElement","lastElement","getLastElement","popStackElement","removeElements","_getOrCreateEditStackElement","newElement","pushElement","pushEOL","setEOL","pushEditOperation","editOperations","cursorStateComputer","inverseEditOperations","applyEdits","_computeCursorState","op","textChange","GuidesTextModelPart","TextModelPart","languageConfigurationService","_computeIndentLevel","lineIndex","computeIndentLevel","getActiveIndentGuide","minLineNumber","maxLineNumber","assertNotDisposed","Boolean","up_aboveContentLineIndex","up_aboveContentLineIndent","up_belowContentLineIndex","up_belowContentLineIndent","up_resolveIndents","indent","down_aboveContentLineIndex","down_aboveContentLineIndent","down_belowContentLineIndex","down_belowContentLineIndent","down_resolveIndents","goUp","goDown","initialIndent","distance","upLineNumber","downLineNumber","upLineIndentLevel","currentIndent","ceil","_getIndentLevelForWhitespaceLine","downLineIndentLevel","getLinesBracketGuides","activePosition","includeSingleLinePairs","getBracketPairsInRangeWithMinIndentation","getLineMaxColumn","toArray","activeBracketPairRange","_findLast","bracketsContainingActivePosition","getBracketPairsInRange","fromPositions","bp","strictContainsPosition","findLast","colorProvider","BracketPairGuidesClassNames","closingBracketRange","isActive","equalsRange","includeInactive","className","getInlineClassName","nestingLevel","nestingLevelOfEqualBracketType","highlightActive","activeClassName","openingBracketRange","end","horizontalGuides","HorizontalGuidesState","Enabled","EnabledForActive","IndentGuide","IndentGuideHorizontalLine","endVisibleColumn","getVisibleColumnFromPosition","startVisibleColumn","guideVisibleColumn","minVisibleColumnIndentation","renderHorizontalEndLineAtTheBottom","visibleGuideStartLineNumber","visibleGuideEndLineNumber","guides","getLinesIndentGuides","aboveContentLineIndex","aboveContentLineIndent","belowContentLineIndex","belowContentLineIndent","resultIndex","getInlineClassNameOfLevel","BracketInfo","isInvalid","BracketPairInfo","bracketPairNode","openingBracketInfo","BracketPairWithMinIndentationInfo","BracketPairsTree","didChangeEmitter","queuedTextEditsForInitialAstWithoutTokens","queuedTextEdits","hasTokens","backgroundTokenizationState","initialAstWithoutTokens","astWithTokens","parseDocumentFromTextBuffer","handleDidChangeBackgroundTokenizationState","wasUndefined","handleDidChangeTokens","ranges","fromLineNumber","toLineNumber","handleEdits","handleContentChanged","tokenChange","flushQueue","previousAst","previousAstClone","getBracketsInRange","onlyColorizedBrackets","CallbackIterable","cb","collectBrackets","includeMinIndentation","startLength","endLength","CollectBracketPairsContext","collectBracketPairs","getFirstBracketAfter","getFirstBracketBefore","nodeOffsetStart","nodeOffsetEnd","lengths","levelPerBracketType","parentPairIsIncomplete","whileLoop","colorize","levelPerBracket","shouldContinue","_node$child","openingBracketEnd","BracketPairsTextModelPart","canBuildAST","getValueLength","bracketPairsTree","MutableDisposable","bracketsRequested","handleLanguageConfigurationServiceChange","_this$bracketPairsTre","object","updateBracketPairsTree","handleDidChangeOptions","handleDidChangeLanguage","handleDidChangeContent","_this$bracketPairsTre2","_this$bracketPairsTre3","_this$bracketPairsTre4","store","DisposableStore","_this$bracketPairsTre5","_this$bracketPairsTre6","_this$bracketPairsTre7","findMatchingBracketUp","_bracket","_position","maxDuration","validatePosition","getLanguageIdAtPosition","closingBracketInfo","bracketPair","bracketsSupport","stripBracketSearchCanceled","_findMatchingBracketUp","createTimeBasedContinueBracketSearchPredicate","matchBracket","containsPosition","findLastMaxBy","compareBy","compareRangesUsingStarts","continueSearchPredicate","_matchBracket","_establishBracketSearchOffsets","modeBrackets","currentLanguageId","searchStartOffset","tokenEndOffset","searchEndOffset","tokenStartOffset","currentModeBrackets","bestResult","foundBracket","foundBracketText","_matchFoundBracket","BracketSearchCanceled","prevTokenIndex","prevModeBrackets","matched","_findMatchingBracketDown","totalCallCount","searchPrevMatchingBracketInRange","INSTANCE","hitText","prevSearchInToken","searchInToken","searchNextMatchingBracketInRange","findPrevBracket","_this$bracketPairsTre8","bracketConfig","tokenLanguageId","_toFoundBracket","findNextBracket","_this$bracketPairsTre9","findEnclosingBrackets","strictContainsRange","savedCounts","counts","resetCounts","tmp","searchInRange","getValueInRange","startTime","Date","now","_searchCanceledBrand","_BracketSearchCanceled","ColorizedBracketPairsDecorationProvider","ColorProvider","colorizationOptions","getDecorationsInRange","ownerId","filterOutValidation","onlyMinimapDecorations","id","description","inlineClassName","getAllDecorations","unexpectedClosingBracketClassName","colors","colorValues","color","SpacesDiffResult","spacesDiff","looksLikeAlignment","aLength","bLength","aSpacesCnt","aTabsCount","bSpacesCnt","bTabsCount","tabsDiff","guessIndentation","defaultTabSize","defaultInsertSpaces","linesCount","linesIndentedWithTabsCount","linesIndentedWithSpacesCount","previousLineIndentation","ALLOWED_TAB_SIZE_GUESSES","spacesDiffCount","currentLineLength","currentLineText","useCurrentLineText","currentLineHasContent","currentLineIndentation","currentLineSpacesCount","currentLineTabsCount","lenJ","getLineCharCode","currentSpacesDiff","tabSizeScore","possibleTabSize","possibleTabSizeScore","getNodeColor","metadata","setNodeColor","getNodeIsVisited","setNodeIsVisited","getNodeIsForValidation","setNodeIsForValidation","getNodeIsInGlyphMargin","setNodeIsInGlyphMargin","_setNodeStickiness","stickiness","setCollapseOnReplaceEdit","IntervalNode","left","right","delta","maxEnd","cachedVersionId","cachedAbsoluteStart","cachedAbsoluteEnd","versionId","setOptions","glyphMarginClassName","collapseOnReplaceEdit","setCachedOffsets","absoluteStart","absoluteEnd","detach","SENTINEL","IntervalTree","root","requestNormalizeDelta","intervalSearch","filterOwnerId","onlyMarginDecorations","T","intervalStart","intervalEnd","nodeMaxEnd","nodeStart","nodeEnd","include","search","collectNodesFromOwner","collectNodesPostOrder","insert","rbTreeInsert","_normalizeDeltaIfNecessary","rbTreeDelete","resolveNode","initialNode","acceptReplace","forceMoveMarkers","nodesOfInterest","searchForEditing","editDelta","recomputeMaxEnd","noOverlapReplace","nodeAcceptEdit","normalizeDelta","adjustMarkerBeforeColumn","markerOffset","markerStickToPreviousCharacter","checkOffset","moveSemantics","nodeStickiness","getNodeStickiness","startStickToPreviousCharacter","endStickToPreviousCharacter","deletingCnt","insertingCnt","commonLength","startDone","endDone","getCollapseOnReplaceEdit","deltaColumn","newNode","z","x","zAbsoluteStart","zAbsoluteEnd","intervalCompare","treeInsert","recomputeMaxEndWalkToRoot","y","leftRotate","rightRotate","leftest","resetSentinel","yWasRed","w","computeMaxEnd","leftMaxEnd","rightMaxEnd","aStart","aEnd","bStart","bEnd","TreeNode","piece","size_left","lf_left","next","righttest","calculateSize","calculateLF","lineFeedCnt","tree","rbDelete","recomputeTreeMetadata","newSizeLeft","newLFLeft","lf_delta","updateTreeMetadata","fixInsert","lineFeedCntDelta","AverageBufferSize","createUintArray","LineStarts","lineStarts","cr","lf","crlf","isBasicASCII","createLineStartsFast","readonly","rLength","chr","Piece","bufferIndex","StringBuffer","PieceTreeSnapshot","BOM","_pieces","_tree","_BOM","_index","iterate","getPieceContent","PieceTreeSearchCache","limit","_limit","_cache","nodePos","nodeStartOffset","get2","nodeStartLineNumber","nodePosition","validate","hasInvalidVal","newArr","PieceTreeBase","chunks","eolNormalized","_buffers","_lastChangeBufferPos","_lineCnt","_EOL","_EOLLength","_EOLNormalized","lastNode","rbInsertRight","_searchCache","_lastVisitedLine","computeBufferMetadata","normalizeEOL","averageBufferSize","tempChunk","tempChunkLen","getNodeContent","newEOL","createSnapshot","getOffsetAt","leftLen","getAccumulatedValue","getPositionAt","lfCnt","originalOffset","out","getIndexOf","Position","remainder","startPosition","nodeAt2","endPosition","getValueInRange2","offsetInBuffer","getLinesContent","linesLength","currentLine","danglingCR","pieceLength","pieceStartLine","pieceEndLine","pieceStartOffset","getLength","getLineRawContent","_getCharCode","matchingNode","targetOffset","findMatchesInNode","searcher","startCursor","endCursor","searchData","captureMatches","limitResultCount","startOffsetInBuffer","searchText","_wordSeparators","positionInBuffer","getLineFeedCnt","retStartColumn","retEndColumn","createFindMatch","findMatchesLineByLine","searchRange","Searcher","wordSeparators","regex","lineBreakCnt","nextLineStartOffset","_findMatchesInLine","deltaOffset","simpleSearch","searchString","searchStringLen","lastMatchIndex","isValidMatch","FindMatch","nodeAt","insertPosInBuffer","appendToNode","insertContentToNodeLeft","nodesToDel","newRightPiece","shouldCheckCRLF","endWithCR","nodeCharCodeAt","newStart","startWithLF","previousPos","deleteNodeTail","newPieces","createNewPieces","tmpNode","deleteNodes","insertContentToNodeRight","rbInsertLeft","cnt","startNode","endNode","startSplitPosInBuffer","endSplitPosInBuffer","validateCRLFWithPrevNode","deleteNodeHead","validateCRLFWithNextNode","shrinkNode","nPiece","adjustCarriageReturnFromNext","low","high","mid","midStop","midStart","previousCharOffset","cursor","nodes","splitText","endIndex","endPos","newPiece","prevAccumulatedValue","accumulatedValue","originalLineNumber","pos","lineCnt","realLineCnt","expectedLineStartIndex","originalLFCnt","originalEndOffset","newEndOffset","newLineFeedCnt","size_delta","originalStartOffset","originalStartPos","originalEndPos","oldLFCnt","hitCRLF","prevStartOffset","oldLineFeedCnt","prevAccumualtedValue","offsetOfNode","val","nextNode","fixCRLF","prevNewLength","prevNewLFCnt","callback","leftRet","prevNode","PieceTreeTextBuffer","containsRTL","containsUnusualLineTerminators","_onDidChangeContent","_mightContainNonBasicASCII","_mightContainRTL","_mightContainUnusualLineTerminators","_pieceTree","mightContainRTL","mightContainUnusualLineTerminators","resetMightContainUnusualLineTerminators","mightContainNonBasicASCII","getBOM","preserveBOM","getRangeAt","lineEnding","_getEndOfLine","getValueLengthInRange","eolOffsetCompensation","desiredEOL","actualEOL","getCharacterCountInRange","fromOffset","toOffset","getLineLastNonWhitespaceColumn","rawOperations","recordTrimAutoWhitespace","computeUndoEdits","canReduceOperations","operations","_isTracked","validatedRange","textMightContainNonBasicASCII","validText","eolCount","firstLineLength","lastLineLength","strEOL","countEOL","bufferEOL","sortIndex","identifier","rangeOffset","rangeLength","isAutoWhitespaceEdit","_sortOpsAscending","hasTouchingRanges","rangeEnd","nextRangeStart","isBeforeOrEqual","isBefore","_reduceOperations","reverseRanges","_getInverseEditRanges","newTrimAutoWhitespaceCandidates","reverseRange","currentLineContent","oldContent","reverseOperations","reverseRangeDeltaOffset","bufferText","reverseRangeOffset","contentChanges","_doApplyEdits","trimAutoWhitespaceLineNumbers","prevContent","ApplyEditsResult","_toSingleEditOperation","firstEditRange","lastEditRange","entireEditRange","lastEndLineNumber","lastEndColumn","operation","_sortOpsDescending","contentChangeRange","prevOpEndLineNumber","prevOpEndColumn","prevOp","resultRange","compareRangesUsingEnds","PieceTreeTextBufferFactory","_chunks","_bom","_cr","_lf","_crlf","_containsRTL","_containsUnusualLineTerminators","_isBasicASCII","_normalizeEOL","_getEOL","defaultEOL","totalEOLCount","totalCRCount","newLineStart","textBuffer","PieceTreeTextBufferBuilder","_hasPreviousChar","_previousChar","_tmpLineStarts","acceptChunk","chunk","_acceptChunk1","allowEmptyStrings","_acceptChunk2","createLineStarts","finish","_finish","lastChunk","newLineStarts","FixedArray","_default","_store","before","after","insertArr","arrayFill","deleteIndex","deleteCount","insertIndex","insertCount","arrayInsert","ContiguousMultilineTokens","_startLineNumber","_tokens","appendLineTokens","ContiguousMultilineTokensBuilder","last","finalize","TokenizerWithStateStore","tokenizationSupport","initialState","getInitialState","TrackingTokenizationStateStore","getStartState","getFirstInvalidLine","TokenizerWithStateStoreAndTextModel","_textModel","_languageIdCodec","updateTokensUntilLine","builder","lineToTokenize","safeTokenize","startState","setEndState","endState","getTokenTypeIfInsertingCharacter","lineStartState","LineTokens","tokenizeLineWithEdit","curLineContent","newLineContent","hasAccurateTokensForLine","getFirstInvalidEndStateLineNumberOrMax","isCheapToTokenize","firstInvalidLineNumber","tokenizeHeuristically","heuristicTokens","guessStartState","nonWhitespaceColumn","likelyRelevantLines","newNonWhitespaceIndex","_tokenizationStateStore","TokenizationStateStore","_invalidEndStatesLineNumbers","RangePriorityQueueImpl","addRange","OffsetRange","getEndState","acceptChange","newLineCount","addRangeAndResize","endLineNumberExclusive","acceptChanges","LineRange","invalidateEndStateRange","getFirstInvalidEndStateLineNumber","allStatesValid","_lineEndStates","oldState","_ranges","findIndex","contains","endExclusive","idxFirstMightBeIntersecting","idxFirstIsAfter","newRange","endEx","hasEOL","tokenizeEncoded","encodeLanguageId","convertToEndOffset","DefaultBackgroundTokenizer","_tokenizerWithStateStore","_backgroundTokenStore","_isDisposed","_isScheduled","handleChanges","_beginBackgroundTokenization","isAttachedToEditor","_hasLinesToTokenize","runWhenGlobalIdle","deadline","_backgroundTokenizeWithDeadline","endTime","timeRemaining","execute","_backgroundTokenizeForAtLeast1ms","setTimeout0","sw","StopWatch","elapsed","_tokenizeOneInvalidLine","setTokens","checkFinished","_this$_tokenizerWithS","firstInvalidLine","backgroundTokenizationFinished","requestTokens","AttachedViews","_onDidChangeVisibleRanges","onDidChangeVisibleRanges","_views","attachView","AttachedViewImpl","detachView","handleStateChange","setVisibleLines","visibleLines","stabilized","visibleLineRanges","AttachedViewHandler","lineRanges","_lineRanges","_refreshTokens","runner","RunOnceScheduler","update","_computedLineRanges","cancel","schedule","AbstractTokens","_backgroundTokenizationState","_onDidChangeBackgroundTokenizationState","onDidChangeBackgroundTokenizationState","_onDidChangeTokens","onDidChangeTokens","tokenizeIfCheap","forceTokenization","TreeSitterTokens","_treeSitterService","_tokenizationSupport","_initialize","newLanguage","_lastLanguageId","TreeSitterTokenizationRegistry","content","rawTokens","createEmpty","resetTokenization","semanticTokensApplied","handleDidChangeAttached","isFlush","getParseResult","EMPTY_LINE_TOKENS","ContiguousTokensEditing","deleteBeginning","toChIndex","deleteEnding","fromChIndex","toUint32Array","lineTextLength","tokensCount","fromTokenIndex","findIndexInTokensArray","fromTokenStartOffset","lastEnd","subarray","_otherTokens","myTokens","otherTokens","otherTokensCount","chIndex","ContiguousTokensStore","_lineTokens","_len","flush","getTokens","topLevelLanguageId","rawLineTokens","getDefaultMetadata","_massageTokens","hasDifferentLanguageId","_ensureLine","_deleteLines","_insertLines","arrays","checkEquality","oldTokens","_equals","_a","_b","acceptEdit","_acceptDeleteRange","_acceptInsertText","firstLineIndex","lastLineIndex","lastLineTokens","setMultilineTokens","minChangedLineNumber","maxChangedLineNumber","hasChange","SparseTokensStore","_isComplete","isComplete","setPartial","_range","_firstRange","getRange","_lastRange","plusRange","insertPosition","removeTokens","addSparseTokens","aTokens","bTokens","_findFirstPieceWithLine","aLen","bLen","aIndex","lastEndOffset","emitToken","bIndex","bStartCharacter","getStartCharacter","bEndCharacter","getEndCharacter","bMetadata","bMask","aMask","aMergeIndex","firstCharCode","TokenizationTextModelPart_1","TokenizationTextModelPart","_bracketPairsTextModelPart","_languageId","_attachedViews","_languageService","_languageConfigurationService","_semanticTokens","_onDidChangeLanguage","onDidChangeLanguage","_onDidChangeLanguageConfiguration","onDidChangeLanguageConfiguration","_tokensDisposables","Event","changedLanguages","createPreferredTokenProvider","createGrammarTokens","GrammarTokens","createTreeSitterTokens","createTokens","useTreeSitter","_this$_tokens","needsReset","_emitModelTokensChangedEvent","isEolChange","validateLineNumber","syntacticTokens","_isDisposing","setSemanticTokens","hasCompleteSemanticTokens","hasSomeSemanticTokens","setPartialSemanticTokens","changedRange","validateRange","getWordAtPosition","rbStartOffset","rbEndOffset","_findLanguageBoundaries","rightBiasedWord","getWordAtText","lbStartOffset","lbEndOffset","leftBiasedWord","getWordUntilPosition","wordAtPosition","word","setLanguageId","oldLanguage","ITreeSitterParserService","attachedViews","_tokenizer","_defaultBackgroundTokenizer","_backgroundTokenizer","_debugBackgroundTokenizer","_attachedViewStates","DisposableMap","TokenizationRegistry","refreshRanges","deleteAndDispose","_this$_debugBackgroun","fireTokenChangeEvent","_debugBackgroundTokens","_debugBackgroundStates","initializeTokenization","isTooLargeForTokenization","firstInvalidEndStateLineNumber","_this$_tokenizer","createBackgroundTokenizer","backgroundTokenizerShouldOnlyVerifyTokens","_this$_debugBackgroun2","_this$_debugBackgroun3","refreshAllVisibleLineTokens","_this$_defaultBackgro","_this$_debugBackgroun5","_this$_defaultBackgro2","_this$_debugBackgroun4","joinMany","_","refreshRange","_this$_defaultBackgro3","changedTokens","_this$_backgroundToke","_this$_tokenizer2","_this$_defaultBackgro4","_this$_debugBackgroun6","backgroundResult","reportMismatchingTokens","validatedPosition","TextModel_1","createTextBuffer","factory","createTextBufferFactory","snapshot","createTextBufferFactoryFromSnapshot","MODEL_ID","TextModelSnapshot","_source","_eos","resultCnt","resultLength","invalidFunc","TextModel","_TextModel","resolveOptions","guessedIndentation","_tokenizationTextModelPart","onDidChangeContent","listener","_eventEmitter","slowEvent","contentChangedEvent","onDidChangeContentOrInjectedText","combinedDisposable","fastEvent","_onDidChangeInjectedText","__isDisposing","_bracketPairs","_guidesTextModelPart","languageIdOrSelection","creationOptions","associatedResource","instantiationService","_onWillDispose","onWillDispose","_onDidChangeDecorations","DidChangeDecorationsEmitter","affectedInjectedTextLines","handleBeforeFireDecorationsChangedEvent","onDidChangeDecorations","_onDidChangeOptions","onDidChangeOptions","_onDidChangeAttached","onDidChangeAttached","DidChangeContentEmitter","_languageSelectionListener","_deltaDecorationCallCnt","isForSimpleWidget","_associatedResource","parse","_attachedEditorCount","_bufferDisposable","_options","_setLanguage","_decorationProvider","createInstance","bufferLineCount","bufferTextLength","_isTooLargeForTokenization","LARGE_FILE_SIZE_THRESHOLD","LARGE_FILE_LINE_COUNT_THRESHOLD","_isTooLargeForHeapOperation","LARGE_FILE_HEAP_OPERATION_THRESHOLD","_isTooLargeForSyncing","_MODEL_SYNC_LIMIT","_versionId","_alternativeVersionId","_initialUndoRedoSnapshot","_instanceId","_lastDecorationId","_decorations","_decorationsTree","DecorationsTrees","_commandManager","_isUndoing","_isRedoing","_trimAutoWhitespaceLines","beginDeferredEmit","endDeferredEmit","requestRichLanguageFeatures","emptyDisposedTextBuffer","None","_assertNotDisposed","_emitContentChangedEvent","rawChange","InternalModelContentChangeEvent","setValue","illegalArgument","_setValueFromTextBuffer","_createContentChanged2","isUndoing","isRedoing","getVersionId","textBufferDisposable","oldFullModelRange","getFullModelRange","oldModelValueLength","_increaseVersionId","ModelRawContentChangedEvent","ModelRawFlush","_onBeforeEOLChange","_onAfterEOLChange","ModelRawEOLChanged","ensureAllNodesHaveRanges","allDecorations","onBeforeAttached","onBeforeDetached","getAttachedEditorCount","isTooLargeForSyncing","isTooLargeForHeapOperation","isDisposed","isDominatedByLongLines","smallLineCharCount","longLineCharCount","lineLength","getFormattingOptions","updateOptions","_newOpts","originalIndentSize","bracketColorizationOptions","newOpts","createChangeEvent","removeUnusualLineTerminators","matches","findMatches","pushEditOperations","getInitialUndoRedoSnapshot","rawPosition","_validatePosition","rawOffset","_overwriteVersionId","_overwriteAlternativeVersionId","newAlternativeVersionId","_overwriteInitialUndoRedoSnapshot","newInitialUndoRedoSnapshot","fullModelRange","fullModelValue","rawRange","getEndOfLineSequence","getLineMinColumn","_validateRangeRelaxedNoAllocations","initialStartLineNumber","initialStartColumn","isNaN","maxColumn","initialEndLineNumber","initialEndColumn","_isValidPosition","validationType","charCodeBefore","_lineNumber","_column","_isValidRange","charCodeBeforeStart","charCodeBeforeEnd","startInsideSurrogatePair","endInsideSurrogatePair","modifyPosition","candidate","rawSearchScope","isRegex","matchCase","searchRanges","searchScope","isIRange","d1","d2","uniqueSearchRanges","matchMapper","areIntersecting","SearchParams","parseSearchRequest","TextModelSearch","findNextMatch","rawSearchStart","searchStart","findPreviousMatch","_validateEditOperation","rawOperation","_validateEditOperations","_pushEditOperations","incomingEdits","editsAreNearCursors","sel","foundEditNearSel","editRange","selIsAbove","selIsBelow","trimLineNumber","maxLineColumn","allowTrimLine","editText","trimRange","resultingAlternativeVersionId","resultingSelection","rangeStart","_applyUndoRedoEdits","oldLineCount","rawContentChanges","deletingLinesCnt","insertingLinesCnt","editingLinesCnt","changeLineCountDelta","currentEditStartLineNumber","firstEditLineNumber","lastInsertedLineNumber","decorationsWithInjectedTextInEditedRange","getInjectedTextInInterval","injectedTextInEditedRange","LineInjectedText","fromDecorations","injectedTextInEditedRangeQueue","editLineNumber","currentEditLineNumber","takeFromEndWhile","decorationsInCurrentLine","ModelRawLineChanged","spliceStartLineNumber","ModelRawLinesDeleted","spliceLineNumber","injectedTexts","newLines","ModelRawLinesInserted","reverseEdits","canUndo","canRedo","lineChangeEvents","_getInjectedTextInLine","ModelInjectedTextChangedEvent","changeDecorations","_changeDecorations","changeAccessor","addDecoration","_deltaDecorationsImpl","changeDecoration","_changeDecorationImpl","changeDecorationOptions","_changeDecorationOptionsImpl","_normalizeOptions","removeDecoration","deltaDecorations","oldDecorations","newDecorations","console","warn","_getTrackedRange","getDecorationRange","_setTrackedRange","newStickiness","TRACKED_RANGE_OPTIONS","removeAllDecorationsWithOwnerId","getDecorationOptions","decorationId","getNodeRange","getLineDecorations","getLinesDecorations","_endLineNumber","decorations","_getDecorationsInRange","pushMany","getOverviewRulerDecorations","getAll","getInjectedTextDecorations","getAllInjectedText","t","getAllMarginDecorations","filterRange","getAllInInterval","oldRange","recordLineAffectedByInjectedText","checkAffectedAndFire","nodeWasInOverviewRuler","overviewRuler","nodeIsInOverviewRuler","nodeRange","movedInOverviewRuler","changedWhetherInjectedText","isOptionsInjectedText","isNodeInjectedText","oldDecorationsIds","suppressEvents","oldDecorationsLen","oldDecorationIndex","newDecorationsLen","newDecorationIndex","internalDecorationId","newDecoration","setLanguage","normalizePosition","affinity","getLineIndentColumn","indentOfLine","DEFAULT_CREATION_OPTIONS","isNodeInOverviewRuler","IUndoRedoService","IInstantiationService","_decorationsTree0","_decorationsTree1","_injectedTextDecorationsTree","host","_ensureNodesHaveRanges","_intervalSearch","r0","r1","r2","showIfCollapsed","overviewRulerOnly","_search","_resolveNode","cleanClassName","DecorationOptions","darkColor","ModelDecorationOverviewRulerOptions","_resolvedColor","Center","_resolveColor","invalidateCachedColor","ModelDecorationGlyphMarginOptions","_options$position","persistLane","ModelDecorationMinimapOptions","_options$sectionHeade","_options$sectionHeade2","sectionHeaderStyle","sectionHeaderText","ModelDecorationInjectedTextOptions","inlineClassNameAffectsLetterSpacing","attachedData","cursorStops","ModelDecorationOptions","createDynamic","_options$blockDoesNot","_options$blockIsAfter","_options$blockPadding","_options$shouldFillLi","_options$hideInCommen","_options$hideInString","blockClassName","blockDoesNotCollapse","blockIsAfterEnd","blockPadding","zIndex","shouldFillLineOnLineBreak","hoverMessage","glyphMarginHoverMessage","lineNumberHoverMessage","isWholeLine","minimap","glyphMargin","linesDecorationsClassName","lineNumberClassName","linesDecorationsTooltip","firstLineDecorationClassName","marginClassName","beforeContentClassName","afterContentClassName","hideInCommentTokens","hideInStringTokens","EMPTY","handleBeforeFire","_affectedInjectedTextLines","_deferredCnt","_shouldFireDeferred","_affectsMinimap","_affectsOverviewRuler","_affectsGlyphMargin","_affectsLineNumber","_this$_affectedInject","doFire","_options$minimap","_options$overviewRule","tryFire","affectsMinimap","affectsOverviewRuler","affectsGlyphMargin","affectsLineNumber","_fastEmitter","_slowEmitter","_deferredEvent","rawContentChangedEvent","chCode","ModelService_1","ModelData","_modelEventListeners","DEFAULT_EOL","DisposedModelInfo","initialUndoRedoSnapshot","time","sharesUndoRedoStack","sha1","ModelService","_ModelService","_configurationService","_resourcePropertiesService","_instantiationService","_onModelAdded","onModelAdded","_onModelRemoved","onModelRemoved","_onModelModeChanged","onModelLanguageChanged","_modelCreationOptionsByLanguageAndResource","_models","_disposedModels","_disposedModelsHeapSize","_updateModelOptions","_readModelOptions","_config$editor","editor","parsedTabSize","parseInt","parsedIndentSize","newDefaultEOL","bracketPairColorization","language","_shouldRestoreUndoStack","getCreationOptions","oldOptionsByLanguageAndResource","modelId","modelData","affectsConfiguration","oldOptions","newOptions","_setModelOptionsForModel","currentOptions","_insertDisposedModel","disposedModelData","_removeDisposedModel","_ensureDisposedModelsHeapSize","maxModelsHeapSize","disposedModels","disposedModel","restoreSnapshot","_createModelData","elements","getElements","sha1Computer","_getSHA1Computer","sha1IsEqual","canComputeSHA1","computeSHA1","past","future","setElementsValidFlag","createModel","languageSelection","getModels","getModel","_schemaShouldMaintainUndoRedoElements","scheme","Schemas","file","vscodeRemote","vscodeUserData","vscodeNotebookCell","getUriComparisonKey","maintainUndoRedoStack","maxMemory","MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK","oldLanguageId","newLanguageId","DefaultModelSHA1Computer","ITextResourcePropertiesService","MAX_MODEL_SIZE","shaComputer","StringSHA1","digest","ITextResourceConfigurationService","changeType","applyInjectedText","lastOriginalOffset","injectedText","decoration","detail","containsEvent","_mergeChangeEvents","horizontalLine","forWrappedLinesAfterColumn","forWrappedLinesBeforeOrAtColumn","top","decoder","defaultMetadata","defaultTokenMetadata","createFromTextAndMetadata","fullText","_lineTokensBrand","_tokensCount","_text","slicedEquals","sliceFromTokenIndex","sliceTokenCount","to","decodeLanguageId","getForeground","getClassName","getClassNameFromMetadata","getInlineStyle","colorMap","getInlineStyleFromMetadata","getPresentation","getPresentationFromMetadata","inflate","SliceLineTokens","desiredIndex","withInserted","insertTokens","nextOriginalTokenIdx","nextInsertTokenIdx","newTokens","nextOriginalTokenEndOffset","nextInsertToken","getTokenText","_startOffset","_endOffset","_deltaOffset","adjustedTokenIndex","getStandardTokenTypeAtPosition","SyncDescriptor","ctor","staticArguments","supportsDelayedInstantiation","ctorOrDescriptor","getSingletonServiceDescriptors","ResourceEditStackSnapshot","UndoRedoGroup","_ID","nextOrder","_UndoRedoGroup","UndoRedoSource","_UndoRedoSource"],"sourceRoot":""}