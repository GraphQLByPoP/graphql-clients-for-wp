{"version":3,"file":"static/js/3489.405fe5a8.chunk.js","mappings":"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","sources":["../node_modules/monaco-editor/esm/vs/base/common/glob.js"],"sourcesContent":["import { isThenable } from './async.js';\nimport { isEqualOrParent } from './extpath.js';\nimport { LRUCache } from './map.js';\nimport { basename, extname, posix, sep } from './path.js';\nimport { isLinux } from './platform.js';\nimport { escapeRegExpCharacters, ltrim } from './strings.js';\nexport const GLOBSTAR = '**';\nexport const GLOB_SPLIT = '/';\nconst PATH_REGEX = '[/\\\\\\\\]'; // any slash or backslash\nconst NO_PATH_REGEX = '[^/\\\\\\\\]'; // any non-slash and non-backslash\nconst ALL_FORWARD_SLASHES = /\\//g;\nfunction starsToRegExp(starCount, isLastPattern) {\n    switch (starCount) {\n        case 0:\n            return '';\n        case 1:\n            return `${NO_PATH_REGEX}*?`; // 1 star matches any number of characters except path separator (/ and \\) - non greedy (?)\n        default:\n            // Matches:  (Path Sep OR Path Val followed by Path Sep) 0-many times except when it's the last pattern\n            //           in which case also matches (Path Sep followed by Path Val)\n            // Group is non capturing because we don't need to capture at all (?:...)\n            // Overall we use non-greedy matching because it could be that we match too much\n            return `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}${isLastPattern ? `|${PATH_REGEX}${NO_PATH_REGEX}+` : ''})*?`;\n    }\n}\nexport function splitGlobAware(pattern, splitChar) {\n    if (!pattern) {\n        return [];\n    }\n    const segments = [];\n    let inBraces = false;\n    let inBrackets = false;\n    let curVal = '';\n    for (const char of pattern) {\n        switch (char) {\n            case splitChar:\n                if (!inBraces && !inBrackets) {\n                    segments.push(curVal);\n                    curVal = '';\n                    continue;\n                }\n                break;\n            case '{':\n                inBraces = true;\n                break;\n            case '}':\n                inBraces = false;\n                break;\n            case '[':\n                inBrackets = true;\n                break;\n            case ']':\n                inBrackets = false;\n                break;\n        }\n        curVal += char;\n    }\n    // Tail\n    if (curVal) {\n        segments.push(curVal);\n    }\n    return segments;\n}\nfunction parseRegExp(pattern) {\n    if (!pattern) {\n        return '';\n    }\n    let regEx = '';\n    // Split up into segments for each slash found\n    const segments = splitGlobAware(pattern, GLOB_SPLIT);\n    // Special case where we only have globstars\n    if (segments.every(segment => segment === GLOBSTAR)) {\n        regEx = '.*';\n    }\n    // Build regex over segments\n    else {\n        let previousSegmentWasGlobStar = false;\n        segments.forEach((segment, index) => {\n            // Treat globstar specially\n            if (segment === GLOBSTAR) {\n                // if we have more than one globstar after another, just ignore it\n                if (previousSegmentWasGlobStar) {\n                    return;\n                }\n                regEx += starsToRegExp(2, index === segments.length - 1);\n            }\n            // Anything else, not globstar\n            else {\n                // States\n                let inBraces = false;\n                let braceVal = '';\n                let inBrackets = false;\n                let bracketVal = '';\n                for (const char of segment) {\n                    // Support brace expansion\n                    if (char !== '}' && inBraces) {\n                        braceVal += char;\n                        continue;\n                    }\n                    // Support brackets\n                    if (inBrackets && (char !== ']' || !bracketVal) /* ] is literally only allowed as first character in brackets to match it */) {\n                        let res;\n                        // range operator\n                        if (char === '-') {\n                            res = char;\n                        }\n                        // negation operator (only valid on first index in bracket)\n                        else if ((char === '^' || char === '!') && !bracketVal) {\n                            res = '^';\n                        }\n                        // glob split matching is not allowed within character ranges\n                        // see http://man7.org/linux/man-pages/man7/glob.7.html\n                        else if (char === GLOB_SPLIT) {\n                            res = '';\n                        }\n                        // anything else gets escaped\n                        else {\n                            res = escapeRegExpCharacters(char);\n                        }\n                        bracketVal += res;\n                        continue;\n                    }\n                    switch (char) {\n                        case '{':\n                            inBraces = true;\n                            continue;\n                        case '[':\n                            inBrackets = true;\n                            continue;\n                        case '}': {\n                            const choices = splitGlobAware(braceVal, ',');\n                            // Converts {foo,bar} => [foo|bar]\n                            const braceRegExp = `(?:${choices.map(choice => parseRegExp(choice)).join('|')})`;\n                            regEx += braceRegExp;\n                            inBraces = false;\n                            braceVal = '';\n                            break;\n                        }\n                        case ']': {\n                            regEx += ('[' + bracketVal + ']');\n                            inBrackets = false;\n                            bracketVal = '';\n                            break;\n                        }\n                        case '?':\n                            regEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \\)\n                            continue;\n                        case '*':\n                            regEx += starsToRegExp(1);\n                            continue;\n                        default:\n                            regEx += escapeRegExpCharacters(char);\n                    }\n                }\n                // Tail: Add the slash we had split on if there is more to\n                // come and the remaining pattern is not a globstar\n                // For example if pattern: some/**/*.js we want the \"/\" after\n                // some to be included in the RegEx to prevent a folder called\n                // \"something\" to match as well.\n                if (index < segments.length - 1 && // more segments to come after this\n                    (segments[index + 1] !== GLOBSTAR || // next segment is not **, or...\n                        index + 2 < segments.length // ...next segment is ** but there is more segments after that\n                    )) {\n                    regEx += PATH_REGEX;\n                }\n            }\n            // update globstar state\n            previousSegmentWasGlobStar = (segment === GLOBSTAR);\n        });\n    }\n    return regEx;\n}\n// regexes to check for trivial glob patterns that just check for String#endsWith\nconst T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/; // **/*.something\nconst T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/; // **/something\nconst T3 = /^{\\*\\*\\/\\*?[\\w\\.-]+\\/?(,\\*\\*\\/\\*?[\\w\\.-]+\\/?)*}$/; // {**/*.something,**/*.else} or {**/package.json,**/project.json}\nconst T3_2 = /^{\\*\\*\\/\\*?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/\\*?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/; // Like T3, with optional trailing /**\nconst T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/; // **/something/else\nconst T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/; // something/else\nconst CACHE = new LRUCache(10000); // bounded to 10000 elements\nconst FALSE = function () {\n    return false;\n};\nconst NULL = function () {\n    return null;\n};\nfunction parsePattern(arg1, options) {\n    if (!arg1) {\n        return NULL;\n    }\n    // Handle relative patterns\n    let pattern;\n    if (typeof arg1 !== 'string') {\n        pattern = arg1.pattern;\n    }\n    else {\n        pattern = arg1;\n    }\n    // Whitespace trimming\n    pattern = pattern.trim();\n    // Check cache\n    const patternKey = `${pattern}_${!!options.trimForExclusions}`;\n    let parsedPattern = CACHE.get(patternKey);\n    if (parsedPattern) {\n        return wrapRelativePattern(parsedPattern, arg1);\n    }\n    // Check for Trivials\n    let match;\n    if (T1.test(pattern)) {\n        parsedPattern = trivia1(pattern.substr(4), pattern); // common pattern: **/*.txt just need endsWith check\n    }\n    else if (match = T2.exec(trimForExclusions(pattern, options))) { // common pattern: **/some.txt just need basename check\n        parsedPattern = trivia2(match[1], pattern);\n    }\n    else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) { // repetition of common patterns (see above) {**/*.txt,**/*.png}\n        parsedPattern = trivia3(pattern, options);\n    }\n    else if (match = T4.exec(trimForExclusions(pattern, options))) { // common pattern: **/something/else just need endsWith check\n        parsedPattern = trivia4and5(match[1].substr(1), pattern, true);\n    }\n    else if (match = T5.exec(trimForExclusions(pattern, options))) { // common pattern: something/else just need equals check\n        parsedPattern = trivia4and5(match[1], pattern, false);\n    }\n    // Otherwise convert to pattern\n    else {\n        parsedPattern = toRegExp(pattern);\n    }\n    // Cache\n    CACHE.set(patternKey, parsedPattern);\n    return wrapRelativePattern(parsedPattern, arg1);\n}\nfunction wrapRelativePattern(parsedPattern, arg2) {\n    if (typeof arg2 === 'string') {\n        return parsedPattern;\n    }\n    const wrappedPattern = function (path, basename) {\n        if (!isEqualOrParent(path, arg2.base, !isLinux)) {\n            // skip glob matching if `base` is not a parent of `path`\n            return null;\n        }\n        // Given we have checked `base` being a parent of `path`,\n        // we can now remove the `base` portion of the `path`\n        // and only match on the remaining path components\n        // For that we try to extract the portion of the `path`\n        // that comes after the `base` portion. We have to account\n        // for the fact that `base` might end in a path separator\n        // (https://github.com/microsoft/vscode/issues/162498)\n        return parsedPattern(ltrim(path.substr(arg2.base.length), sep), basename);\n    };\n    // Make sure to preserve associated metadata\n    wrappedPattern.allBasenames = parsedPattern.allBasenames;\n    wrappedPattern.allPaths = parsedPattern.allPaths;\n    wrappedPattern.basenames = parsedPattern.basenames;\n    wrappedPattern.patterns = parsedPattern.patterns;\n    return wrappedPattern;\n}\nfunction trimForExclusions(pattern, options) {\n    return options.trimForExclusions && pattern.endsWith('/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later\n}\n// common pattern: **/*.txt just need endsWith check\nfunction trivia1(base, pattern) {\n    return function (path, basename) {\n        return typeof path === 'string' && path.endsWith(base) ? pattern : null;\n    };\n}\n// common pattern: **/some.txt just need basename check\nfunction trivia2(base, pattern) {\n    const slashBase = `/${base}`;\n    const backslashBase = `\\\\${base}`;\n    const parsedPattern = function (path, basename) {\n        if (typeof path !== 'string') {\n            return null;\n        }\n        if (basename) {\n            return basename === base ? pattern : null;\n        }\n        return path === base || path.endsWith(slashBase) || path.endsWith(backslashBase) ? pattern : null;\n    };\n    const basenames = [base];\n    parsedPattern.basenames = basenames;\n    parsedPattern.patterns = [pattern];\n    parsedPattern.allBasenames = basenames;\n    return parsedPattern;\n}\n// repetition of common patterns (see above) {**/*.txt,**/*.png}\nfunction trivia3(pattern, options) {\n    const parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1)\n        .split(',')\n        .map(pattern => parsePattern(pattern, options))\n        .filter(pattern => pattern !== NULL), pattern);\n    const patternsLength = parsedPatterns.length;\n    if (!patternsLength) {\n        return NULL;\n    }\n    if (patternsLength === 1) {\n        return parsedPatterns[0];\n    }\n    const parsedPattern = function (path, basename) {\n        for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n            if (parsedPatterns[i](path, basename)) {\n                return pattern;\n            }\n        }\n        return null;\n    };\n    const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n    if (withBasenames) {\n        parsedPattern.allBasenames = withBasenames.allBasenames;\n    }\n    const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n    if (allPaths.length) {\n        parsedPattern.allPaths = allPaths;\n    }\n    return parsedPattern;\n}\n// common patterns: **/something/else just need endsWith check, something/else just needs and equals check\nfunction trivia4and5(targetPath, pattern, matchPathEnds) {\n    const usingPosixSep = sep === posix.sep;\n    const nativePath = usingPosixSep ? targetPath : targetPath.replace(ALL_FORWARD_SLASHES, sep);\n    const nativePathEnd = sep + nativePath;\n    const targetPathEnd = posix.sep + targetPath;\n    let parsedPattern;\n    if (matchPathEnds) {\n        parsedPattern = function (path, basename) {\n            return typeof path === 'string' && ((path === nativePath || path.endsWith(nativePathEnd)) || !usingPosixSep && (path === targetPath || path.endsWith(targetPathEnd))) ? pattern : null;\n        };\n    }\n    else {\n        parsedPattern = function (path, basename) {\n            return typeof path === 'string' && (path === nativePath || (!usingPosixSep && path === targetPath)) ? pattern : null;\n        };\n    }\n    parsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + targetPath];\n    return parsedPattern;\n}\nfunction toRegExp(pattern) {\n    try {\n        const regExp = new RegExp(`^${parseRegExp(pattern)}$`);\n        return function (path) {\n            regExp.lastIndex = 0; // reset RegExp to its initial state to reuse it!\n            return typeof path === 'string' && regExp.test(path) ? pattern : null;\n        };\n    }\n    catch (error) {\n        return NULL;\n    }\n}\nexport function match(arg1, path, hasSibling) {\n    if (!arg1 || typeof path !== 'string') {\n        return false;\n    }\n    return parse(arg1)(path, undefined, hasSibling);\n}\nexport function parse(arg1, options = {}) {\n    if (!arg1) {\n        return FALSE;\n    }\n    // Glob with String\n    if (typeof arg1 === 'string' || isRelativePattern(arg1)) {\n        const parsedPattern = parsePattern(arg1, options);\n        if (parsedPattern === NULL) {\n            return FALSE;\n        }\n        const resultPattern = function (path, basename) {\n            return !!parsedPattern(path, basename);\n        };\n        if (parsedPattern.allBasenames) {\n            resultPattern.allBasenames = parsedPattern.allBasenames;\n        }\n        if (parsedPattern.allPaths) {\n            resultPattern.allPaths = parsedPattern.allPaths;\n        }\n        return resultPattern;\n    }\n    // Glob with Expression\n    return parsedExpression(arg1, options);\n}\nexport function isRelativePattern(obj) {\n    const rp = obj;\n    if (!rp) {\n        return false;\n    }\n    return typeof rp.base === 'string' && typeof rp.pattern === 'string';\n}\nfunction parsedExpression(expression, options) {\n    const parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)\n        .map(pattern => parseExpressionPattern(pattern, expression[pattern], options))\n        .filter(pattern => pattern !== NULL));\n    const patternsLength = parsedPatterns.length;\n    if (!patternsLength) {\n        return NULL;\n    }\n    if (!parsedPatterns.some(parsedPattern => !!parsedPattern.requiresSiblings)) {\n        if (patternsLength === 1) {\n            return parsedPatterns[0];\n        }\n        const resultExpression = function (path, basename) {\n            let resultPromises = undefined;\n            for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n                const result = parsedPatterns[i](path, basename);\n                if (typeof result === 'string') {\n                    return result; // immediately return as soon as the first expression matches\n                }\n                // If the result is a promise, we have to keep it for\n                // later processing and await the result properly.\n                if (isThenable(result)) {\n                    if (!resultPromises) {\n                        resultPromises = [];\n                    }\n                    resultPromises.push(result);\n                }\n            }\n            // With result promises, we have to loop over each and\n            // await the result before we can return any result.\n            if (resultPromises) {\n                return (async () => {\n                    for (const resultPromise of resultPromises) {\n                        const result = await resultPromise;\n                        if (typeof result === 'string') {\n                            return result;\n                        }\n                    }\n                    return null;\n                })();\n            }\n            return null;\n        };\n        const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n        if (withBasenames) {\n            resultExpression.allBasenames = withBasenames.allBasenames;\n        }\n        const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n        if (allPaths.length) {\n            resultExpression.allPaths = allPaths;\n        }\n        return resultExpression;\n    }\n    const resultExpression = function (path, base, hasSibling) {\n        let name = undefined;\n        let resultPromises = undefined;\n        for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n            // Pattern matches path\n            const parsedPattern = parsedPatterns[i];\n            if (parsedPattern.requiresSiblings && hasSibling) {\n                if (!base) {\n                    base = basename(path);\n                }\n                if (!name) {\n                    name = base.substr(0, base.length - extname(path).length);\n                }\n            }\n            const result = parsedPattern(path, base, name, hasSibling);\n            if (typeof result === 'string') {\n                return result; // immediately return as soon as the first expression matches\n            }\n            // If the result is a promise, we have to keep it for\n            // later processing and await the result properly.\n            if (isThenable(result)) {\n                if (!resultPromises) {\n                    resultPromises = [];\n                }\n                resultPromises.push(result);\n            }\n        }\n        // With result promises, we have to loop over each and\n        // await the result before we can return any result.\n        if (resultPromises) {\n            return (async () => {\n                for (const resultPromise of resultPromises) {\n                    const result = await resultPromise;\n                    if (typeof result === 'string') {\n                        return result;\n                    }\n                }\n                return null;\n            })();\n        }\n        return null;\n    };\n    const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n    if (withBasenames) {\n        resultExpression.allBasenames = withBasenames.allBasenames;\n    }\n    const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n    if (allPaths.length) {\n        resultExpression.allPaths = allPaths;\n    }\n    return resultExpression;\n}\nfunction parseExpressionPattern(pattern, value, options) {\n    if (value === false) {\n        return NULL; // pattern is disabled\n    }\n    const parsedPattern = parsePattern(pattern, options);\n    if (parsedPattern === NULL) {\n        return NULL;\n    }\n    // Expression Pattern is <boolean>\n    if (typeof value === 'boolean') {\n        return parsedPattern;\n    }\n    // Expression Pattern is <SiblingClause>\n    if (value) {\n        const when = value.when;\n        if (typeof when === 'string') {\n            const result = (path, basename, name, hasSibling) => {\n                if (!hasSibling || !parsedPattern(path, basename)) {\n                    return null;\n                }\n                const clausePattern = when.replace('$(basename)', () => name);\n                const matched = hasSibling(clausePattern);\n                return isThenable(matched) ?\n                    matched.then(match => match ? pattern : null) :\n                    matched ? pattern : null;\n            };\n            result.requiresSiblings = true;\n            return result;\n        }\n    }\n    // Expression is anything\n    return parsedPattern;\n}\nfunction aggregateBasenameMatches(parsedPatterns, result) {\n    const basenamePatterns = parsedPatterns.filter(parsedPattern => !!parsedPattern.basenames);\n    if (basenamePatterns.length < 2) {\n        return parsedPatterns;\n    }\n    const basenames = basenamePatterns.reduce((all, current) => {\n        const basenames = current.basenames;\n        return basenames ? all.concat(basenames) : all;\n    }, []);\n    let patterns;\n    if (result) {\n        patterns = [];\n        for (let i = 0, n = basenames.length; i < n; i++) {\n            patterns.push(result);\n        }\n    }\n    else {\n        patterns = basenamePatterns.reduce((all, current) => {\n            const patterns = current.patterns;\n            return patterns ? all.concat(patterns) : all;\n        }, []);\n    }\n    const aggregate = function (path, basename) {\n        if (typeof path !== 'string') {\n            return null;\n        }\n        if (!basename) {\n            let i;\n            for (i = path.length; i > 0; i--) {\n                const ch = path.charCodeAt(i - 1);\n                if (ch === 47 /* CharCode.Slash */ || ch === 92 /* CharCode.Backslash */) {\n                    break;\n                }\n            }\n            basename = path.substr(i);\n        }\n        const index = basenames.indexOf(basename);\n        return index !== -1 ? patterns[index] : null;\n    };\n    aggregate.basenames = basenames;\n    aggregate.patterns = patterns;\n    aggregate.allBasenames = basenames;\n    const aggregatedPatterns = parsedPatterns.filter(parsedPattern => !parsedPattern.basenames);\n    aggregatedPatterns.push(aggregate);\n    return aggregatedPatterns;\n}\n"],"names":["GLOBSTAR","PATH_REGEX","NO_PATH_REGEX","ALL_FORWARD_SLASHES","starsToRegExp","starCount","isLastPattern","concat","splitGlobAware","pattern","splitChar","segments","inBraces","inBrackets","curVal","char","push","parseRegExp","regEx","every","segment","previousSegmentWasGlobStar","forEach","index","length","braceVal","bracketVal","res","escapeRegExpCharacters","choices","braceRegExp","map","choice","join","T1","T2","T3","T3_2","T4","T5","CACHE","LRUCache","FALSE","NULL","parsePattern","arg1","options","trim","patternKey","trimForExclusions","match","parsedPattern","get","test","base","path","basename","endsWith","trivia1","substr","exec","slashBase","backslashBase","basenames","patterns","allBasenames","trivia2","parsedPatterns","aggregateBasenameMatches","slice","split","filter","patternsLength","i","n","withBasenames","find","allPaths","reduce","all","current","trivia3","trivia4and5","regExp","RegExp","lastIndex","error","toRegExp","set","wrapRelativePattern","arg2","wrappedPattern","isEqualOrParent","isLinux","ltrim","sep","targetPath","matchPathEnds","usingPosixSep","posix","nativePath","replace","nativePathEnd","targetPathEnd","hasSibling","parse","undefined","arguments","obj","rp","isRelativePattern","resultPattern","expression","Object","getOwnPropertyNames","value","when","result","name","matched","isThenable","then","requiresSiblings","parseExpressionPattern","some","resultExpression","resultPromises","resultPromise","extname","parsedExpression","basenamePatterns","aggregate","ch","charCodeAt","indexOf","aggregatedPatterns"],"sourceRoot":""}