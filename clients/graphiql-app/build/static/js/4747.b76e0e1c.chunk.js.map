{"version":3,"file":"static/js/4747.b76e0e1c.chunk.js","mappings":"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","sources":["../node_modules/monaco-editor/esm/vs/base/common/cache.js","../node_modules/monaco-editor/esm/vs/base/common/diff/diffChange.js","../node_modules/monaco-editor/esm/vs/base/common/lazy.js","../node_modules/monaco-editor/esm/vs/base/common/uint.js","../node_modules/monaco-editor/esm/vs/editor/common/core/lineRange.js","../node_modules/monaco-editor/esm/vs/editor/common/core/positionToOffset.js","../node_modules/monaco-editor/esm/vs/editor/common/core/textLength.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/diffAlgorithm.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/utils.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/dynamicProgrammingDiffing.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/myersDiffAlgorithm.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/linesSliceCharSequence.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/computeMovedLines.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/lineSequence.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/defaultLinesDiffComputer.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/heuristicSequenceOptimizations.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputer.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/rangeMapping.js","../node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js","../node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js","../node_modules/monaco-editor/esm/vs/editor/common/languages/linkComputer.js","../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/inplaceReplaceSupport.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/legacyLinesDiffComputer.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputers.js","../node_modules/monaco-editor/esm/vs/editor/common/languages/defaultDocumentColorsComputer.js","../node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js","../node_modules/monaco-editor/esm/vs/editor/common/services/editorWorkerHost.js","../node_modules/monaco-editor/esm/vs/editor/common/services/findSectionHeaders.js","../node_modules/monaco-editor/esm/vs/editor/common/services/unicodeTextModelHighlighter.js"],"sourcesContent":["export function identity(t) {\n    return t;\n}\n/**\n * Uses a LRU cache to make a given parametrized function cached.\n * Caches just the last key/value.\n*/\nexport class LRUCachedFunction {\n    constructor(arg1, arg2) {\n        this.lastCache = undefined;\n        this.lastArgKey = undefined;\n        if (typeof arg1 === 'function') {\n            this._fn = arg1;\n            this._computeKey = identity;\n        }\n        else {\n            this._fn = arg2;\n            this._computeKey = arg1.getCacheKey;\n        }\n    }\n    get(arg) {\n        const key = this._computeKey(arg);\n        if (this.lastArgKey !== key) {\n            this.lastArgKey = key;\n            this.lastCache = this._fn(arg);\n        }\n        return this.lastCache;\n    }\n}\n/**\n * Uses an unbounded cache to memoize the results of the given function.\n*/\nexport class CachedFunction {\n    get cachedValues() {\n        return this._map;\n    }\n    constructor(arg1, arg2) {\n        this._map = new Map();\n        this._map2 = new Map();\n        if (typeof arg1 === 'function') {\n            this._fn = arg1;\n            this._computeKey = identity;\n        }\n        else {\n            this._fn = arg2;\n            this._computeKey = arg1.getCacheKey;\n        }\n    }\n    get(arg) {\n        const key = this._computeKey(arg);\n        if (this._map2.has(key)) {\n            return this._map2.get(key);\n        }\n        const value = this._fn(arg);\n        this._map.set(arg, value);\n        this._map2.set(key, value);\n        return value;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Represents information about a specific difference between two sequences.\n */\nexport class DiffChange {\n    /**\n     * Constructs a new DiffChange with the given sequence information\n     * and content.\n     */\n    constructor(originalStart, originalLength, modifiedStart, modifiedLength) {\n        //Debug.Assert(originalLength > 0 || modifiedLength > 0, \"originalLength and modifiedLength cannot both be <= 0\");\n        this.originalStart = originalStart;\n        this.originalLength = originalLength;\n        this.modifiedStart = modifiedStart;\n        this.modifiedLength = modifiedLength;\n    }\n    /**\n     * The end point (exclusive) of the change in the original sequence.\n     */\n    getOriginalEnd() {\n        return this.originalStart + this.originalLength;\n    }\n    /**\n     * The end point (exclusive) of the change in the modified sequence.\n     */\n    getModifiedEnd() {\n        return this.modifiedStart + this.modifiedLength;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class Lazy {\n    constructor(executor) {\n        this.executor = executor;\n        this._didRun = false;\n    }\n    /**\n     * Get the wrapped value.\n     *\n     * This will force evaluation of the lazy value if it has not been resolved yet. Lazy values are only\n     * resolved once. `getValue` will re-throw exceptions that are hit while resolving the value\n     */\n    get value() {\n        if (!this._didRun) {\n            try {\n                this._value = this.executor();\n            }\n            catch (err) {\n                this._error = err;\n            }\n            finally {\n                this._didRun = true;\n            }\n        }\n        if (this._error) {\n            throw this._error;\n        }\n        return this._value;\n    }\n    /**\n     * Get the wrapped value without forcing evaluation.\n     */\n    get rawValue() { return this._value; }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function toUint8(v) {\n    if (v < 0) {\n        return 0;\n    }\n    if (v > 255 /* Constants.MAX_UINT_8 */) {\n        return 255 /* Constants.MAX_UINT_8 */;\n    }\n    return v | 0;\n}\nexport function toUint32(v) {\n    if (v < 0) {\n        return 0;\n    }\n    if (v > 4294967295 /* Constants.MAX_UINT_32 */) {\n        return 4294967295 /* Constants.MAX_UINT_32 */;\n    }\n    return v | 0;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { OffsetRange } from './offsetRange.js';\nimport { Range } from './range.js';\nimport { findFirstIdxMonotonousOrArrLen, findLastIdxMonotonous, findLastMonotonous } from '../../../base/common/arraysFind.js';\n/**\n * A range of lines (1-based).\n */\nexport class LineRange {\n    static fromRangeInclusive(range) {\n        return new LineRange(range.startLineNumber, range.endLineNumber + 1);\n    }\n    /**\n     * @param lineRanges An array of sorted line ranges.\n     */\n    static joinMany(lineRanges) {\n        if (lineRanges.length === 0) {\n            return [];\n        }\n        let result = new LineRangeSet(lineRanges[0].slice());\n        for (let i = 1; i < lineRanges.length; i++) {\n            result = result.getUnion(new LineRangeSet(lineRanges[i].slice()));\n        }\n        return result.ranges;\n    }\n    static join(lineRanges) {\n        if (lineRanges.length === 0) {\n            throw new BugIndicatingError('lineRanges cannot be empty');\n        }\n        let startLineNumber = lineRanges[0].startLineNumber;\n        let endLineNumberExclusive = lineRanges[0].endLineNumberExclusive;\n        for (let i = 1; i < lineRanges.length; i++) {\n            startLineNumber = Math.min(startLineNumber, lineRanges[i].startLineNumber);\n            endLineNumberExclusive = Math.max(endLineNumberExclusive, lineRanges[i].endLineNumberExclusive);\n        }\n        return new LineRange(startLineNumber, endLineNumberExclusive);\n    }\n    static ofLength(startLineNumber, length) {\n        return new LineRange(startLineNumber, startLineNumber + length);\n    }\n    /**\n     * @internal\n     */\n    static deserialize(lineRange) {\n        return new LineRange(lineRange[0], lineRange[1]);\n    }\n    constructor(startLineNumber, endLineNumberExclusive) {\n        if (startLineNumber > endLineNumberExclusive) {\n            throw new BugIndicatingError(`startLineNumber ${startLineNumber} cannot be after endLineNumberExclusive ${endLineNumberExclusive}`);\n        }\n        this.startLineNumber = startLineNumber;\n        this.endLineNumberExclusive = endLineNumberExclusive;\n    }\n    /**\n     * Indicates if this line range contains the given line number.\n     */\n    contains(lineNumber) {\n        return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;\n    }\n    /**\n     * Indicates if this line range is empty.\n     */\n    get isEmpty() {\n        return this.startLineNumber === this.endLineNumberExclusive;\n    }\n    /**\n     * Moves this line range by the given offset of line numbers.\n     */\n    delta(offset) {\n        return new LineRange(this.startLineNumber + offset, this.endLineNumberExclusive + offset);\n    }\n    deltaLength(offset) {\n        return new LineRange(this.startLineNumber, this.endLineNumberExclusive + offset);\n    }\n    /**\n     * The number of lines this line range spans.\n     */\n    get length() {\n        return this.endLineNumberExclusive - this.startLineNumber;\n    }\n    /**\n     * Creates a line range that combines this and the given line range.\n     */\n    join(other) {\n        return new LineRange(Math.min(this.startLineNumber, other.startLineNumber), Math.max(this.endLineNumberExclusive, other.endLineNumberExclusive));\n    }\n    toString() {\n        return `[${this.startLineNumber},${this.endLineNumberExclusive})`;\n    }\n    /**\n     * The resulting range is empty if the ranges do not intersect, but touch.\n     * If the ranges don't even touch, the result is undefined.\n     */\n    intersect(other) {\n        const startLineNumber = Math.max(this.startLineNumber, other.startLineNumber);\n        const endLineNumberExclusive = Math.min(this.endLineNumberExclusive, other.endLineNumberExclusive);\n        if (startLineNumber <= endLineNumberExclusive) {\n            return new LineRange(startLineNumber, endLineNumberExclusive);\n        }\n        return undefined;\n    }\n    intersectsStrict(other) {\n        return this.startLineNumber < other.endLineNumberExclusive && other.startLineNumber < this.endLineNumberExclusive;\n    }\n    overlapOrTouch(other) {\n        return this.startLineNumber <= other.endLineNumberExclusive && other.startLineNumber <= this.endLineNumberExclusive;\n    }\n    equals(b) {\n        return this.startLineNumber === b.startLineNumber && this.endLineNumberExclusive === b.endLineNumberExclusive;\n    }\n    toInclusiveRange() {\n        if (this.isEmpty) {\n            return null;\n        }\n        return new Range(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);\n    }\n    /**\n     * @deprecated Using this function is discouraged because it might lead to bugs: The end position is not guaranteed to be a valid position!\n    */\n    toExclusiveRange() {\n        return new Range(this.startLineNumber, 1, this.endLineNumberExclusive, 1);\n    }\n    mapToLineArray(f) {\n        const result = [];\n        for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n            result.push(f(lineNumber));\n        }\n        return result;\n    }\n    forEach(f) {\n        for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n            f(lineNumber);\n        }\n    }\n    /**\n     * @internal\n     */\n    serialize() {\n        return [this.startLineNumber, this.endLineNumberExclusive];\n    }\n    includes(lineNumber) {\n        return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;\n    }\n    /**\n     * Converts this 1-based line range to a 0-based offset range (subtracts 1!).\n     * @internal\n     */\n    toOffsetRange() {\n        return new OffsetRange(this.startLineNumber - 1, this.endLineNumberExclusive - 1);\n    }\n}\nexport class LineRangeSet {\n    constructor(\n    /**\n     * Sorted by start line number.\n     * No two line ranges are touching or intersecting.\n     */\n    _normalizedRanges = []) {\n        this._normalizedRanges = _normalizedRanges;\n    }\n    get ranges() {\n        return this._normalizedRanges;\n    }\n    addRange(range) {\n        if (range.length === 0) {\n            return;\n        }\n        // Idea: Find joinRange such that:\n        // replaceRange = _normalizedRanges.replaceRange(joinRange, range.joinAll(joinRange.map(idx => this._normalizedRanges[idx])))\n        // idx of first element that touches range or that is after range\n        const joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);\n        // idx of element after { last element that touches range or that is before range }\n        const joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;\n        if (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n            // If there is no element that touches range, then joinRangeStartIdx === joinRangeEndIdxExclusive and that value is the index of the element after range\n            this._normalizedRanges.splice(joinRangeStartIdx, 0, range);\n        }\n        else if (joinRangeStartIdx === joinRangeEndIdxExclusive - 1) {\n            // Else, there is an element that touches range and in this case it is both the first and last element. Thus we can replace it\n            const joinRange = this._normalizedRanges[joinRangeStartIdx];\n            this._normalizedRanges[joinRangeStartIdx] = joinRange.join(range);\n        }\n        else {\n            // First and last element are different - we need to replace the entire range\n            const joinRange = this._normalizedRanges[joinRangeStartIdx].join(this._normalizedRanges[joinRangeEndIdxExclusive - 1]).join(range);\n            this._normalizedRanges.splice(joinRangeStartIdx, joinRangeEndIdxExclusive - joinRangeStartIdx, joinRange);\n        }\n    }\n    contains(lineNumber) {\n        const rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, r => r.startLineNumber <= lineNumber);\n        return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > lineNumber;\n    }\n    intersects(range) {\n        const rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, r => r.startLineNumber < range.endLineNumberExclusive);\n        return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > range.startLineNumber;\n    }\n    getUnion(other) {\n        if (this._normalizedRanges.length === 0) {\n            return other;\n        }\n        if (other._normalizedRanges.length === 0) {\n            return this;\n        }\n        const result = [];\n        let i1 = 0;\n        let i2 = 0;\n        let current = null;\n        while (i1 < this._normalizedRanges.length || i2 < other._normalizedRanges.length) {\n            let next = null;\n            if (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\n                const lineRange1 = this._normalizedRanges[i1];\n                const lineRange2 = other._normalizedRanges[i2];\n                if (lineRange1.startLineNumber < lineRange2.startLineNumber) {\n                    next = lineRange1;\n                    i1++;\n                }\n                else {\n                    next = lineRange2;\n                    i2++;\n                }\n            }\n            else if (i1 < this._normalizedRanges.length) {\n                next = this._normalizedRanges[i1];\n                i1++;\n            }\n            else {\n                next = other._normalizedRanges[i2];\n                i2++;\n            }\n            if (current === null) {\n                current = next;\n            }\n            else {\n                if (current.endLineNumberExclusive >= next.startLineNumber) {\n                    // merge\n                    current = new LineRange(current.startLineNumber, Math.max(current.endLineNumberExclusive, next.endLineNumberExclusive));\n                }\n                else {\n                    // push\n                    result.push(current);\n                    current = next;\n                }\n            }\n        }\n        if (current !== null) {\n            result.push(current);\n        }\n        return new LineRangeSet(result);\n    }\n    /**\n     * Subtracts all ranges in this set from `range` and returns the result.\n     */\n    subtractFrom(range) {\n        // idx of first element that touches range or that is after range\n        const joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);\n        // idx of element after { last element that touches range or that is before range }\n        const joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;\n        if (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n            return new LineRangeSet([range]);\n        }\n        const result = [];\n        let startLineNumber = range.startLineNumber;\n        for (let i = joinRangeStartIdx; i < joinRangeEndIdxExclusive; i++) {\n            const r = this._normalizedRanges[i];\n            if (r.startLineNumber > startLineNumber) {\n                result.push(new LineRange(startLineNumber, r.startLineNumber));\n            }\n            startLineNumber = r.endLineNumberExclusive;\n        }\n        if (startLineNumber < range.endLineNumberExclusive) {\n            result.push(new LineRange(startLineNumber, range.endLineNumberExclusive));\n        }\n        return new LineRangeSet(result);\n    }\n    toString() {\n        return this._normalizedRanges.map(r => r.toString()).join(', ');\n    }\n    getIntersection(other) {\n        const result = [];\n        let i1 = 0;\n        let i2 = 0;\n        while (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\n            const r1 = this._normalizedRanges[i1];\n            const r2 = other._normalizedRanges[i2];\n            const i = r1.intersect(r2);\n            if (i && !i.isEmpty) {\n                result.push(i);\n            }\n            if (r1.endLineNumberExclusive < r2.endLineNumberExclusive) {\n                i1++;\n            }\n            else {\n                i2++;\n            }\n        }\n        return new LineRangeSet(result);\n    }\n    getWithDelta(value) {\n        return new LineRangeSet(this._normalizedRanges.map(r => r.delta(value)));\n    }\n}\n","import { OffsetRange } from './offsetRange.js';\nimport { TextLength } from './textLength.js';\nexport class PositionOffsetTransformer {\n    constructor(text) {\n        this.text = text;\n        this.lineStartOffsetByLineIdx = [];\n        this.lineStartOffsetByLineIdx.push(0);\n        for (let i = 0; i < text.length; i++) {\n            if (text.charAt(i) === '\\n') {\n                this.lineStartOffsetByLineIdx.push(i + 1);\n            }\n        }\n    }\n    getOffset(position) {\n        return this.lineStartOffsetByLineIdx[position.lineNumber - 1] + position.column - 1;\n    }\n    getOffsetRange(range) {\n        return new OffsetRange(this.getOffset(range.getStartPosition()), this.getOffset(range.getEndPosition()));\n    }\n    get textLength() {\n        const lineIdx = this.lineStartOffsetByLineIdx.length - 1;\n        return new TextLength(lineIdx, this.text.length - this.lineStartOffsetByLineIdx[lineIdx]);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './position.js';\nimport { Range } from './range.js';\n/**\n * Represents a non-negative length of text in terms of line and column count.\n*/\nexport class TextLength {\n    static { this.zero = new TextLength(0, 0); }\n    static betweenPositions(position1, position2) {\n        if (position1.lineNumber === position2.lineNumber) {\n            return new TextLength(0, position2.column - position1.column);\n        }\n        else {\n            return new TextLength(position2.lineNumber - position1.lineNumber, position2.column - 1);\n        }\n    }\n    static ofRange(range) {\n        return TextLength.betweenPositions(range.getStartPosition(), range.getEndPosition());\n    }\n    static ofText(text) {\n        let line = 0;\n        let column = 0;\n        for (const c of text) {\n            if (c === '\\n') {\n                line++;\n                column = 0;\n            }\n            else {\n                column++;\n            }\n        }\n        return new TextLength(line, column);\n    }\n    constructor(lineCount, columnCount) {\n        this.lineCount = lineCount;\n        this.columnCount = columnCount;\n    }\n    isGreaterThanOrEqualTo(other) {\n        if (this.lineCount !== other.lineCount) {\n            return this.lineCount > other.lineCount;\n        }\n        return this.columnCount >= other.columnCount;\n    }\n    createRange(startPosition) {\n        if (this.lineCount === 0) {\n            return new Range(startPosition.lineNumber, startPosition.column, startPosition.lineNumber, startPosition.column + this.columnCount);\n        }\n        else {\n            return new Range(startPosition.lineNumber, startPosition.column, startPosition.lineNumber + this.lineCount, this.columnCount + 1);\n        }\n    }\n    addToPosition(position) {\n        if (this.lineCount === 0) {\n            return new Position(position.lineNumber, position.column + this.columnCount);\n        }\n        else {\n            return new Position(position.lineNumber + this.lineCount, this.columnCount + 1);\n        }\n    }\n    toString() {\n        return `${this.lineCount},${this.columnCount}`;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { forEachAdjacent } from '../../../../../base/common/arrays.js';\nimport { BugIndicatingError } from '../../../../../base/common/errors.js';\nimport { OffsetRange } from '../../../core/offsetRange.js';\nexport class DiffAlgorithmResult {\n    static trivial(seq1, seq2) {\n        return new DiffAlgorithmResult([new SequenceDiff(OffsetRange.ofLength(seq1.length), OffsetRange.ofLength(seq2.length))], false);\n    }\n    static trivialTimedOut(seq1, seq2) {\n        return new DiffAlgorithmResult([new SequenceDiff(OffsetRange.ofLength(seq1.length), OffsetRange.ofLength(seq2.length))], true);\n    }\n    constructor(diffs, \n    /**\n     * Indicates if the time out was reached.\n     * In that case, the diffs might be an approximation and the user should be asked to rerun the diff with more time.\n     */\n    hitTimeout) {\n        this.diffs = diffs;\n        this.hitTimeout = hitTimeout;\n    }\n}\nexport class SequenceDiff {\n    static invert(sequenceDiffs, doc1Length) {\n        const result = [];\n        forEachAdjacent(sequenceDiffs, (a, b) => {\n            result.push(SequenceDiff.fromOffsetPairs(a ? a.getEndExclusives() : OffsetPair.zero, b ? b.getStarts() : new OffsetPair(doc1Length, (a ? a.seq2Range.endExclusive - a.seq1Range.endExclusive : 0) + doc1Length)));\n        });\n        return result;\n    }\n    static fromOffsetPairs(start, endExclusive) {\n        return new SequenceDiff(new OffsetRange(start.offset1, endExclusive.offset1), new OffsetRange(start.offset2, endExclusive.offset2));\n    }\n    static assertSorted(sequenceDiffs) {\n        let last = undefined;\n        for (const cur of sequenceDiffs) {\n            if (last) {\n                if (!(last.seq1Range.endExclusive <= cur.seq1Range.start && last.seq2Range.endExclusive <= cur.seq2Range.start)) {\n                    throw new BugIndicatingError('Sequence diffs must be sorted');\n                }\n            }\n            last = cur;\n        }\n    }\n    constructor(seq1Range, seq2Range) {\n        this.seq1Range = seq1Range;\n        this.seq2Range = seq2Range;\n    }\n    swap() {\n        return new SequenceDiff(this.seq2Range, this.seq1Range);\n    }\n    toString() {\n        return `${this.seq1Range} <-> ${this.seq2Range}`;\n    }\n    join(other) {\n        return new SequenceDiff(this.seq1Range.join(other.seq1Range), this.seq2Range.join(other.seq2Range));\n    }\n    delta(offset) {\n        if (offset === 0) {\n            return this;\n        }\n        return new SequenceDiff(this.seq1Range.delta(offset), this.seq2Range.delta(offset));\n    }\n    deltaStart(offset) {\n        if (offset === 0) {\n            return this;\n        }\n        return new SequenceDiff(this.seq1Range.deltaStart(offset), this.seq2Range.deltaStart(offset));\n    }\n    deltaEnd(offset) {\n        if (offset === 0) {\n            return this;\n        }\n        return new SequenceDiff(this.seq1Range.deltaEnd(offset), this.seq2Range.deltaEnd(offset));\n    }\n    intersect(other) {\n        const i1 = this.seq1Range.intersect(other.seq1Range);\n        const i2 = this.seq2Range.intersect(other.seq2Range);\n        if (!i1 || !i2) {\n            return undefined;\n        }\n        return new SequenceDiff(i1, i2);\n    }\n    getStarts() {\n        return new OffsetPair(this.seq1Range.start, this.seq2Range.start);\n    }\n    getEndExclusives() {\n        return new OffsetPair(this.seq1Range.endExclusive, this.seq2Range.endExclusive);\n    }\n}\nexport class OffsetPair {\n    static { this.zero = new OffsetPair(0, 0); }\n    static { this.max = new OffsetPair(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER); }\n    constructor(offset1, offset2) {\n        this.offset1 = offset1;\n        this.offset2 = offset2;\n    }\n    toString() {\n        return `${this.offset1} <-> ${this.offset2}`;\n    }\n    delta(offset) {\n        if (offset === 0) {\n            return this;\n        }\n        return new OffsetPair(this.offset1 + offset, this.offset2 + offset);\n    }\n    equals(other) {\n        return this.offset1 === other.offset1 && this.offset2 === other.offset2;\n    }\n}\nexport class InfiniteTimeout {\n    static { this.instance = new InfiniteTimeout(); }\n    isValid() {\n        return true;\n    }\n}\nexport class DateTimeout {\n    constructor(timeout) {\n        this.timeout = timeout;\n        this.startTime = Date.now();\n        this.valid = true;\n        if (timeout <= 0) {\n            throw new BugIndicatingError('timeout must be positive');\n        }\n    }\n    // Recommendation: Set a log-point `{this.disable()}` in the body\n    isValid() {\n        const valid = Date.now() - this.startTime < this.timeout;\n        if (!valid && this.valid) {\n            this.valid = false; // timeout reached\n            // eslint-disable-next-line no-debugger\n            debugger; // WARNING: Most likely debugging caused the timeout. Call `this.disable()` to continue without timing out.\n        }\n        return this.valid;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class Array2D {\n    constructor(width, height) {\n        this.width = width;\n        this.height = height;\n        this.array = [];\n        this.array = new Array(width * height);\n    }\n    get(x, y) {\n        return this.array[x + y * this.width];\n    }\n    set(x, y, value) {\n        this.array[x + y * this.width] = value;\n    }\n}\nexport function isSpace(charCode) {\n    return charCode === 32 /* CharCode.Space */ || charCode === 9 /* CharCode.Tab */;\n}\nexport class LineRangeFragment {\n    static { this.chrKeys = new Map(); }\n    static getKey(chr) {\n        let key = this.chrKeys.get(chr);\n        if (key === undefined) {\n            key = this.chrKeys.size;\n            this.chrKeys.set(chr, key);\n        }\n        return key;\n    }\n    constructor(range, lines, source) {\n        this.range = range;\n        this.lines = lines;\n        this.source = source;\n        this.histogram = [];\n        let counter = 0;\n        for (let i = range.startLineNumber - 1; i < range.endLineNumberExclusive - 1; i++) {\n            const line = lines[i];\n            for (let j = 0; j < line.length; j++) {\n                counter++;\n                const chr = line[j];\n                const key = LineRangeFragment.getKey(chr);\n                this.histogram[key] = (this.histogram[key] || 0) + 1;\n            }\n            counter++;\n            const key = LineRangeFragment.getKey('\\n');\n            this.histogram[key] = (this.histogram[key] || 0) + 1;\n        }\n        this.totalCount = counter;\n    }\n    computeSimilarity(other) {\n        let sumDifferences = 0;\n        const maxLength = Math.max(this.histogram.length, other.histogram.length);\n        for (let i = 0; i < maxLength; i++) {\n            sumDifferences += Math.abs((this.histogram[i] ?? 0) - (other.histogram[i] ?? 0));\n        }\n        return 1 - (sumDifferences / (this.totalCount + other.totalCount));\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { OffsetRange } from '../../../core/offsetRange.js';\nimport { SequenceDiff, InfiniteTimeout, DiffAlgorithmResult } from './diffAlgorithm.js';\nimport { Array2D } from '../utils.js';\n/**\n * A O(MN) diffing algorithm that supports a score function.\n * The algorithm can be improved by processing the 2d array diagonally.\n*/\nexport class DynamicProgrammingDiffing {\n    compute(sequence1, sequence2, timeout = InfiniteTimeout.instance, equalityScore) {\n        if (sequence1.length === 0 || sequence2.length === 0) {\n            return DiffAlgorithmResult.trivial(sequence1, sequence2);\n        }\n        /**\n         * lcsLengths.get(i, j): Length of the longest common subsequence of sequence1.substring(0, i + 1) and sequence2.substring(0, j + 1).\n         */\n        const lcsLengths = new Array2D(sequence1.length, sequence2.length);\n        const directions = new Array2D(sequence1.length, sequence2.length);\n        const lengths = new Array2D(sequence1.length, sequence2.length);\n        // ==== Initializing lcsLengths ====\n        for (let s1 = 0; s1 < sequence1.length; s1++) {\n            for (let s2 = 0; s2 < sequence2.length; s2++) {\n                if (!timeout.isValid()) {\n                    return DiffAlgorithmResult.trivialTimedOut(sequence1, sequence2);\n                }\n                const horizontalLen = s1 === 0 ? 0 : lcsLengths.get(s1 - 1, s2);\n                const verticalLen = s2 === 0 ? 0 : lcsLengths.get(s1, s2 - 1);\n                let extendedSeqScore;\n                if (sequence1.getElement(s1) === sequence2.getElement(s2)) {\n                    if (s1 === 0 || s2 === 0) {\n                        extendedSeqScore = 0;\n                    }\n                    else {\n                        extendedSeqScore = lcsLengths.get(s1 - 1, s2 - 1);\n                    }\n                    if (s1 > 0 && s2 > 0 && directions.get(s1 - 1, s2 - 1) === 3) {\n                        // Prefer consecutive diagonals\n                        extendedSeqScore += lengths.get(s1 - 1, s2 - 1);\n                    }\n                    extendedSeqScore += (equalityScore ? equalityScore(s1, s2) : 1);\n                }\n                else {\n                    extendedSeqScore = -1;\n                }\n                const newValue = Math.max(horizontalLen, verticalLen, extendedSeqScore);\n                if (newValue === extendedSeqScore) {\n                    // Prefer diagonals\n                    const prevLen = s1 > 0 && s2 > 0 ? lengths.get(s1 - 1, s2 - 1) : 0;\n                    lengths.set(s1, s2, prevLen + 1);\n                    directions.set(s1, s2, 3);\n                }\n                else if (newValue === horizontalLen) {\n                    lengths.set(s1, s2, 0);\n                    directions.set(s1, s2, 1);\n                }\n                else if (newValue === verticalLen) {\n                    lengths.set(s1, s2, 0);\n                    directions.set(s1, s2, 2);\n                }\n                lcsLengths.set(s1, s2, newValue);\n            }\n        }\n        // ==== Backtracking ====\n        const result = [];\n        let lastAligningPosS1 = sequence1.length;\n        let lastAligningPosS2 = sequence2.length;\n        function reportDecreasingAligningPositions(s1, s2) {\n            if (s1 + 1 !== lastAligningPosS1 || s2 + 1 !== lastAligningPosS2) {\n                result.push(new SequenceDiff(new OffsetRange(s1 + 1, lastAligningPosS1), new OffsetRange(s2 + 1, lastAligningPosS2)));\n            }\n            lastAligningPosS1 = s1;\n            lastAligningPosS2 = s2;\n        }\n        let s1 = sequence1.length - 1;\n        let s2 = sequence2.length - 1;\n        while (s1 >= 0 && s2 >= 0) {\n            if (directions.get(s1, s2) === 3) {\n                reportDecreasingAligningPositions(s1, s2);\n                s1--;\n                s2--;\n            }\n            else {\n                if (directions.get(s1, s2) === 1) {\n                    s1--;\n                }\n                else {\n                    s2--;\n                }\n            }\n        }\n        reportDecreasingAligningPositions(-1, -1);\n        result.reverse();\n        return new DiffAlgorithmResult(result, false);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { OffsetRange } from '../../../core/offsetRange.js';\nimport { DiffAlgorithmResult, InfiniteTimeout, SequenceDiff } from './diffAlgorithm.js';\n/**\n * An O(ND) diff algorithm that has a quadratic space worst-case complexity.\n*/\nexport class MyersDiffAlgorithm {\n    compute(seq1, seq2, timeout = InfiniteTimeout.instance) {\n        // These are common special cases.\n        // The early return improves performance dramatically.\n        if (seq1.length === 0 || seq2.length === 0) {\n            return DiffAlgorithmResult.trivial(seq1, seq2);\n        }\n        const seqX = seq1; // Text on the x axis\n        const seqY = seq2; // Text on the y axis\n        function getXAfterSnake(x, y) {\n            while (x < seqX.length && y < seqY.length && seqX.getElement(x) === seqY.getElement(y)) {\n                x++;\n                y++;\n            }\n            return x;\n        }\n        let d = 0;\n        // V[k]: X value of longest d-line that ends in diagonal k.\n        // d-line: path from (0,0) to (x,y) that uses exactly d non-diagonals.\n        // diagonal k: Set of points (x,y) with x-y = k.\n        // k=1 -> (1,0),(2,1)\n        const V = new FastInt32Array();\n        V.set(0, getXAfterSnake(0, 0));\n        const paths = new FastArrayNegativeIndices();\n        paths.set(0, V.get(0) === 0 ? null : new SnakePath(null, 0, 0, V.get(0)));\n        let k = 0;\n        loop: while (true) {\n            d++;\n            if (!timeout.isValid()) {\n                return DiffAlgorithmResult.trivialTimedOut(seqX, seqY);\n            }\n            // The paper has `for (k = -d; k <= d; k += 2)`, but we can ignore diagonals that cannot influence the result.\n            const lowerBound = -Math.min(d, seqY.length + (d % 2));\n            const upperBound = Math.min(d, seqX.length + (d % 2));\n            for (k = lowerBound; k <= upperBound; k += 2) {\n                let step = 0;\n                // We can use the X values of (d-1)-lines to compute X value of the longest d-lines.\n                const maxXofDLineTop = k === upperBound ? -1 : V.get(k + 1); // We take a vertical non-diagonal (add a symbol in seqX)\n                const maxXofDLineLeft = k === lowerBound ? -1 : V.get(k - 1) + 1; // We take a horizontal non-diagonal (+1 x) (delete a symbol in seqX)\n                step++;\n                const x = Math.min(Math.max(maxXofDLineTop, maxXofDLineLeft), seqX.length);\n                const y = x - k;\n                step++;\n                if (x > seqX.length || y > seqY.length) {\n                    // This diagonal is irrelevant for the result.\n                    // TODO: Don't pay the cost for this in the next iteration.\n                    continue;\n                }\n                const newMaxX = getXAfterSnake(x, y);\n                V.set(k, newMaxX);\n                const lastPath = x === maxXofDLineTop ? paths.get(k + 1) : paths.get(k - 1);\n                paths.set(k, newMaxX !== x ? new SnakePath(lastPath, x, y, newMaxX - x) : lastPath);\n                if (V.get(k) === seqX.length && V.get(k) - k === seqY.length) {\n                    break loop;\n                }\n            }\n        }\n        let path = paths.get(k);\n        const result = [];\n        let lastAligningPosS1 = seqX.length;\n        let lastAligningPosS2 = seqY.length;\n        while (true) {\n            const endX = path ? path.x + path.length : 0;\n            const endY = path ? path.y + path.length : 0;\n            if (endX !== lastAligningPosS1 || endY !== lastAligningPosS2) {\n                result.push(new SequenceDiff(new OffsetRange(endX, lastAligningPosS1), new OffsetRange(endY, lastAligningPosS2)));\n            }\n            if (!path) {\n                break;\n            }\n            lastAligningPosS1 = path.x;\n            lastAligningPosS2 = path.y;\n            path = path.prev;\n        }\n        result.reverse();\n        return new DiffAlgorithmResult(result, false);\n    }\n}\nclass SnakePath {\n    constructor(prev, x, y, length) {\n        this.prev = prev;\n        this.x = x;\n        this.y = y;\n        this.length = length;\n    }\n}\n/**\n * An array that supports fast negative indices.\n*/\nclass FastInt32Array {\n    constructor() {\n        this.positiveArr = new Int32Array(10);\n        this.negativeArr = new Int32Array(10);\n    }\n    get(idx) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            return this.negativeArr[idx];\n        }\n        else {\n            return this.positiveArr[idx];\n        }\n    }\n    set(idx, value) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            if (idx >= this.negativeArr.length) {\n                const arr = this.negativeArr;\n                this.negativeArr = new Int32Array(arr.length * 2);\n                this.negativeArr.set(arr);\n            }\n            this.negativeArr[idx] = value;\n        }\n        else {\n            if (idx >= this.positiveArr.length) {\n                const arr = this.positiveArr;\n                this.positiveArr = new Int32Array(arr.length * 2);\n                this.positiveArr.set(arr);\n            }\n            this.positiveArr[idx] = value;\n        }\n    }\n}\n/**\n * An array that supports fast negative indices.\n*/\nclass FastArrayNegativeIndices {\n    constructor() {\n        this.positiveArr = [];\n        this.negativeArr = [];\n    }\n    get(idx) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            return this.negativeArr[idx];\n        }\n        else {\n            return this.positiveArr[idx];\n        }\n    }\n    set(idx, value) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            this.negativeArr[idx] = value;\n        }\n        else {\n            this.positiveArr[idx] = value;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { findLastIdxMonotonous, findLastMonotonous, findFirstMonotonous } from '../../../../base/common/arraysFind.js';\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { isSpace } from './utils.js';\nexport class LinesSliceCharSequence {\n    constructor(lines, range, considerWhitespaceChanges) {\n        this.lines = lines;\n        this.range = range;\n        this.considerWhitespaceChanges = considerWhitespaceChanges;\n        this.elements = [];\n        this.firstElementOffsetByLineIdx = [];\n        this.lineStartOffsets = [];\n        this.trimmedWsLengthsByLineIdx = [];\n        this.firstElementOffsetByLineIdx.push(0);\n        for (let lineNumber = this.range.startLineNumber; lineNumber <= this.range.endLineNumber; lineNumber++) {\n            let line = lines[lineNumber - 1];\n            let lineStartOffset = 0;\n            if (lineNumber === this.range.startLineNumber && this.range.startColumn > 1) {\n                lineStartOffset = this.range.startColumn - 1;\n                line = line.substring(lineStartOffset);\n            }\n            this.lineStartOffsets.push(lineStartOffset);\n            let trimmedWsLength = 0;\n            if (!considerWhitespaceChanges) {\n                const trimmedStartLine = line.trimStart();\n                trimmedWsLength = line.length - trimmedStartLine.length;\n                line = trimmedStartLine.trimEnd();\n            }\n            this.trimmedWsLengthsByLineIdx.push(trimmedWsLength);\n            const lineLength = lineNumber === this.range.endLineNumber ? Math.min(this.range.endColumn - 1 - lineStartOffset - trimmedWsLength, line.length) : line.length;\n            for (let i = 0; i < lineLength; i++) {\n                this.elements.push(line.charCodeAt(i));\n            }\n            if (lineNumber < this.range.endLineNumber) {\n                this.elements.push('\\n'.charCodeAt(0));\n                this.firstElementOffsetByLineIdx.push(this.elements.length);\n            }\n        }\n    }\n    toString() {\n        return `Slice: \"${this.text}\"`;\n    }\n    get text() {\n        return this.getText(new OffsetRange(0, this.length));\n    }\n    getText(range) {\n        return this.elements.slice(range.start, range.endExclusive).map(e => String.fromCharCode(e)).join('');\n    }\n    getElement(offset) {\n        return this.elements[offset];\n    }\n    get length() {\n        return this.elements.length;\n    }\n    getBoundaryScore(length) {\n        //   a   b   c   ,           d   e   f\n        // 11  0   0   12  15  6   13  0   0   11\n        const prevCategory = getCategory(length > 0 ? this.elements[length - 1] : -1);\n        const nextCategory = getCategory(length < this.elements.length ? this.elements[length] : -1);\n        if (prevCategory === 7 /* CharBoundaryCategory.LineBreakCR */ && nextCategory === 8 /* CharBoundaryCategory.LineBreakLF */) {\n            // don't break between \\r and \\n\n            return 0;\n        }\n        if (prevCategory === 8 /* CharBoundaryCategory.LineBreakLF */) {\n            // prefer the linebreak before the change\n            return 150;\n        }\n        let score = 0;\n        if (prevCategory !== nextCategory) {\n            score += 10;\n            if (prevCategory === 0 /* CharBoundaryCategory.WordLower */ && nextCategory === 1 /* CharBoundaryCategory.WordUpper */) {\n                score += 1;\n            }\n        }\n        score += getCategoryBoundaryScore(prevCategory);\n        score += getCategoryBoundaryScore(nextCategory);\n        return score;\n    }\n    translateOffset(offset, preference = 'right') {\n        // find smallest i, so that lineBreakOffsets[i] <= offset using binary search\n        const i = findLastIdxMonotonous(this.firstElementOffsetByLineIdx, (value) => value <= offset);\n        const lineOffset = offset - this.firstElementOffsetByLineIdx[i];\n        return new Position(this.range.startLineNumber + i, 1 + this.lineStartOffsets[i] + lineOffset + ((lineOffset === 0 && preference === 'left') ? 0 : this.trimmedWsLengthsByLineIdx[i]));\n    }\n    translateRange(range) {\n        const pos1 = this.translateOffset(range.start, 'right');\n        const pos2 = this.translateOffset(range.endExclusive, 'left');\n        if (pos2.isBefore(pos1)) {\n            return Range.fromPositions(pos2, pos2);\n        }\n        return Range.fromPositions(pos1, pos2);\n    }\n    /**\n     * Finds the word that contains the character at the given offset\n     */\n    findWordContaining(offset) {\n        if (offset < 0 || offset >= this.elements.length) {\n            return undefined;\n        }\n        if (!isWordChar(this.elements[offset])) {\n            return undefined;\n        }\n        // find start\n        let start = offset;\n        while (start > 0 && isWordChar(this.elements[start - 1])) {\n            start--;\n        }\n        // find end\n        let end = offset;\n        while (end < this.elements.length && isWordChar(this.elements[end])) {\n            end++;\n        }\n        return new OffsetRange(start, end);\n    }\n    countLinesIn(range) {\n        return this.translateOffset(range.endExclusive).lineNumber - this.translateOffset(range.start).lineNumber;\n    }\n    isStronglyEqual(offset1, offset2) {\n        return this.elements[offset1] === this.elements[offset2];\n    }\n    extendToFullLines(range) {\n        const start = findLastMonotonous(this.firstElementOffsetByLineIdx, x => x <= range.start) ?? 0;\n        const end = findFirstMonotonous(this.firstElementOffsetByLineIdx, x => range.endExclusive <= x) ?? this.elements.length;\n        return new OffsetRange(start, end);\n    }\n}\nfunction isWordChar(charCode) {\n    return charCode >= 97 /* CharCode.a */ && charCode <= 122 /* CharCode.z */\n        || charCode >= 65 /* CharCode.A */ && charCode <= 90 /* CharCode.Z */\n        || charCode >= 48 /* CharCode.Digit0 */ && charCode <= 57 /* CharCode.Digit9 */;\n}\nconst score = {\n    [0 /* CharBoundaryCategory.WordLower */]: 0,\n    [1 /* CharBoundaryCategory.WordUpper */]: 0,\n    [2 /* CharBoundaryCategory.WordNumber */]: 0,\n    [3 /* CharBoundaryCategory.End */]: 10,\n    [4 /* CharBoundaryCategory.Other */]: 2,\n    [5 /* CharBoundaryCategory.Separator */]: 30,\n    [6 /* CharBoundaryCategory.Space */]: 3,\n    [7 /* CharBoundaryCategory.LineBreakCR */]: 10,\n    [8 /* CharBoundaryCategory.LineBreakLF */]: 10,\n};\nfunction getCategoryBoundaryScore(category) {\n    return score[category];\n}\nfunction getCategory(charCode) {\n    if (charCode === 10 /* CharCode.LineFeed */) {\n        return 8 /* CharBoundaryCategory.LineBreakLF */;\n    }\n    else if (charCode === 13 /* CharCode.CarriageReturn */) {\n        return 7 /* CharBoundaryCategory.LineBreakCR */;\n    }\n    else if (isSpace(charCode)) {\n        return 6 /* CharBoundaryCategory.Space */;\n    }\n    else if (charCode >= 97 /* CharCode.a */ && charCode <= 122 /* CharCode.z */) {\n        return 0 /* CharBoundaryCategory.WordLower */;\n    }\n    else if (charCode >= 65 /* CharCode.A */ && charCode <= 90 /* CharCode.Z */) {\n        return 1 /* CharBoundaryCategory.WordUpper */;\n    }\n    else if (charCode >= 48 /* CharCode.Digit0 */ && charCode <= 57 /* CharCode.Digit9 */) {\n        return 2 /* CharBoundaryCategory.WordNumber */;\n    }\n    else if (charCode === -1) {\n        return 3 /* CharBoundaryCategory.End */;\n    }\n    else if (charCode === 44 /* CharCode.Comma */ || charCode === 59 /* CharCode.Semicolon */) {\n        return 5 /* CharBoundaryCategory.Separator */;\n    }\n    else {\n        return 4 /* CharBoundaryCategory.Other */;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SequenceDiff } from './algorithms/diffAlgorithm.js';\nimport { LineRangeMapping } from '../rangeMapping.js';\nimport { pushMany, compareBy, numberComparator, reverseOrder } from '../../../../base/common/arrays.js';\nimport { MonotonousArray, findLastMonotonous } from '../../../../base/common/arraysFind.js';\nimport { SetMap } from '../../../../base/common/map.js';\nimport { LineRange, LineRangeSet } from '../../core/lineRange.js';\nimport { LinesSliceCharSequence } from './linesSliceCharSequence.js';\nimport { LineRangeFragment, isSpace } from './utils.js';\nimport { MyersDiffAlgorithm } from './algorithms/myersDiffAlgorithm.js';\nimport { Range } from '../../core/range.js';\nexport function computeMovedLines(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout) {\n    let { moves, excludedChanges } = computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout);\n    if (!timeout.isValid()) {\n        return [];\n    }\n    const filteredChanges = changes.filter(c => !excludedChanges.has(c));\n    const unchangedMoves = computeUnchangedMoves(filteredChanges, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout);\n    pushMany(moves, unchangedMoves);\n    moves = joinCloseConsecutiveMoves(moves);\n    // Ignore too short moves\n    moves = moves.filter(current => {\n        const lines = current.original.toOffsetRange().slice(originalLines).map(l => l.trim());\n        const originalText = lines.join('\\n');\n        return originalText.length >= 15 && countWhere(lines, l => l.length >= 2) >= 2;\n    });\n    moves = removeMovesInSameDiff(changes, moves);\n    return moves;\n}\nfunction countWhere(arr, predicate) {\n    let count = 0;\n    for (const t of arr) {\n        if (predicate(t)) {\n            count++;\n        }\n    }\n    return count;\n}\nfunction computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout) {\n    const moves = [];\n    const deletions = changes\n        .filter(c => c.modified.isEmpty && c.original.length >= 3)\n        .map(d => new LineRangeFragment(d.original, originalLines, d));\n    const insertions = new Set(changes\n        .filter(c => c.original.isEmpty && c.modified.length >= 3)\n        .map(d => new LineRangeFragment(d.modified, modifiedLines, d)));\n    const excludedChanges = new Set();\n    for (const deletion of deletions) {\n        let highestSimilarity = -1;\n        let best;\n        for (const insertion of insertions) {\n            const similarity = deletion.computeSimilarity(insertion);\n            if (similarity > highestSimilarity) {\n                highestSimilarity = similarity;\n                best = insertion;\n            }\n        }\n        if (highestSimilarity > 0.90 && best) {\n            insertions.delete(best);\n            moves.push(new LineRangeMapping(deletion.range, best.range));\n            excludedChanges.add(deletion.source);\n            excludedChanges.add(best.source);\n        }\n        if (!timeout.isValid()) {\n            return { moves, excludedChanges };\n        }\n    }\n    return { moves, excludedChanges };\n}\nfunction computeUnchangedMoves(changes, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout) {\n    const moves = [];\n    const original3LineHashes = new SetMap();\n    for (const change of changes) {\n        for (let i = change.original.startLineNumber; i < change.original.endLineNumberExclusive - 2; i++) {\n            const key = `${hashedOriginalLines[i - 1]}:${hashedOriginalLines[i + 1 - 1]}:${hashedOriginalLines[i + 2 - 1]}`;\n            original3LineHashes.add(key, { range: new LineRange(i, i + 3) });\n        }\n    }\n    const possibleMappings = [];\n    changes.sort(compareBy(c => c.modified.startLineNumber, numberComparator));\n    for (const change of changes) {\n        let lastMappings = [];\n        for (let i = change.modified.startLineNumber; i < change.modified.endLineNumberExclusive - 2; i++) {\n            const key = `${hashedModifiedLines[i - 1]}:${hashedModifiedLines[i + 1 - 1]}:${hashedModifiedLines[i + 2 - 1]}`;\n            const currentModifiedRange = new LineRange(i, i + 3);\n            const nextMappings = [];\n            original3LineHashes.forEach(key, ({ range }) => {\n                for (const lastMapping of lastMappings) {\n                    // does this match extend some last match?\n                    if (lastMapping.originalLineRange.endLineNumberExclusive + 1 === range.endLineNumberExclusive &&\n                        lastMapping.modifiedLineRange.endLineNumberExclusive + 1 === currentModifiedRange.endLineNumberExclusive) {\n                        lastMapping.originalLineRange = new LineRange(lastMapping.originalLineRange.startLineNumber, range.endLineNumberExclusive);\n                        lastMapping.modifiedLineRange = new LineRange(lastMapping.modifiedLineRange.startLineNumber, currentModifiedRange.endLineNumberExclusive);\n                        nextMappings.push(lastMapping);\n                        return;\n                    }\n                }\n                const mapping = {\n                    modifiedLineRange: currentModifiedRange,\n                    originalLineRange: range,\n                };\n                possibleMappings.push(mapping);\n                nextMappings.push(mapping);\n            });\n            lastMappings = nextMappings;\n        }\n        if (!timeout.isValid()) {\n            return [];\n        }\n    }\n    possibleMappings.sort(reverseOrder(compareBy(m => m.modifiedLineRange.length, numberComparator)));\n    const modifiedSet = new LineRangeSet();\n    const originalSet = new LineRangeSet();\n    for (const mapping of possibleMappings) {\n        const diffOrigToMod = mapping.modifiedLineRange.startLineNumber - mapping.originalLineRange.startLineNumber;\n        const modifiedSections = modifiedSet.subtractFrom(mapping.modifiedLineRange);\n        const originalTranslatedSections = originalSet.subtractFrom(mapping.originalLineRange).getWithDelta(diffOrigToMod);\n        const modifiedIntersectedSections = modifiedSections.getIntersection(originalTranslatedSections);\n        for (const s of modifiedIntersectedSections.ranges) {\n            if (s.length < 3) {\n                continue;\n            }\n            const modifiedLineRange = s;\n            const originalLineRange = s.delta(-diffOrigToMod);\n            moves.push(new LineRangeMapping(originalLineRange, modifiedLineRange));\n            modifiedSet.addRange(modifiedLineRange);\n            originalSet.addRange(originalLineRange);\n        }\n    }\n    moves.sort(compareBy(m => m.original.startLineNumber, numberComparator));\n    const monotonousChanges = new MonotonousArray(changes);\n    for (let i = 0; i < moves.length; i++) {\n        const move = moves[i];\n        const firstTouchingChangeOrig = monotonousChanges.findLastMonotonous(c => c.original.startLineNumber <= move.original.startLineNumber);\n        const firstTouchingChangeMod = findLastMonotonous(changes, c => c.modified.startLineNumber <= move.modified.startLineNumber);\n        const linesAbove = Math.max(move.original.startLineNumber - firstTouchingChangeOrig.original.startLineNumber, move.modified.startLineNumber - firstTouchingChangeMod.modified.startLineNumber);\n        const lastTouchingChangeOrig = monotonousChanges.findLastMonotonous(c => c.original.startLineNumber < move.original.endLineNumberExclusive);\n        const lastTouchingChangeMod = findLastMonotonous(changes, c => c.modified.startLineNumber < move.modified.endLineNumberExclusive);\n        const linesBelow = Math.max(lastTouchingChangeOrig.original.endLineNumberExclusive - move.original.endLineNumberExclusive, lastTouchingChangeMod.modified.endLineNumberExclusive - move.modified.endLineNumberExclusive);\n        let extendToTop;\n        for (extendToTop = 0; extendToTop < linesAbove; extendToTop++) {\n            const origLine = move.original.startLineNumber - extendToTop - 1;\n            const modLine = move.modified.startLineNumber - extendToTop - 1;\n            if (origLine > originalLines.length || modLine > modifiedLines.length) {\n                break;\n            }\n            if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {\n                break;\n            }\n            if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {\n                break;\n            }\n        }\n        if (extendToTop > 0) {\n            originalSet.addRange(new LineRange(move.original.startLineNumber - extendToTop, move.original.startLineNumber));\n            modifiedSet.addRange(new LineRange(move.modified.startLineNumber - extendToTop, move.modified.startLineNumber));\n        }\n        let extendToBottom;\n        for (extendToBottom = 0; extendToBottom < linesBelow; extendToBottom++) {\n            const origLine = move.original.endLineNumberExclusive + extendToBottom;\n            const modLine = move.modified.endLineNumberExclusive + extendToBottom;\n            if (origLine > originalLines.length || modLine > modifiedLines.length) {\n                break;\n            }\n            if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {\n                break;\n            }\n            if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {\n                break;\n            }\n        }\n        if (extendToBottom > 0) {\n            originalSet.addRange(new LineRange(move.original.endLineNumberExclusive, move.original.endLineNumberExclusive + extendToBottom));\n            modifiedSet.addRange(new LineRange(move.modified.endLineNumberExclusive, move.modified.endLineNumberExclusive + extendToBottom));\n        }\n        if (extendToTop > 0 || extendToBottom > 0) {\n            moves[i] = new LineRangeMapping(new LineRange(move.original.startLineNumber - extendToTop, move.original.endLineNumberExclusive + extendToBottom), new LineRange(move.modified.startLineNumber - extendToTop, move.modified.endLineNumberExclusive + extendToBottom));\n        }\n    }\n    return moves;\n}\nfunction areLinesSimilar(line1, line2, timeout) {\n    if (line1.trim() === line2.trim()) {\n        return true;\n    }\n    if (line1.length > 300 && line2.length > 300) {\n        return false;\n    }\n    const myersDiffingAlgorithm = new MyersDiffAlgorithm();\n    const result = myersDiffingAlgorithm.compute(new LinesSliceCharSequence([line1], new Range(1, 1, 1, line1.length), false), new LinesSliceCharSequence([line2], new Range(1, 1, 1, line2.length), false), timeout);\n    let commonNonSpaceCharCount = 0;\n    const inverted = SequenceDiff.invert(result.diffs, line1.length);\n    for (const seq of inverted) {\n        seq.seq1Range.forEach(idx => {\n            if (!isSpace(line1.charCodeAt(idx))) {\n                commonNonSpaceCharCount++;\n            }\n        });\n    }\n    function countNonWsChars(str) {\n        let count = 0;\n        for (let i = 0; i < line1.length; i++) {\n            if (!isSpace(str.charCodeAt(i))) {\n                count++;\n            }\n        }\n        return count;\n    }\n    const longerLineLength = countNonWsChars(line1.length > line2.length ? line1 : line2);\n    const r = commonNonSpaceCharCount / longerLineLength > 0.6 && longerLineLength > 10;\n    return r;\n}\nfunction joinCloseConsecutiveMoves(moves) {\n    if (moves.length === 0) {\n        return moves;\n    }\n    moves.sort(compareBy(m => m.original.startLineNumber, numberComparator));\n    const result = [moves[0]];\n    for (let i = 1; i < moves.length; i++) {\n        const last = result[result.length - 1];\n        const current = moves[i];\n        const originalDist = current.original.startLineNumber - last.original.endLineNumberExclusive;\n        const modifiedDist = current.modified.startLineNumber - last.modified.endLineNumberExclusive;\n        const currentMoveAfterLast = originalDist >= 0 && modifiedDist >= 0;\n        if (currentMoveAfterLast && originalDist + modifiedDist <= 2) {\n            result[result.length - 1] = last.join(current);\n            continue;\n        }\n        result.push(current);\n    }\n    return result;\n}\nfunction removeMovesInSameDiff(changes, moves) {\n    const changesMonotonous = new MonotonousArray(changes);\n    moves = moves.filter(m => {\n        const diffBeforeEndOfMoveOriginal = changesMonotonous.findLastMonotonous(c => c.original.startLineNumber < m.original.endLineNumberExclusive)\n            || new LineRangeMapping(new LineRange(1, 1), new LineRange(1, 1));\n        const diffBeforeEndOfMoveModified = findLastMonotonous(changes, c => c.modified.startLineNumber < m.modified.endLineNumberExclusive);\n        const differentDiffs = diffBeforeEndOfMoveOriginal !== diffBeforeEndOfMoveModified;\n        return differentDiffs;\n    });\n    return moves;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class LineSequence {\n    constructor(trimmedHash, lines) {\n        this.trimmedHash = trimmedHash;\n        this.lines = lines;\n    }\n    getElement(offset) {\n        return this.trimmedHash[offset];\n    }\n    get length() {\n        return this.trimmedHash.length;\n    }\n    getBoundaryScore(length) {\n        const indentationBefore = length === 0 ? 0 : getIndentation(this.lines[length - 1]);\n        const indentationAfter = length === this.lines.length ? 0 : getIndentation(this.lines[length]);\n        return 1000 - (indentationBefore + indentationAfter);\n    }\n    getText(range) {\n        return this.lines.slice(range.start, range.endExclusive).join('\\n');\n    }\n    isStronglyEqual(offset1, offset2) {\n        return this.lines[offset1] === this.lines[offset2];\n    }\n}\nfunction getIndentation(str) {\n    let i = 0;\n    while (i < str.length && (str.charCodeAt(i) === 32 /* CharCode.Space */ || str.charCodeAt(i) === 9 /* CharCode.Tab */)) {\n        i++;\n    }\n    return i;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { equals, groupAdjacentBy } from '../../../../base/common/arrays.js';\nimport { assertFn, checkAdjacentItems } from '../../../../base/common/assert.js';\nimport { LineRange } from '../../core/lineRange.js';\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { Range } from '../../core/range.js';\nimport { DateTimeout, InfiniteTimeout, SequenceDiff } from './algorithms/diffAlgorithm.js';\nimport { DynamicProgrammingDiffing } from './algorithms/dynamicProgrammingDiffing.js';\nimport { MyersDiffAlgorithm } from './algorithms/myersDiffAlgorithm.js';\nimport { computeMovedLines } from './computeMovedLines.js';\nimport { extendDiffsToEntireWordIfAppropriate, optimizeSequenceDiffs, removeShortMatches, removeVeryShortMatchingLinesBetweenDiffs, removeVeryShortMatchingTextBetweenLongDiffs } from './heuristicSequenceOptimizations.js';\nimport { LineSequence } from './lineSequence.js';\nimport { LinesSliceCharSequence } from './linesSliceCharSequence.js';\nimport { LinesDiff, MovedText } from '../linesDiffComputer.js';\nimport { DetailedLineRangeMapping, LineRangeMapping, RangeMapping } from '../rangeMapping.js';\nexport class DefaultLinesDiffComputer {\n    constructor() {\n        this.dynamicProgrammingDiffing = new DynamicProgrammingDiffing();\n        this.myersDiffingAlgorithm = new MyersDiffAlgorithm();\n    }\n    computeDiff(originalLines, modifiedLines, options) {\n        if (originalLines.length <= 1 && equals(originalLines, modifiedLines, (a, b) => a === b)) {\n            return new LinesDiff([], [], false);\n        }\n        if (originalLines.length === 1 && originalLines[0].length === 0 || modifiedLines.length === 1 && modifiedLines[0].length === 0) {\n            return new LinesDiff([\n                new DetailedLineRangeMapping(new LineRange(1, originalLines.length + 1), new LineRange(1, modifiedLines.length + 1), [\n                    new RangeMapping(new Range(1, 1, originalLines.length, originalLines[originalLines.length - 1].length + 1), new Range(1, 1, modifiedLines.length, modifiedLines[modifiedLines.length - 1].length + 1))\n                ])\n            ], [], false);\n        }\n        const timeout = options.maxComputationTimeMs === 0 ? InfiniteTimeout.instance : new DateTimeout(options.maxComputationTimeMs);\n        const considerWhitespaceChanges = !options.ignoreTrimWhitespace;\n        const perfectHashes = new Map();\n        function getOrCreateHash(text) {\n            let hash = perfectHashes.get(text);\n            if (hash === undefined) {\n                hash = perfectHashes.size;\n                perfectHashes.set(text, hash);\n            }\n            return hash;\n        }\n        const originalLinesHashes = originalLines.map((l) => getOrCreateHash(l.trim()));\n        const modifiedLinesHashes = modifiedLines.map((l) => getOrCreateHash(l.trim()));\n        const sequence1 = new LineSequence(originalLinesHashes, originalLines);\n        const sequence2 = new LineSequence(modifiedLinesHashes, modifiedLines);\n        const lineAlignmentResult = (() => {\n            if (sequence1.length + sequence2.length < 1700) {\n                // Use the improved algorithm for small files\n                return this.dynamicProgrammingDiffing.compute(sequence1, sequence2, timeout, (offset1, offset2) => originalLines[offset1] === modifiedLines[offset2]\n                    ? modifiedLines[offset2].length === 0\n                        ? 0.1\n                        : 1 + Math.log(1 + modifiedLines[offset2].length)\n                    : 0.99);\n            }\n            return this.myersDiffingAlgorithm.compute(sequence1, sequence2, timeout);\n        })();\n        let lineAlignments = lineAlignmentResult.diffs;\n        let hitTimeout = lineAlignmentResult.hitTimeout;\n        lineAlignments = optimizeSequenceDiffs(sequence1, sequence2, lineAlignments);\n        lineAlignments = removeVeryShortMatchingLinesBetweenDiffs(sequence1, sequence2, lineAlignments);\n        const alignments = [];\n        const scanForWhitespaceChanges = (equalLinesCount) => {\n            if (!considerWhitespaceChanges) {\n                return;\n            }\n            for (let i = 0; i < equalLinesCount; i++) {\n                const seq1Offset = seq1LastStart + i;\n                const seq2Offset = seq2LastStart + i;\n                if (originalLines[seq1Offset] !== modifiedLines[seq2Offset]) {\n                    // This is because of whitespace changes, diff these lines\n                    const characterDiffs = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(new OffsetRange(seq1Offset, seq1Offset + 1), new OffsetRange(seq2Offset, seq2Offset + 1)), timeout, considerWhitespaceChanges);\n                    for (const a of characterDiffs.mappings) {\n                        alignments.push(a);\n                    }\n                    if (characterDiffs.hitTimeout) {\n                        hitTimeout = true;\n                    }\n                }\n            }\n        };\n        let seq1LastStart = 0;\n        let seq2LastStart = 0;\n        for (const diff of lineAlignments) {\n            assertFn(() => diff.seq1Range.start - seq1LastStart === diff.seq2Range.start - seq2LastStart);\n            const equalLinesCount = diff.seq1Range.start - seq1LastStart;\n            scanForWhitespaceChanges(equalLinesCount);\n            seq1LastStart = diff.seq1Range.endExclusive;\n            seq2LastStart = diff.seq2Range.endExclusive;\n            const characterDiffs = this.refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges);\n            if (characterDiffs.hitTimeout) {\n                hitTimeout = true;\n            }\n            for (const a of characterDiffs.mappings) {\n                alignments.push(a);\n            }\n        }\n        scanForWhitespaceChanges(originalLines.length - seq1LastStart);\n        const changes = lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines);\n        let moves = [];\n        if (options.computeMoves) {\n            moves = this.computeMoves(changes, originalLines, modifiedLines, originalLinesHashes, modifiedLinesHashes, timeout, considerWhitespaceChanges);\n        }\n        // Make sure all ranges are valid\n        assertFn(() => {\n            function validatePosition(pos, lines) {\n                if (pos.lineNumber < 1 || pos.lineNumber > lines.length) {\n                    return false;\n                }\n                const line = lines[pos.lineNumber - 1];\n                if (pos.column < 1 || pos.column > line.length + 1) {\n                    return false;\n                }\n                return true;\n            }\n            function validateRange(range, lines) {\n                if (range.startLineNumber < 1 || range.startLineNumber > lines.length + 1) {\n                    return false;\n                }\n                if (range.endLineNumberExclusive < 1 || range.endLineNumberExclusive > lines.length + 1) {\n                    return false;\n                }\n                return true;\n            }\n            for (const c of changes) {\n                if (!c.innerChanges) {\n                    return false;\n                }\n                for (const ic of c.innerChanges) {\n                    const valid = validatePosition(ic.modifiedRange.getStartPosition(), modifiedLines) && validatePosition(ic.modifiedRange.getEndPosition(), modifiedLines) &&\n                        validatePosition(ic.originalRange.getStartPosition(), originalLines) && validatePosition(ic.originalRange.getEndPosition(), originalLines);\n                    if (!valid) {\n                        return false;\n                    }\n                }\n                if (!validateRange(c.modified, modifiedLines) || !validateRange(c.original, originalLines)) {\n                    return false;\n                }\n            }\n            return true;\n        });\n        return new LinesDiff(changes, moves, hitTimeout);\n    }\n    computeMoves(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout, considerWhitespaceChanges) {\n        const moves = computeMovedLines(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout);\n        const movesWithDiffs = moves.map(m => {\n            const moveChanges = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(m.original.toOffsetRange(), m.modified.toOffsetRange()), timeout, considerWhitespaceChanges);\n            const mappings = lineRangeMappingFromRangeMappings(moveChanges.mappings, originalLines, modifiedLines, true);\n            return new MovedText(m, mappings);\n        });\n        return movesWithDiffs;\n    }\n    refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges) {\n        const lineRangeMapping = toLineRangeMapping(diff);\n        const rangeMapping = lineRangeMapping.toRangeMapping2(originalLines, modifiedLines);\n        const slice1 = new LinesSliceCharSequence(originalLines, rangeMapping.originalRange, considerWhitespaceChanges);\n        const slice2 = new LinesSliceCharSequence(modifiedLines, rangeMapping.modifiedRange, considerWhitespaceChanges);\n        const diffResult = slice1.length + slice2.length < 500\n            ? this.dynamicProgrammingDiffing.compute(slice1, slice2, timeout)\n            : this.myersDiffingAlgorithm.compute(slice1, slice2, timeout);\n        const check = false;\n        let diffs = diffResult.diffs;\n        if (check) {\n            SequenceDiff.assertSorted(diffs);\n        }\n        diffs = optimizeSequenceDiffs(slice1, slice2, diffs);\n        if (check) {\n            SequenceDiff.assertSorted(diffs);\n        }\n        diffs = extendDiffsToEntireWordIfAppropriate(slice1, slice2, diffs);\n        if (check) {\n            SequenceDiff.assertSorted(diffs);\n        }\n        diffs = removeShortMatches(slice1, slice2, diffs);\n        if (check) {\n            SequenceDiff.assertSorted(diffs);\n        }\n        diffs = removeVeryShortMatchingTextBetweenLongDiffs(slice1, slice2, diffs);\n        if (check) {\n            SequenceDiff.assertSorted(diffs);\n        }\n        const result = diffs.map((d) => new RangeMapping(slice1.translateRange(d.seq1Range), slice2.translateRange(d.seq2Range)));\n        if (check) {\n            RangeMapping.assertSorted(result);\n        }\n        // Assert: result applied on original should be the same as diff applied to original\n        return {\n            mappings: result,\n            hitTimeout: diffResult.hitTimeout,\n        };\n    }\n}\nexport function lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines, dontAssertStartLine = false) {\n    const changes = [];\n    for (const g of groupAdjacentBy(alignments.map(a => getLineRangeMapping(a, originalLines, modifiedLines)), (a1, a2) => a1.original.overlapOrTouch(a2.original)\n        || a1.modified.overlapOrTouch(a2.modified))) {\n        const first = g[0];\n        const last = g[g.length - 1];\n        changes.push(new DetailedLineRangeMapping(first.original.join(last.original), first.modified.join(last.modified), g.map(a => a.innerChanges[0])));\n    }\n    assertFn(() => {\n        if (!dontAssertStartLine && changes.length > 0) {\n            if (changes[0].modified.startLineNumber !== changes[0].original.startLineNumber) {\n                return false;\n            }\n            if (modifiedLines.length - changes[changes.length - 1].modified.endLineNumberExclusive !== originalLines.length - changes[changes.length - 1].original.endLineNumberExclusive) {\n                return false;\n            }\n        }\n        return checkAdjacentItems(changes, (m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive &&\n            // There has to be an unchanged line in between (otherwise both diffs should have been joined)\n            m1.original.endLineNumberExclusive < m2.original.startLineNumber &&\n            m1.modified.endLineNumberExclusive < m2.modified.startLineNumber);\n    });\n    return changes;\n}\nexport function getLineRangeMapping(rangeMapping, originalLines, modifiedLines) {\n    let lineStartDelta = 0;\n    let lineEndDelta = 0;\n    // rangeMapping describes the edit that replaces `rangeMapping.originalRange` with `newText := getText(modifiedLines, rangeMapping.modifiedRange)`.\n    // original: ]xxx \\n <- this line is not modified\n    // modified: ]xx  \\n\n    if (rangeMapping.modifiedRange.endColumn === 1 && rangeMapping.originalRange.endColumn === 1\n        && rangeMapping.originalRange.startLineNumber + lineStartDelta <= rangeMapping.originalRange.endLineNumber\n        && rangeMapping.modifiedRange.startLineNumber + lineStartDelta <= rangeMapping.modifiedRange.endLineNumber) {\n        // We can only do this if the range is not empty yet\n        lineEndDelta = -1;\n    }\n    // original: xxx[ \\n <- this line is not modified\n    // modified: xxx[ \\n\n    if (rangeMapping.modifiedRange.startColumn - 1 >= modifiedLines[rangeMapping.modifiedRange.startLineNumber - 1].length\n        && rangeMapping.originalRange.startColumn - 1 >= originalLines[rangeMapping.originalRange.startLineNumber - 1].length\n        && rangeMapping.originalRange.startLineNumber <= rangeMapping.originalRange.endLineNumber + lineEndDelta\n        && rangeMapping.modifiedRange.startLineNumber <= rangeMapping.modifiedRange.endLineNumber + lineEndDelta) {\n        // We can only do this if the range is not empty yet\n        lineStartDelta = 1;\n    }\n    const originalLineRange = new LineRange(rangeMapping.originalRange.startLineNumber + lineStartDelta, rangeMapping.originalRange.endLineNumber + 1 + lineEndDelta);\n    const modifiedLineRange = new LineRange(rangeMapping.modifiedRange.startLineNumber + lineStartDelta, rangeMapping.modifiedRange.endLineNumber + 1 + lineEndDelta);\n    return new DetailedLineRangeMapping(originalLineRange, modifiedLineRange, [rangeMapping]);\n}\nfunction toLineRangeMapping(sequenceDiff) {\n    return new LineRangeMapping(new LineRange(sequenceDiff.seq1Range.start + 1, sequenceDiff.seq1Range.endExclusive + 1), new LineRange(sequenceDiff.seq2Range.start + 1, sequenceDiff.seq2Range.endExclusive + 1));\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { forEachWithNeighbors } from '../../../../base/common/arrays.js';\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { OffsetPair, SequenceDiff } from './algorithms/diffAlgorithm.js';\nexport function optimizeSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    let result = sequenceDiffs;\n    result = joinSequenceDiffsByShifting(sequence1, sequence2, result);\n    // Sometimes, calling this function twice improves the result.\n    // Uncomment the second invocation and run the tests to see the difference.\n    result = joinSequenceDiffsByShifting(sequence1, sequence2, result);\n    result = shiftSequenceDiffs(sequence1, sequence2, result);\n    return result;\n}\n/**\n * This function fixes issues like this:\n * ```\n * import { Baz, Bar } from \"foo\";\n * ```\n * <->\n * ```\n * import { Baz, Bar, Foo } from \"foo\";\n * ```\n * Computed diff: [ {Add \",\" after Bar}, {Add \"Foo \" after space} }\n * Improved diff: [{Add \", Foo\" after Bar}]\n */\nfunction joinSequenceDiffsByShifting(sequence1, sequence2, sequenceDiffs) {\n    if (sequenceDiffs.length === 0) {\n        return sequenceDiffs;\n    }\n    const result = [];\n    result.push(sequenceDiffs[0]);\n    // First move them all to the left as much as possible and join them if possible\n    for (let i = 1; i < sequenceDiffs.length; i++) {\n        const prevResult = result[result.length - 1];\n        let cur = sequenceDiffs[i];\n        if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n            const length = cur.seq1Range.start - prevResult.seq1Range.endExclusive;\n            let d;\n            for (d = 1; d <= length; d++) {\n                if (sequence1.getElement(cur.seq1Range.start - d) !== sequence1.getElement(cur.seq1Range.endExclusive - d) ||\n                    sequence2.getElement(cur.seq2Range.start - d) !== sequence2.getElement(cur.seq2Range.endExclusive - d)) {\n                    break;\n                }\n            }\n            d--;\n            if (d === length) {\n                // Merge previous and current diff\n                result[result.length - 1] = new SequenceDiff(new OffsetRange(prevResult.seq1Range.start, cur.seq1Range.endExclusive - length), new OffsetRange(prevResult.seq2Range.start, cur.seq2Range.endExclusive - length));\n                continue;\n            }\n            cur = cur.delta(-d);\n        }\n        result.push(cur);\n    }\n    const result2 = [];\n    // Then move them all to the right and join them again if possible\n    for (let i = 0; i < result.length - 1; i++) {\n        const nextResult = result[i + 1];\n        let cur = result[i];\n        if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n            const length = nextResult.seq1Range.start - cur.seq1Range.endExclusive;\n            let d;\n            for (d = 0; d < length; d++) {\n                if (!sequence1.isStronglyEqual(cur.seq1Range.start + d, cur.seq1Range.endExclusive + d) ||\n                    !sequence2.isStronglyEqual(cur.seq2Range.start + d, cur.seq2Range.endExclusive + d)) {\n                    break;\n                }\n            }\n            if (d === length) {\n                // Merge previous and current diff, write to result!\n                result[i + 1] = new SequenceDiff(new OffsetRange(cur.seq1Range.start + length, nextResult.seq1Range.endExclusive), new OffsetRange(cur.seq2Range.start + length, nextResult.seq2Range.endExclusive));\n                continue;\n            }\n            if (d > 0) {\n                cur = cur.delta(d);\n            }\n        }\n        result2.push(cur);\n    }\n    if (result.length > 0) {\n        result2.push(result[result.length - 1]);\n    }\n    return result2;\n}\n// align character level diffs at whitespace characters\n// import { IBar } from \"foo\";\n// import { I[Arr, I]Bar } from \"foo\";\n// ->\n// import { [IArr, ]IBar } from \"foo\";\n// import { ITransaction, observableValue, transaction } from 'vs/base/common/observable';\n// import { ITransaction, observable[FromEvent, observable]Value, transaction } from 'vs/base/common/observable';\n// ->\n// import { ITransaction, [observableFromEvent, ]observableValue, transaction } from 'vs/base/common/observable';\n// collectBrackets(level + 1, levelPerBracketType);\n// collectBrackets(level + 1, levelPerBracket[ + 1, levelPerBracket]Type);\n// ->\n// collectBrackets(level + 1, [levelPerBracket + 1, ]levelPerBracketType);\nfunction shiftSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    if (!sequence1.getBoundaryScore || !sequence2.getBoundaryScore) {\n        return sequenceDiffs;\n    }\n    for (let i = 0; i < sequenceDiffs.length; i++) {\n        const prevDiff = (i > 0 ? sequenceDiffs[i - 1] : undefined);\n        const diff = sequenceDiffs[i];\n        const nextDiff = (i + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1] : undefined);\n        const seq1ValidRange = new OffsetRange(prevDiff ? prevDiff.seq1Range.endExclusive + 1 : 0, nextDiff ? nextDiff.seq1Range.start - 1 : sequence1.length);\n        const seq2ValidRange = new OffsetRange(prevDiff ? prevDiff.seq2Range.endExclusive + 1 : 0, nextDiff ? nextDiff.seq2Range.start - 1 : sequence2.length);\n        if (diff.seq1Range.isEmpty) {\n            sequenceDiffs[i] = shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange);\n        }\n        else if (diff.seq2Range.isEmpty) {\n            sequenceDiffs[i] = shiftDiffToBetterPosition(diff.swap(), sequence2, sequence1, seq2ValidRange, seq1ValidRange).swap();\n        }\n    }\n    return sequenceDiffs;\n}\nfunction shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange) {\n    const maxShiftLimit = 100; // To prevent performance issues\n    // don't touch previous or next!\n    let deltaBefore = 1;\n    while (diff.seq1Range.start - deltaBefore >= seq1ValidRange.start &&\n        diff.seq2Range.start - deltaBefore >= seq2ValidRange.start &&\n        sequence2.isStronglyEqual(diff.seq2Range.start - deltaBefore, diff.seq2Range.endExclusive - deltaBefore) && deltaBefore < maxShiftLimit) {\n        deltaBefore++;\n    }\n    deltaBefore--;\n    let deltaAfter = 0;\n    while (diff.seq1Range.start + deltaAfter < seq1ValidRange.endExclusive &&\n        diff.seq2Range.endExclusive + deltaAfter < seq2ValidRange.endExclusive &&\n        sequence2.isStronglyEqual(diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter) && deltaAfter < maxShiftLimit) {\n        deltaAfter++;\n    }\n    if (deltaBefore === 0 && deltaAfter === 0) {\n        return diff;\n    }\n    // Visualize `[sequence1.text, diff.seq1Range.start + deltaAfter]`\n    // and `[sequence2.text, diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter]`\n    let bestDelta = 0;\n    let bestScore = -1;\n    // find best scored delta\n    for (let delta = -deltaBefore; delta <= deltaAfter; delta++) {\n        const seq2OffsetStart = diff.seq2Range.start + delta;\n        const seq2OffsetEndExclusive = diff.seq2Range.endExclusive + delta;\n        const seq1Offset = diff.seq1Range.start + delta;\n        const score = sequence1.getBoundaryScore(seq1Offset) + sequence2.getBoundaryScore(seq2OffsetStart) + sequence2.getBoundaryScore(seq2OffsetEndExclusive);\n        if (score > bestScore) {\n            bestScore = score;\n            bestDelta = delta;\n        }\n    }\n    return diff.delta(bestDelta);\n}\nexport function removeShortMatches(sequence1, sequence2, sequenceDiffs) {\n    const result = [];\n    for (const s of sequenceDiffs) {\n        const last = result[result.length - 1];\n        if (!last) {\n            result.push(s);\n            continue;\n        }\n        if (s.seq1Range.start - last.seq1Range.endExclusive <= 2 || s.seq2Range.start - last.seq2Range.endExclusive <= 2) {\n            result[result.length - 1] = new SequenceDiff(last.seq1Range.join(s.seq1Range), last.seq2Range.join(s.seq2Range));\n        }\n        else {\n            result.push(s);\n        }\n    }\n    return result;\n}\nexport function extendDiffsToEntireWordIfAppropriate(sequence1, sequence2, sequenceDiffs) {\n    const equalMappings = SequenceDiff.invert(sequenceDiffs, sequence1.length);\n    const additional = [];\n    let lastPoint = new OffsetPair(0, 0);\n    function scanWord(pair, equalMapping) {\n        if (pair.offset1 < lastPoint.offset1 || pair.offset2 < lastPoint.offset2) {\n            return;\n        }\n        const w1 = sequence1.findWordContaining(pair.offset1);\n        const w2 = sequence2.findWordContaining(pair.offset2);\n        if (!w1 || !w2) {\n            return;\n        }\n        let w = new SequenceDiff(w1, w2);\n        const equalPart = w.intersect(equalMapping);\n        let equalChars1 = equalPart.seq1Range.length;\n        let equalChars2 = equalPart.seq2Range.length;\n        // The words do not touch previous equals mappings, as we would have processed them already.\n        // But they might touch the next ones.\n        while (equalMappings.length > 0) {\n            const next = equalMappings[0];\n            const intersects = next.seq1Range.intersects(w.seq1Range) || next.seq2Range.intersects(w.seq2Range);\n            if (!intersects) {\n                break;\n            }\n            const v1 = sequence1.findWordContaining(next.seq1Range.start);\n            const v2 = sequence2.findWordContaining(next.seq2Range.start);\n            // Because there is an intersection, we know that the words are not empty.\n            const v = new SequenceDiff(v1, v2);\n            const equalPart = v.intersect(next);\n            equalChars1 += equalPart.seq1Range.length;\n            equalChars2 += equalPart.seq2Range.length;\n            w = w.join(v);\n            if (w.seq1Range.endExclusive >= next.seq1Range.endExclusive) {\n                // The word extends beyond the next equal mapping.\n                equalMappings.shift();\n            }\n            else {\n                break;\n            }\n        }\n        if (equalChars1 + equalChars2 < (w.seq1Range.length + w.seq2Range.length) * 2 / 3) {\n            additional.push(w);\n        }\n        lastPoint = w.getEndExclusives();\n    }\n    while (equalMappings.length > 0) {\n        const next = equalMappings.shift();\n        if (next.seq1Range.isEmpty) {\n            continue;\n        }\n        scanWord(next.getStarts(), next);\n        // The equal parts are not empty, so -1 gives us a character that is equal in both parts.\n        scanWord(next.getEndExclusives().delta(-1), next);\n    }\n    const merged = mergeSequenceDiffs(sequenceDiffs, additional);\n    return merged;\n}\nfunction mergeSequenceDiffs(sequenceDiffs1, sequenceDiffs2) {\n    const result = [];\n    while (sequenceDiffs1.length > 0 || sequenceDiffs2.length > 0) {\n        const sd1 = sequenceDiffs1[0];\n        const sd2 = sequenceDiffs2[0];\n        let next;\n        if (sd1 && (!sd2 || sd1.seq1Range.start < sd2.seq1Range.start)) {\n            next = sequenceDiffs1.shift();\n        }\n        else {\n            next = sequenceDiffs2.shift();\n        }\n        if (result.length > 0 && result[result.length - 1].seq1Range.endExclusive >= next.seq1Range.start) {\n            result[result.length - 1] = result[result.length - 1].join(next);\n        }\n        else {\n            result.push(next);\n        }\n    }\n    return result;\n}\nexport function removeVeryShortMatchingLinesBetweenDiffs(sequence1, _sequence2, sequenceDiffs) {\n    let diffs = sequenceDiffs;\n    if (diffs.length === 0) {\n        return diffs;\n    }\n    let counter = 0;\n    let shouldRepeat;\n    do {\n        shouldRepeat = false;\n        const result = [\n            diffs[0]\n        ];\n        for (let i = 1; i < diffs.length; i++) {\n            const cur = diffs[i];\n            const lastResult = result[result.length - 1];\n            function shouldJoinDiffs(before, after) {\n                const unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);\n                const unchangedText = sequence1.getText(unchangedRange);\n                const unchangedTextWithoutWs = unchangedText.replace(/\\s/g, '');\n                if (unchangedTextWithoutWs.length <= 4\n                    && (before.seq1Range.length + before.seq2Range.length > 5 || after.seq1Range.length + after.seq2Range.length > 5)) {\n                    return true;\n                }\n                return false;\n            }\n            const shouldJoin = shouldJoinDiffs(lastResult, cur);\n            if (shouldJoin) {\n                shouldRepeat = true;\n                result[result.length - 1] = result[result.length - 1].join(cur);\n            }\n            else {\n                result.push(cur);\n            }\n        }\n        diffs = result;\n    } while (counter++ < 10 && shouldRepeat);\n    return diffs;\n}\nexport function removeVeryShortMatchingTextBetweenLongDiffs(sequence1, sequence2, sequenceDiffs) {\n    let diffs = sequenceDiffs;\n    if (diffs.length === 0) {\n        return diffs;\n    }\n    let counter = 0;\n    let shouldRepeat;\n    do {\n        shouldRepeat = false;\n        const result = [\n            diffs[0]\n        ];\n        for (let i = 1; i < diffs.length; i++) {\n            const cur = diffs[i];\n            const lastResult = result[result.length - 1];\n            function shouldJoinDiffs(before, after) {\n                const unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);\n                const unchangedLineCount = sequence1.countLinesIn(unchangedRange);\n                if (unchangedLineCount > 5 || unchangedRange.length > 500) {\n                    return false;\n                }\n                const unchangedText = sequence1.getText(unchangedRange).trim();\n                if (unchangedText.length > 20 || unchangedText.split(/\\r\\n|\\r|\\n/).length > 1) {\n                    return false;\n                }\n                const beforeLineCount1 = sequence1.countLinesIn(before.seq1Range);\n                const beforeSeq1Length = before.seq1Range.length;\n                const beforeLineCount2 = sequence2.countLinesIn(before.seq2Range);\n                const beforeSeq2Length = before.seq2Range.length;\n                const afterLineCount1 = sequence1.countLinesIn(after.seq1Range);\n                const afterSeq1Length = after.seq1Range.length;\n                const afterLineCount2 = sequence2.countLinesIn(after.seq2Range);\n                const afterSeq2Length = after.seq2Range.length;\n                // TODO: Maybe a neural net can be used to derive the result from these numbers\n                const max = 2 * 40 + 50;\n                function cap(v) {\n                    return Math.min(v, max);\n                }\n                if (Math.pow(Math.pow(cap(beforeLineCount1 * 40 + beforeSeq1Length), 1.5) + Math.pow(cap(beforeLineCount2 * 40 + beforeSeq2Length), 1.5), 1.5)\n                    + Math.pow(Math.pow(cap(afterLineCount1 * 40 + afterSeq1Length), 1.5) + Math.pow(cap(afterLineCount2 * 40 + afterSeq2Length), 1.5), 1.5) > ((max ** 1.5) ** 1.5) * 1.3) {\n                    return true;\n                }\n                return false;\n            }\n            const shouldJoin = shouldJoinDiffs(lastResult, cur);\n            if (shouldJoin) {\n                shouldRepeat = true;\n                result[result.length - 1] = result[result.length - 1].join(cur);\n            }\n            else {\n                result.push(cur);\n            }\n        }\n        diffs = result;\n    } while (counter++ < 10 && shouldRepeat);\n    const newDiffs = [];\n    // Remove short suffixes/prefixes\n    forEachWithNeighbors(diffs, (prev, cur, next) => {\n        let newDiff = cur;\n        function shouldMarkAsChanged(text) {\n            return text.length > 0 && text.trim().length <= 3 && cur.seq1Range.length + cur.seq2Range.length > 100;\n        }\n        const fullRange1 = sequence1.extendToFullLines(cur.seq1Range);\n        const prefix = sequence1.getText(new OffsetRange(fullRange1.start, cur.seq1Range.start));\n        if (shouldMarkAsChanged(prefix)) {\n            newDiff = newDiff.deltaStart(-prefix.length);\n        }\n        const suffix = sequence1.getText(new OffsetRange(cur.seq1Range.endExclusive, fullRange1.endExclusive));\n        if (shouldMarkAsChanged(suffix)) {\n            newDiff = newDiff.deltaEnd(suffix.length);\n        }\n        const availableSpace = SequenceDiff.fromOffsetPairs(prev ? prev.getEndExclusives() : OffsetPair.zero, next ? next.getStarts() : OffsetPair.max);\n        const result = newDiff.intersect(availableSpace);\n        if (newDiffs.length > 0 && result.getStarts().equals(newDiffs[newDiffs.length - 1].getEndExclusives())) {\n            newDiffs[newDiffs.length - 1] = newDiffs[newDiffs.length - 1].join(result);\n        }\n        else {\n            newDiffs.push(result);\n        }\n    });\n    return newDiffs;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class LinesDiff {\n    constructor(changes, \n    /**\n     * Sorted by original line ranges.\n     * The original line ranges and the modified line ranges must be disjoint (but can be touching).\n     */\n    moves, \n    /**\n     * Indicates if the time out was reached.\n     * In that case, the diffs might be an approximation and the user should be asked to rerun the diff with more time.\n     */\n    hitTimeout) {\n        this.changes = changes;\n        this.moves = moves;\n        this.hitTimeout = hitTimeout;\n    }\n}\nexport class MovedText {\n    constructor(lineRangeMapping, changes) {\n        this.lineRangeMapping = lineRangeMapping;\n        this.changes = changes;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { SingleTextEdit } from '../core/textEdit.js';\n/**\n * Maps a line range in the original text model to a line range in the modified text model.\n */\nexport class LineRangeMapping {\n    static inverse(mapping, originalLineCount, modifiedLineCount) {\n        const result = [];\n        let lastOriginalEndLineNumber = 1;\n        let lastModifiedEndLineNumber = 1;\n        for (const m of mapping) {\n            const r = new LineRangeMapping(new LineRange(lastOriginalEndLineNumber, m.original.startLineNumber), new LineRange(lastModifiedEndLineNumber, m.modified.startLineNumber));\n            if (!r.modified.isEmpty) {\n                result.push(r);\n            }\n            lastOriginalEndLineNumber = m.original.endLineNumberExclusive;\n            lastModifiedEndLineNumber = m.modified.endLineNumberExclusive;\n        }\n        const r = new LineRangeMapping(new LineRange(lastOriginalEndLineNumber, originalLineCount + 1), new LineRange(lastModifiedEndLineNumber, modifiedLineCount + 1));\n        if (!r.modified.isEmpty) {\n            result.push(r);\n        }\n        return result;\n    }\n    static clip(mapping, originalRange, modifiedRange) {\n        const result = [];\n        for (const m of mapping) {\n            const original = m.original.intersect(originalRange);\n            const modified = m.modified.intersect(modifiedRange);\n            if (original && !original.isEmpty && modified && !modified.isEmpty) {\n                result.push(new LineRangeMapping(original, modified));\n            }\n        }\n        return result;\n    }\n    constructor(originalRange, modifiedRange) {\n        this.original = originalRange;\n        this.modified = modifiedRange;\n    }\n    toString() {\n        return `{${this.original.toString()}->${this.modified.toString()}}`;\n    }\n    flip() {\n        return new LineRangeMapping(this.modified, this.original);\n    }\n    join(other) {\n        return new LineRangeMapping(this.original.join(other.original), this.modified.join(other.modified));\n    }\n    /**\n     * This method assumes that the LineRangeMapping describes a valid diff!\n     * I.e. if one range is empty, the other range cannot be the entire document.\n     * It avoids various problems when the line range points to non-existing line-numbers.\n    */\n    toRangeMapping() {\n        const origInclusiveRange = this.original.toInclusiveRange();\n        const modInclusiveRange = this.modified.toInclusiveRange();\n        if (origInclusiveRange && modInclusiveRange) {\n            return new RangeMapping(origInclusiveRange, modInclusiveRange);\n        }\n        else if (this.original.startLineNumber === 1 || this.modified.startLineNumber === 1) {\n            if (!(this.modified.startLineNumber === 1 && this.original.startLineNumber === 1)) {\n                // If one line range starts at 1, the other one must start at 1 as well.\n                throw new BugIndicatingError('not a valid diff');\n            }\n            // Because one range is empty and both ranges start at line 1, none of the ranges can cover all lines.\n            // Thus, `endLineNumberExclusive` is a valid line number.\n            return new RangeMapping(new Range(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1), new Range(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1));\n        }\n        else {\n            // We can assume here that both startLineNumbers are greater than 1.\n            return new RangeMapping(new Range(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), new Range(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER));\n        }\n    }\n    /**\n     * This method assumes that the LineRangeMapping describes a valid diff!\n     * I.e. if one range is empty, the other range cannot be the entire document.\n     * It avoids various problems when the line range points to non-existing line-numbers.\n    */\n    toRangeMapping2(original, modified) {\n        if (isValidLineNumber(this.original.endLineNumberExclusive, original)\n            && isValidLineNumber(this.modified.endLineNumberExclusive, modified)) {\n            return new RangeMapping(new Range(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1), new Range(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1));\n        }\n        if (!this.original.isEmpty && !this.modified.isEmpty) {\n            return new RangeMapping(Range.fromPositions(new Position(this.original.startLineNumber, 1), normalizePosition(new Position(this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), original)), Range.fromPositions(new Position(this.modified.startLineNumber, 1), normalizePosition(new Position(this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), modified)));\n        }\n        if (this.original.startLineNumber > 1 && this.modified.startLineNumber > 1) {\n            return new RangeMapping(Range.fromPositions(normalizePosition(new Position(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER), original), normalizePosition(new Position(this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), original)), Range.fromPositions(normalizePosition(new Position(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER), modified), normalizePosition(new Position(this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), modified)));\n        }\n        // Situation now: one range is empty and one range touches the last line and one range starts at line 1.\n        // I don't think this can happen.\n        throw new BugIndicatingError();\n    }\n}\nfunction normalizePosition(position, content) {\n    if (position.lineNumber < 1) {\n        return new Position(1, 1);\n    }\n    if (position.lineNumber > content.length) {\n        return new Position(content.length, content[content.length - 1].length + 1);\n    }\n    const line = content[position.lineNumber - 1];\n    if (position.column > line.length + 1) {\n        return new Position(position.lineNumber, line.length + 1);\n    }\n    return position;\n}\nfunction isValidLineNumber(lineNumber, lines) {\n    return lineNumber >= 1 && lineNumber <= lines.length;\n}\n/**\n * Maps a line range in the original text model to a line range in the modified text model.\n * Also contains inner range mappings.\n */\nexport class DetailedLineRangeMapping extends LineRangeMapping {\n    static fromRangeMappings(rangeMappings) {\n        const originalRange = LineRange.join(rangeMappings.map(r => LineRange.fromRangeInclusive(r.originalRange)));\n        const modifiedRange = LineRange.join(rangeMappings.map(r => LineRange.fromRangeInclusive(r.modifiedRange)));\n        return new DetailedLineRangeMapping(originalRange, modifiedRange, rangeMappings);\n    }\n    constructor(originalRange, modifiedRange, innerChanges) {\n        super(originalRange, modifiedRange);\n        this.innerChanges = innerChanges;\n    }\n    flip() {\n        return new DetailedLineRangeMapping(this.modified, this.original, this.innerChanges?.map(c => c.flip()));\n    }\n    withInnerChangesFromLineRanges() {\n        return new DetailedLineRangeMapping(this.original, this.modified, [this.toRangeMapping()]);\n    }\n}\n/**\n * Maps a range in the original text model to a range in the modified text model.\n */\nexport class RangeMapping {\n    static assertSorted(rangeMappings) {\n        for (let i = 1; i < rangeMappings.length; i++) {\n            const previous = rangeMappings[i - 1];\n            const current = rangeMappings[i];\n            if (!(previous.originalRange.getEndPosition().isBeforeOrEqual(current.originalRange.getStartPosition())\n                && previous.modifiedRange.getEndPosition().isBeforeOrEqual(current.modifiedRange.getStartPosition()))) {\n                throw new BugIndicatingError('Range mappings must be sorted');\n            }\n        }\n    }\n    constructor(originalRange, modifiedRange) {\n        this.originalRange = originalRange;\n        this.modifiedRange = modifiedRange;\n    }\n    toString() {\n        return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;\n    }\n    flip() {\n        return new RangeMapping(this.modifiedRange, this.originalRange);\n    }\n    /**\n     * Creates a single text edit that describes the change from the original to the modified text.\n    */\n    toTextEdit(modified) {\n        const newText = modified.getValueOfRange(this.modifiedRange);\n        return new SingleTextEdit(this.originalRange, newText);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { splitLines } from '../../../base/common/strings.js';\nimport { Position } from '../core/position.js';\nimport { PrefixSumComputer } from './prefixSumComputer.js';\nexport class MirrorTextModel {\n    constructor(uri, lines, eol, versionId) {\n        this._uri = uri;\n        this._lines = lines;\n        this._eol = eol;\n        this._versionId = versionId;\n        this._lineStarts = null;\n        this._cachedTextValue = null;\n    }\n    dispose() {\n        this._lines.length = 0;\n    }\n    get version() {\n        return this._versionId;\n    }\n    getText() {\n        if (this._cachedTextValue === null) {\n            this._cachedTextValue = this._lines.join(this._eol);\n        }\n        return this._cachedTextValue;\n    }\n    onEvents(e) {\n        if (e.eol && e.eol !== this._eol) {\n            this._eol = e.eol;\n            this._lineStarts = null;\n        }\n        // Update my lines\n        const changes = e.changes;\n        for (const change of changes) {\n            this._acceptDeleteRange(change.range);\n            this._acceptInsertText(new Position(change.range.startLineNumber, change.range.startColumn), change.text);\n        }\n        this._versionId = e.versionId;\n        this._cachedTextValue = null;\n    }\n    _ensureLineStarts() {\n        if (!this._lineStarts) {\n            const eolLength = this._eol.length;\n            const linesLength = this._lines.length;\n            const lineStartValues = new Uint32Array(linesLength);\n            for (let i = 0; i < linesLength; i++) {\n                lineStartValues[i] = this._lines[i].length + eolLength;\n            }\n            this._lineStarts = new PrefixSumComputer(lineStartValues);\n        }\n    }\n    /**\n     * All changes to a line's text go through this method\n     */\n    _setLineText(lineIndex, newValue) {\n        this._lines[lineIndex] = newValue;\n        if (this._lineStarts) {\n            // update prefix sum\n            this._lineStarts.setValue(lineIndex, this._lines[lineIndex].length + this._eol.length);\n        }\n    }\n    _acceptDeleteRange(range) {\n        if (range.startLineNumber === range.endLineNumber) {\n            if (range.startColumn === range.endColumn) {\n                // Nothing to delete\n                return;\n            }\n            // Delete text on the affected line\n            this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)\n                + this._lines[range.startLineNumber - 1].substring(range.endColumn - 1));\n            return;\n        }\n        // Take remaining text on last line and append it to remaining text on first line\n        this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)\n            + this._lines[range.endLineNumber - 1].substring(range.endColumn - 1));\n        // Delete middle lines\n        this._lines.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n        if (this._lineStarts) {\n            // update prefix sum\n            this._lineStarts.removeValues(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n        }\n    }\n    _acceptInsertText(position, insertText) {\n        if (insertText.length === 0) {\n            // Nothing to insert\n            return;\n        }\n        const insertLines = splitLines(insertText);\n        if (insertLines.length === 1) {\n            // Inserting text on one line\n            this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)\n                + insertLines[0]\n                + this._lines[position.lineNumber - 1].substring(position.column - 1));\n            return;\n        }\n        // Append overflowing text from first line to the end of text to insert\n        insertLines[insertLines.length - 1] += this._lines[position.lineNumber - 1].substring(position.column - 1);\n        // Delete overflowing text from first line and insert text on first line\n        this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)\n            + insertLines[0]);\n        // Insert new lines & store lengths\n        const newLengths = new Uint32Array(insertLines.length - 1);\n        for (let i = 1; i < insertLines.length; i++) {\n            this._lines.splice(position.lineNumber + i - 1, 0, insertLines[i]);\n            newLengths[i - 1] = insertLines[i].length + this._eol.length;\n        }\n        if (this._lineStarts) {\n            // update prefix sum\n            this._lineStarts.insertValues(position.lineNumber, newLengths);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { FindMatch, SearchData } from '../model.js';\nconst LIMIT_FIND_COUNT = 999;\nexport class SearchParams {\n    constructor(searchString, isRegex, matchCase, wordSeparators) {\n        this.searchString = searchString;\n        this.isRegex = isRegex;\n        this.matchCase = matchCase;\n        this.wordSeparators = wordSeparators;\n    }\n    parseSearchRequest() {\n        if (this.searchString === '') {\n            return null;\n        }\n        // Try to create a RegExp out of the params\n        let multiline;\n        if (this.isRegex) {\n            multiline = isMultilineRegexSource(this.searchString);\n        }\n        else {\n            multiline = (this.searchString.indexOf('\\n') >= 0);\n        }\n        let regex = null;\n        try {\n            regex = strings.createRegExp(this.searchString, this.isRegex, {\n                matchCase: this.matchCase,\n                wholeWord: false,\n                multiline: multiline,\n                global: true,\n                unicode: true\n            });\n        }\n        catch (err) {\n            return null;\n        }\n        if (!regex) {\n            return null;\n        }\n        let canUseSimpleSearch = (!this.isRegex && !multiline);\n        if (canUseSimpleSearch && this.searchString.toLowerCase() !== this.searchString.toUpperCase()) {\n            // casing might make a difference\n            canUseSimpleSearch = this.matchCase;\n        }\n        return new SearchData(regex, this.wordSeparators ? getMapForWordSeparators(this.wordSeparators, []) : null, canUseSimpleSearch ? this.searchString : null);\n    }\n}\nexport function isMultilineRegexSource(searchString) {\n    if (!searchString || searchString.length === 0) {\n        return false;\n    }\n    for (let i = 0, len = searchString.length; i < len; i++) {\n        const chCode = searchString.charCodeAt(i);\n        if (chCode === 10 /* CharCode.LineFeed */) {\n            return true;\n        }\n        if (chCode === 92 /* CharCode.Backslash */) {\n            // move to next char\n            i++;\n            if (i >= len) {\n                // string ends with a \\\n                break;\n            }\n            const nextChCode = searchString.charCodeAt(i);\n            if (nextChCode === 110 /* CharCode.n */ || nextChCode === 114 /* CharCode.r */ || nextChCode === 87 /* CharCode.W */) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nexport function createFindMatch(range, rawMatches, captureMatches) {\n    if (!captureMatches) {\n        return new FindMatch(range, null);\n    }\n    const matches = [];\n    for (let i = 0, len = rawMatches.length; i < len; i++) {\n        matches[i] = rawMatches[i];\n    }\n    return new FindMatch(range, matches);\n}\nclass LineFeedCounter {\n    constructor(text) {\n        const lineFeedsOffsets = [];\n        let lineFeedsOffsetsLen = 0;\n        for (let i = 0, textLen = text.length; i < textLen; i++) {\n            if (text.charCodeAt(i) === 10 /* CharCode.LineFeed */) {\n                lineFeedsOffsets[lineFeedsOffsetsLen++] = i;\n            }\n        }\n        this._lineFeedsOffsets = lineFeedsOffsets;\n    }\n    findLineFeedCountBeforeOffset(offset) {\n        const lineFeedsOffsets = this._lineFeedsOffsets;\n        let min = 0;\n        let max = lineFeedsOffsets.length - 1;\n        if (max === -1) {\n            // no line feeds\n            return 0;\n        }\n        if (offset <= lineFeedsOffsets[0]) {\n            // before first line feed\n            return 0;\n        }\n        while (min < max) {\n            const mid = min + ((max - min) / 2 >> 0);\n            if (lineFeedsOffsets[mid] >= offset) {\n                max = mid - 1;\n            }\n            else {\n                if (lineFeedsOffsets[mid + 1] >= offset) {\n                    // bingo!\n                    min = mid;\n                    max = mid;\n                }\n                else {\n                    min = mid + 1;\n                }\n            }\n        }\n        return min + 1;\n    }\n}\nexport class TextModelSearch {\n    static findMatches(model, searchParams, searchRange, captureMatches, limitResultCount) {\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return [];\n        }\n        if (searchData.regex.multiline) {\n            return this._doFindMatchesMultiline(model, searchRange, new Searcher(searchData.wordSeparators, searchData.regex), captureMatches, limitResultCount);\n        }\n        return this._doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount);\n    }\n    /**\n     * Multiline search always executes on the lines concatenated with \\n.\n     * We must therefore compensate for the count of \\n in case the model is CRLF\n     */\n    static _getMultilineMatchRange(model, deltaOffset, text, lfCounter, matchIndex, match0) {\n        let startOffset;\n        let lineFeedCountBeforeMatch = 0;\n        if (lfCounter) {\n            lineFeedCountBeforeMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex);\n            startOffset = deltaOffset + matchIndex + lineFeedCountBeforeMatch /* add as many \\r as there were \\n */;\n        }\n        else {\n            startOffset = deltaOffset + matchIndex;\n        }\n        let endOffset;\n        if (lfCounter) {\n            const lineFeedCountBeforeEndOfMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex + match0.length);\n            const lineFeedCountInMatch = lineFeedCountBeforeEndOfMatch - lineFeedCountBeforeMatch;\n            endOffset = startOffset + match0.length + lineFeedCountInMatch /* add as many \\r as there were \\n */;\n        }\n        else {\n            endOffset = startOffset + match0.length;\n        }\n        const startPosition = model.getPositionAt(startOffset);\n        const endPosition = model.getPositionAt(endOffset);\n        return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n    }\n    static _doFindMatchesMultiline(model, searchRange, searcher, captureMatches, limitResultCount) {\n        const deltaOffset = model.getOffsetAt(searchRange.getStartPosition());\n        // We always execute multiline search over the lines joined with \\n\n        // This makes it that \\n will match the EOL for both CRLF and LF models\n        // We compensate for offset errors in `_getMultilineMatchRange`\n        const text = model.getValueInRange(searchRange, 1 /* EndOfLinePreference.LF */);\n        const lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\n        const result = [];\n        let counter = 0;\n        let m;\n        searcher.reset(0);\n        while ((m = searcher.next(text))) {\n            result[counter++] = createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n            if (counter >= limitResultCount) {\n                return result;\n            }\n        }\n        return result;\n    }\n    static _doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount) {\n        const result = [];\n        let resultLen = 0;\n        // Early case for a search range that starts & stops on the same line number\n        if (searchRange.startLineNumber === searchRange.endLineNumber) {\n            const text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n            return result;\n        }\n        // Collect results from first line\n        const text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1);\n        resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n        // Collect results from middle lines\n        for (let lineNumber = searchRange.startLineNumber + 1; lineNumber < searchRange.endLineNumber && resultLen < limitResultCount; lineNumber++) {\n            resultLen = this._findMatchesInLine(searchData, model.getLineContent(lineNumber), lineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n        }\n        // Collect results from last line\n        if (resultLen < limitResultCount) {\n            const text = model.getLineContent(searchRange.endLineNumber).substring(0, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, text, searchRange.endLineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n        }\n        return result;\n    }\n    static _findMatchesInLine(searchData, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n        const wordSeparators = searchData.wordSeparators;\n        if (!captureMatches && searchData.simpleSearch) {\n            const searchString = searchData.simpleSearch;\n            const searchStringLen = searchString.length;\n            const textLength = text.length;\n            let lastMatchIndex = -searchStringLen;\n            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n                    result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n                    if (resultLen >= limitResultCount) {\n                        return resultLen;\n                    }\n                }\n            }\n            return resultLen;\n        }\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        let m;\n        // Reset regex to search from the beginning\n        searcher.reset(0);\n        do {\n            m = searcher.next(text);\n            if (m) {\n                result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    static findNextMatch(model, searchParams, searchStart, captureMatches) {\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return null;\n        }\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        if (searchData.regex.multiline) {\n            return this._doFindNextMatchMultiline(model, searchStart, searcher, captureMatches);\n        }\n        return this._doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches);\n    }\n    static _doFindNextMatchMultiline(model, searchStart, searcher, captureMatches) {\n        const searchTextStart = new Position(searchStart.lineNumber, 1);\n        const deltaOffset = model.getOffsetAt(searchTextStart);\n        const lineCount = model.getLineCount();\n        // We always execute multiline search over the lines joined with \\n\n        // This makes it that \\n will match the EOL for both CRLF and LF models\n        // We compensate for offset errors in `_getMultilineMatchRange`\n        const text = model.getValueInRange(new Range(searchTextStart.lineNumber, searchTextStart.column, lineCount, model.getLineMaxColumn(lineCount)), 1 /* EndOfLinePreference.LF */);\n        const lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\n        searcher.reset(searchStart.column - 1);\n        const m = searcher.next(text);\n        if (m) {\n            return createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n        }\n        if (searchStart.lineNumber !== 1 || searchStart.column !== 1) {\n            // Try again from the top\n            return this._doFindNextMatchMultiline(model, new Position(1, 1), searcher, captureMatches);\n        }\n        return null;\n    }\n    static _doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches) {\n        const lineCount = model.getLineCount();\n        const startLineNumber = searchStart.lineNumber;\n        // Look in first line\n        const text = model.getLineContent(startLineNumber);\n        const r = this._findFirstMatchInLine(searcher, text, startLineNumber, searchStart.column, captureMatches);\n        if (r) {\n            return r;\n        }\n        for (let i = 1; i <= lineCount; i++) {\n            const lineIndex = (startLineNumber + i - 1) % lineCount;\n            const text = model.getLineContent(lineIndex + 1);\n            const r = this._findFirstMatchInLine(searcher, text, lineIndex + 1, 1, captureMatches);\n            if (r) {\n                return r;\n            }\n        }\n        return null;\n    }\n    static _findFirstMatchInLine(searcher, text, lineNumber, fromColumn, captureMatches) {\n        // Set regex to search from column\n        searcher.reset(fromColumn - 1);\n        const m = searcher.next(text);\n        if (m) {\n            return createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n        }\n        return null;\n    }\n    static findPreviousMatch(model, searchParams, searchStart, captureMatches) {\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return null;\n        }\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        if (searchData.regex.multiline) {\n            return this._doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches);\n        }\n        return this._doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches);\n    }\n    static _doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches) {\n        const matches = this._doFindMatchesMultiline(model, new Range(1, 1, searchStart.lineNumber, searchStart.column), searcher, captureMatches, 10 * LIMIT_FIND_COUNT);\n        if (matches.length > 0) {\n            return matches[matches.length - 1];\n        }\n        const lineCount = model.getLineCount();\n        if (searchStart.lineNumber !== lineCount || searchStart.column !== model.getLineMaxColumn(lineCount)) {\n            // Try again with all content\n            return this._doFindPreviousMatchMultiline(model, new Position(lineCount, model.getLineMaxColumn(lineCount)), searcher, captureMatches);\n        }\n        return null;\n    }\n    static _doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches) {\n        const lineCount = model.getLineCount();\n        const startLineNumber = searchStart.lineNumber;\n        // Look in first line\n        const text = model.getLineContent(startLineNumber).substring(0, searchStart.column - 1);\n        const r = this._findLastMatchInLine(searcher, text, startLineNumber, captureMatches);\n        if (r) {\n            return r;\n        }\n        for (let i = 1; i <= lineCount; i++) {\n            const lineIndex = (lineCount + startLineNumber - i - 1) % lineCount;\n            const text = model.getLineContent(lineIndex + 1);\n            const r = this._findLastMatchInLine(searcher, text, lineIndex + 1, captureMatches);\n            if (r) {\n                return r;\n            }\n        }\n        return null;\n    }\n    static _findLastMatchInLine(searcher, text, lineNumber, captureMatches) {\n        let bestResult = null;\n        let m;\n        searcher.reset(0);\n        while ((m = searcher.next(text))) {\n            bestResult = createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n        }\n        return bestResult;\n    }\n}\nfunction leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n    if (matchStartIndex === 0) {\n        // Match starts at start of string\n        return true;\n    }\n    const charBefore = text.charCodeAt(matchStartIndex - 1);\n    if (wordSeparators.get(charBefore) !== 0 /* WordCharacterClass.Regular */) {\n        // The character before the match is a word separator\n        return true;\n    }\n    if (charBefore === 13 /* CharCode.CarriageReturn */ || charBefore === 10 /* CharCode.LineFeed */) {\n        // The character before the match is line break or carriage return.\n        return true;\n    }\n    if (matchLength > 0) {\n        const firstCharInMatch = text.charCodeAt(matchStartIndex);\n        if (wordSeparators.get(firstCharInMatch) !== 0 /* WordCharacterClass.Regular */) {\n            // The first character inside the match is a word separator\n            return true;\n        }\n    }\n    return false;\n}\nfunction rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n    if (matchStartIndex + matchLength === textLength) {\n        // Match ends at end of string\n        return true;\n    }\n    const charAfter = text.charCodeAt(matchStartIndex + matchLength);\n    if (wordSeparators.get(charAfter) !== 0 /* WordCharacterClass.Regular */) {\n        // The character after the match is a word separator\n        return true;\n    }\n    if (charAfter === 13 /* CharCode.CarriageReturn */ || charAfter === 10 /* CharCode.LineFeed */) {\n        // The character after the match is line break or carriage return.\n        return true;\n    }\n    if (matchLength > 0) {\n        const lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);\n        if (wordSeparators.get(lastCharInMatch) !== 0 /* WordCharacterClass.Regular */) {\n            // The last character in the match is a word separator\n            return true;\n        }\n    }\n    return false;\n}\nexport function isValidMatch(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n    return (leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength)\n        && rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength));\n}\nexport class Searcher {\n    constructor(wordSeparators, searchRegex) {\n        this._wordSeparators = wordSeparators;\n        this._searchRegex = searchRegex;\n        this._prevMatchStartIndex = -1;\n        this._prevMatchLength = 0;\n    }\n    reset(lastIndex) {\n        this._searchRegex.lastIndex = lastIndex;\n        this._prevMatchStartIndex = -1;\n        this._prevMatchLength = 0;\n    }\n    next(text) {\n        const textLength = text.length;\n        let m;\n        do {\n            if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {\n                // Reached the end of the line\n                return null;\n            }\n            m = this._searchRegex.exec(text);\n            if (!m) {\n                return null;\n            }\n            const matchStartIndex = m.index;\n            const matchLength = m[0].length;\n            if (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {\n                if (matchLength === 0) {\n                    // the search result is an empty string and won't advance `regex.lastIndex`, so `regex.exec` will stuck here\n                    // we attempt to recover from that by advancing by two if surrogate pair found and by one otherwise\n                    if (strings.getNextCodePoint(text, textLength, this._searchRegex.lastIndex) > 0xFFFF) {\n                        this._searchRegex.lastIndex += 2;\n                    }\n                    else {\n                        this._searchRegex.lastIndex += 1;\n                    }\n                    continue;\n                }\n                // Exit early if the regex matches the same range twice\n                return null;\n            }\n            this._prevMatchStartIndex = matchStartIndex;\n            this._prevMatchLength = matchLength;\n            if (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {\n                return m;\n            }\n        } while (m);\n        return null;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CharacterClassifier } from '../core/characterClassifier.js';\nclass Uint8Matrix {\n    constructor(rows, cols, defaultValue) {\n        const data = new Uint8Array(rows * cols);\n        for (let i = 0, len = rows * cols; i < len; i++) {\n            data[i] = defaultValue;\n        }\n        this._data = data;\n        this.rows = rows;\n        this.cols = cols;\n    }\n    get(row, col) {\n        return this._data[row * this.cols + col];\n    }\n    set(row, col, value) {\n        this._data[row * this.cols + col] = value;\n    }\n}\nexport class StateMachine {\n    constructor(edges) {\n        let maxCharCode = 0;\n        let maxState = 0 /* State.Invalid */;\n        for (let i = 0, len = edges.length; i < len; i++) {\n            const [from, chCode, to] = edges[i];\n            if (chCode > maxCharCode) {\n                maxCharCode = chCode;\n            }\n            if (from > maxState) {\n                maxState = from;\n            }\n            if (to > maxState) {\n                maxState = to;\n            }\n        }\n        maxCharCode++;\n        maxState++;\n        const states = new Uint8Matrix(maxState, maxCharCode, 0 /* State.Invalid */);\n        for (let i = 0, len = edges.length; i < len; i++) {\n            const [from, chCode, to] = edges[i];\n            states.set(from, chCode, to);\n        }\n        this._states = states;\n        this._maxCharCode = maxCharCode;\n    }\n    nextState(currentState, chCode) {\n        if (chCode < 0 || chCode >= this._maxCharCode) {\n            return 0 /* State.Invalid */;\n        }\n        return this._states.get(currentState, chCode);\n    }\n}\n// State machine for http:// or https:// or file://\nlet _stateMachine = null;\nfunction getStateMachine() {\n    if (_stateMachine === null) {\n        _stateMachine = new StateMachine([\n            [1 /* State.Start */, 104 /* CharCode.h */, 2 /* State.H */],\n            [1 /* State.Start */, 72 /* CharCode.H */, 2 /* State.H */],\n            [1 /* State.Start */, 102 /* CharCode.f */, 6 /* State.F */],\n            [1 /* State.Start */, 70 /* CharCode.F */, 6 /* State.F */],\n            [2 /* State.H */, 116 /* CharCode.t */, 3 /* State.HT */],\n            [2 /* State.H */, 84 /* CharCode.T */, 3 /* State.HT */],\n            [3 /* State.HT */, 116 /* CharCode.t */, 4 /* State.HTT */],\n            [3 /* State.HT */, 84 /* CharCode.T */, 4 /* State.HTT */],\n            [4 /* State.HTT */, 112 /* CharCode.p */, 5 /* State.HTTP */],\n            [4 /* State.HTT */, 80 /* CharCode.P */, 5 /* State.HTTP */],\n            [5 /* State.HTTP */, 115 /* CharCode.s */, 9 /* State.BeforeColon */],\n            [5 /* State.HTTP */, 83 /* CharCode.S */, 9 /* State.BeforeColon */],\n            [5 /* State.HTTP */, 58 /* CharCode.Colon */, 10 /* State.AfterColon */],\n            [6 /* State.F */, 105 /* CharCode.i */, 7 /* State.FI */],\n            [6 /* State.F */, 73 /* CharCode.I */, 7 /* State.FI */],\n            [7 /* State.FI */, 108 /* CharCode.l */, 8 /* State.FIL */],\n            [7 /* State.FI */, 76 /* CharCode.L */, 8 /* State.FIL */],\n            [8 /* State.FIL */, 101 /* CharCode.e */, 9 /* State.BeforeColon */],\n            [8 /* State.FIL */, 69 /* CharCode.E */, 9 /* State.BeforeColon */],\n            [9 /* State.BeforeColon */, 58 /* CharCode.Colon */, 10 /* State.AfterColon */],\n            [10 /* State.AfterColon */, 47 /* CharCode.Slash */, 11 /* State.AlmostThere */],\n            [11 /* State.AlmostThere */, 47 /* CharCode.Slash */, 12 /* State.End */],\n        ]);\n    }\n    return _stateMachine;\n}\nlet _classifier = null;\nfunction getClassifier() {\n    if (_classifier === null) {\n        _classifier = new CharacterClassifier(0 /* CharacterClass.None */);\n        // allow-any-unicode-next-line\n        const FORCE_TERMINATION_CHARACTERS = ' \\t<>\\'\\\"';\n        for (let i = 0; i < FORCE_TERMINATION_CHARACTERS.length; i++) {\n            _classifier.set(FORCE_TERMINATION_CHARACTERS.charCodeAt(i), 1 /* CharacterClass.ForceTermination */);\n        }\n        const CANNOT_END_WITH_CHARACTERS = '.,;:';\n        for (let i = 0; i < CANNOT_END_WITH_CHARACTERS.length; i++) {\n            _classifier.set(CANNOT_END_WITH_CHARACTERS.charCodeAt(i), 2 /* CharacterClass.CannotEndIn */);\n        }\n    }\n    return _classifier;\n}\nexport class LinkComputer {\n    static _createLink(classifier, line, lineNumber, linkBeginIndex, linkEndIndex) {\n        // Do not allow to end link in certain characters...\n        let lastIncludedCharIndex = linkEndIndex - 1;\n        do {\n            const chCode = line.charCodeAt(lastIncludedCharIndex);\n            const chClass = classifier.get(chCode);\n            if (chClass !== 2 /* CharacterClass.CannotEndIn */) {\n                break;\n            }\n            lastIncludedCharIndex--;\n        } while (lastIncludedCharIndex > linkBeginIndex);\n        // Handle links enclosed in parens, square brackets and curlys.\n        if (linkBeginIndex > 0) {\n            const charCodeBeforeLink = line.charCodeAt(linkBeginIndex - 1);\n            const lastCharCodeInLink = line.charCodeAt(lastIncludedCharIndex);\n            if ((charCodeBeforeLink === 40 /* CharCode.OpenParen */ && lastCharCodeInLink === 41 /* CharCode.CloseParen */)\n                || (charCodeBeforeLink === 91 /* CharCode.OpenSquareBracket */ && lastCharCodeInLink === 93 /* CharCode.CloseSquareBracket */)\n                || (charCodeBeforeLink === 123 /* CharCode.OpenCurlyBrace */ && lastCharCodeInLink === 125 /* CharCode.CloseCurlyBrace */)) {\n                // Do not end in ) if ( is before the link start\n                // Do not end in ] if [ is before the link start\n                // Do not end in } if { is before the link start\n                lastIncludedCharIndex--;\n            }\n        }\n        return {\n            range: {\n                startLineNumber: lineNumber,\n                startColumn: linkBeginIndex + 1,\n                endLineNumber: lineNumber,\n                endColumn: lastIncludedCharIndex + 2\n            },\n            url: line.substring(linkBeginIndex, lastIncludedCharIndex + 1)\n        };\n    }\n    static computeLinks(model, stateMachine = getStateMachine()) {\n        const classifier = getClassifier();\n        const result = [];\n        for (let i = 1, lineCount = model.getLineCount(); i <= lineCount; i++) {\n            const line = model.getLineContent(i);\n            const len = line.length;\n            let j = 0;\n            let linkBeginIndex = 0;\n            let linkBeginChCode = 0;\n            let state = 1 /* State.Start */;\n            let hasOpenParens = false;\n            let hasOpenSquareBracket = false;\n            let inSquareBrackets = false;\n            let hasOpenCurlyBracket = false;\n            while (j < len) {\n                let resetStateMachine = false;\n                const chCode = line.charCodeAt(j);\n                if (state === 13 /* State.Accept */) {\n                    let chClass;\n                    switch (chCode) {\n                        case 40 /* CharCode.OpenParen */:\n                            hasOpenParens = true;\n                            chClass = 0 /* CharacterClass.None */;\n                            break;\n                        case 41 /* CharCode.CloseParen */:\n                            chClass = (hasOpenParens ? 0 /* CharacterClass.None */ : 1 /* CharacterClass.ForceTermination */);\n                            break;\n                        case 91 /* CharCode.OpenSquareBracket */:\n                            inSquareBrackets = true;\n                            hasOpenSquareBracket = true;\n                            chClass = 0 /* CharacterClass.None */;\n                            break;\n                        case 93 /* CharCode.CloseSquareBracket */:\n                            inSquareBrackets = false;\n                            chClass = (hasOpenSquareBracket ? 0 /* CharacterClass.None */ : 1 /* CharacterClass.ForceTermination */);\n                            break;\n                        case 123 /* CharCode.OpenCurlyBrace */:\n                            hasOpenCurlyBracket = true;\n                            chClass = 0 /* CharacterClass.None */;\n                            break;\n                        case 125 /* CharCode.CloseCurlyBrace */:\n                            chClass = (hasOpenCurlyBracket ? 0 /* CharacterClass.None */ : 1 /* CharacterClass.ForceTermination */);\n                            break;\n                        // The following three rules make it that ' or \" or ` are allowed inside links\n                        // only if the link is wrapped by some other quote character\n                        case 39 /* CharCode.SingleQuote */:\n                        case 34 /* CharCode.DoubleQuote */:\n                        case 96 /* CharCode.BackTick */:\n                            if (linkBeginChCode === chCode) {\n                                chClass = 1 /* CharacterClass.ForceTermination */;\n                            }\n                            else if (linkBeginChCode === 39 /* CharCode.SingleQuote */ || linkBeginChCode === 34 /* CharCode.DoubleQuote */ || linkBeginChCode === 96 /* CharCode.BackTick */) {\n                                chClass = 0 /* CharacterClass.None */;\n                            }\n                            else {\n                                chClass = 1 /* CharacterClass.ForceTermination */;\n                            }\n                            break;\n                        case 42 /* CharCode.Asterisk */:\n                            // `*` terminates a link if the link began with `*`\n                            chClass = (linkBeginChCode === 42 /* CharCode.Asterisk */) ? 1 /* CharacterClass.ForceTermination */ : 0 /* CharacterClass.None */;\n                            break;\n                        case 124 /* CharCode.Pipe */:\n                            // `|` terminates a link if the link began with `|`\n                            chClass = (linkBeginChCode === 124 /* CharCode.Pipe */) ? 1 /* CharacterClass.ForceTermination */ : 0 /* CharacterClass.None */;\n                            break;\n                        case 32 /* CharCode.Space */:\n                            // ` ` allow space in between [ and ]\n                            chClass = (inSquareBrackets ? 0 /* CharacterClass.None */ : 1 /* CharacterClass.ForceTermination */);\n                            break;\n                        default:\n                            chClass = classifier.get(chCode);\n                    }\n                    // Check if character terminates link\n                    if (chClass === 1 /* CharacterClass.ForceTermination */) {\n                        result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, j));\n                        resetStateMachine = true;\n                    }\n                }\n                else if (state === 12 /* State.End */) {\n                    let chClass;\n                    if (chCode === 91 /* CharCode.OpenSquareBracket */) {\n                        // Allow for the authority part to contain ipv6 addresses which contain [ and ]\n                        hasOpenSquareBracket = true;\n                        chClass = 0 /* CharacterClass.None */;\n                    }\n                    else {\n                        chClass = classifier.get(chCode);\n                    }\n                    // Check if character terminates link\n                    if (chClass === 1 /* CharacterClass.ForceTermination */) {\n                        resetStateMachine = true;\n                    }\n                    else {\n                        state = 13 /* State.Accept */;\n                    }\n                }\n                else {\n                    state = stateMachine.nextState(state, chCode);\n                    if (state === 0 /* State.Invalid */) {\n                        resetStateMachine = true;\n                    }\n                }\n                if (resetStateMachine) {\n                    state = 1 /* State.Start */;\n                    hasOpenParens = false;\n                    hasOpenSquareBracket = false;\n                    hasOpenCurlyBracket = false;\n                    // Record where the link started\n                    linkBeginIndex = j + 1;\n                    linkBeginChCode = chCode;\n                }\n                j++;\n            }\n            if (state === 13 /* State.Accept */) {\n                result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, len));\n            }\n        }\n        return result;\n    }\n}\n/**\n * Returns an array of all links contains in the provided\n * document. *Note* that this operation is computational\n * expensive and should not run in the UI thread.\n */\nexport function computeLinks(model) {\n    if (!model || typeof model.getLineCount !== 'function' || typeof model.getLineContent !== 'function') {\n        // Unknown caller!\n        return [];\n    }\n    return LinkComputer.computeLinks(model);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class BasicInplaceReplace {\n    constructor() {\n        this._defaultValueSet = [\n            ['true', 'false'],\n            ['True', 'False'],\n            ['Private', 'Public', 'Friend', 'ReadOnly', 'Partial', 'Protected', 'WriteOnly'],\n            ['public', 'protected', 'private'],\n        ];\n    }\n    static { this.INSTANCE = new BasicInplaceReplace(); }\n    navigateValueSet(range1, text1, range2, text2, up) {\n        if (range1 && text1) {\n            const result = this.doNavigateValueSet(text1, up);\n            if (result) {\n                return {\n                    range: range1,\n                    value: result\n                };\n            }\n        }\n        if (range2 && text2) {\n            const result = this.doNavigateValueSet(text2, up);\n            if (result) {\n                return {\n                    range: range2,\n                    value: result\n                };\n            }\n        }\n        return null;\n    }\n    doNavigateValueSet(text, up) {\n        const numberResult = this.numberReplace(text, up);\n        if (numberResult !== null) {\n            return numberResult;\n        }\n        return this.textReplace(text, up);\n    }\n    numberReplace(value, up) {\n        const precision = Math.pow(10, value.length - (value.lastIndexOf('.') + 1));\n        let n1 = Number(value);\n        const n2 = parseFloat(value);\n        if (!isNaN(n1) && !isNaN(n2) && n1 === n2) {\n            if (n1 === 0 && !up) {\n                return null; // don't do negative\n                //\t\t\t} else if(n1 === 9 && up) {\n                //\t\t\t\treturn null; // don't insert 10 into a number\n            }\n            else {\n                n1 = Math.floor(n1 * precision);\n                n1 += up ? precision : -precision;\n                return String(n1 / precision);\n            }\n        }\n        return null;\n    }\n    textReplace(value, up) {\n        return this.valueSetsReplace(this._defaultValueSet, value, up);\n    }\n    valueSetsReplace(valueSets, value, up) {\n        let result = null;\n        for (let i = 0, len = valueSets.length; result === null && i < len; i++) {\n            result = this.valueSetReplace(valueSets[i], value, up);\n        }\n        return result;\n    }\n    valueSetReplace(valueSet, value, up) {\n        let idx = valueSet.indexOf(value);\n        if (idx >= 0) {\n            idx += up ? +1 : -1;\n            if (idx < 0) {\n                idx = valueSet.length - 1;\n            }\n            else {\n                idx %= valueSet.length;\n            }\n            return valueSet[idx];\n        }\n        return null;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LcsDiff } from '../../../base/common/diff/diff.js';\nimport { LinesDiff } from './linesDiffComputer.js';\nimport { RangeMapping, DetailedLineRangeMapping } from './rangeMapping.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { Range } from '../core/range.js';\nimport { assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { LineRange } from '../core/lineRange.js';\nconst MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\nexport class LegacyLinesDiffComputer {\n    computeDiff(originalLines, modifiedLines, options) {\n        const diffComputer = new DiffComputer(originalLines, modifiedLines, {\n            maxComputationTime: options.maxComputationTimeMs,\n            shouldIgnoreTrimWhitespace: options.ignoreTrimWhitespace,\n            shouldComputeCharChanges: true,\n            shouldMakePrettyDiff: true,\n            shouldPostProcessCharChanges: true,\n        });\n        const result = diffComputer.computeDiff();\n        const changes = [];\n        let lastChange = null;\n        for (const c of result.changes) {\n            let originalRange;\n            if (c.originalEndLineNumber === 0) {\n                // Insertion\n                originalRange = new LineRange(c.originalStartLineNumber + 1, c.originalStartLineNumber + 1);\n            }\n            else {\n                originalRange = new LineRange(c.originalStartLineNumber, c.originalEndLineNumber + 1);\n            }\n            let modifiedRange;\n            if (c.modifiedEndLineNumber === 0) {\n                // Deletion\n                modifiedRange = new LineRange(c.modifiedStartLineNumber + 1, c.modifiedStartLineNumber + 1);\n            }\n            else {\n                modifiedRange = new LineRange(c.modifiedStartLineNumber, c.modifiedEndLineNumber + 1);\n            }\n            let change = new DetailedLineRangeMapping(originalRange, modifiedRange, c.charChanges?.map(c => new RangeMapping(new Range(c.originalStartLineNumber, c.originalStartColumn, c.originalEndLineNumber, c.originalEndColumn), new Range(c.modifiedStartLineNumber, c.modifiedStartColumn, c.modifiedEndLineNumber, c.modifiedEndColumn))));\n            if (lastChange) {\n                if (lastChange.modified.endLineNumberExclusive === change.modified.startLineNumber\n                    || lastChange.original.endLineNumberExclusive === change.original.startLineNumber) {\n                    // join touching diffs. Probably moving diffs up/down in the algorithm causes touching diffs.\n                    change = new DetailedLineRangeMapping(lastChange.original.join(change.original), lastChange.modified.join(change.modified), lastChange.innerChanges && change.innerChanges ?\n                        lastChange.innerChanges.concat(change.innerChanges) : undefined);\n                    changes.pop();\n                }\n            }\n            changes.push(change);\n            lastChange = change;\n        }\n        assertFn(() => {\n            return checkAdjacentItems(changes, (m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive &&\n                // There has to be an unchanged line in between (otherwise both diffs should have been joined)\n                m1.original.endLineNumberExclusive < m2.original.startLineNumber &&\n                m1.modified.endLineNumberExclusive < m2.modified.startLineNumber);\n        });\n        return new LinesDiff(changes, [], result.quitEarly);\n    }\n}\nfunction computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {\n    const diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);\n    return diffAlgo.ComputeDiff(pretty);\n}\nclass LineSequence {\n    constructor(lines) {\n        const startColumns = [];\n        const endColumns = [];\n        for (let i = 0, length = lines.length; i < length; i++) {\n            startColumns[i] = getFirstNonBlankColumn(lines[i], 1);\n            endColumns[i] = getLastNonBlankColumn(lines[i], 1);\n        }\n        this.lines = lines;\n        this._startColumns = startColumns;\n        this._endColumns = endColumns;\n    }\n    getElements() {\n        const elements = [];\n        for (let i = 0, len = this.lines.length; i < len; i++) {\n            elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);\n        }\n        return elements;\n    }\n    getStrictElement(index) {\n        return this.lines[index];\n    }\n    getStartLineNumber(i) {\n        return i + 1;\n    }\n    getEndLineNumber(i) {\n        return i + 1;\n    }\n    createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {\n        const charCodes = [];\n        const lineNumbers = [];\n        const columns = [];\n        let len = 0;\n        for (let index = startIndex; index <= endIndex; index++) {\n            const lineContent = this.lines[index];\n            const startColumn = (shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1);\n            const endColumn = (shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1);\n            for (let col = startColumn; col < endColumn; col++) {\n                charCodes[len] = lineContent.charCodeAt(col - 1);\n                lineNumbers[len] = index + 1;\n                columns[len] = col;\n                len++;\n            }\n            if (!shouldIgnoreTrimWhitespace && index < endIndex) {\n                // Add \\n if trim whitespace is not ignored\n                charCodes[len] = 10 /* CharCode.LineFeed */;\n                lineNumbers[len] = index + 1;\n                columns[len] = lineContent.length + 1;\n                len++;\n            }\n        }\n        return new CharSequence(charCodes, lineNumbers, columns);\n    }\n}\nclass CharSequence {\n    constructor(charCodes, lineNumbers, columns) {\n        this._charCodes = charCodes;\n        this._lineNumbers = lineNumbers;\n        this._columns = columns;\n    }\n    toString() {\n        return ('[' + this._charCodes.map((s, idx) => (s === 10 /* CharCode.LineFeed */ ? '\\\\n' : String.fromCharCode(s)) + `-(${this._lineNumbers[idx]},${this._columns[idx]})`).join(', ') + ']');\n    }\n    _assertIndex(index, arr) {\n        if (index < 0 || index >= arr.length) {\n            throw new Error(`Illegal index`);\n        }\n    }\n    getElements() {\n        return this._charCodes;\n    }\n    getStartLineNumber(i) {\n        if (i > 0 && i === this._lineNumbers.length) {\n            // the start line number of the element after the last element\n            // is the end line number of the last element\n            return this.getEndLineNumber(i - 1);\n        }\n        this._assertIndex(i, this._lineNumbers);\n        return this._lineNumbers[i];\n    }\n    getEndLineNumber(i) {\n        if (i === -1) {\n            // the end line number of the element before the first element\n            // is the start line number of the first element\n            return this.getStartLineNumber(i + 1);\n        }\n        this._assertIndex(i, this._lineNumbers);\n        if (this._charCodes[i] === 10 /* CharCode.LineFeed */) {\n            return this._lineNumbers[i] + 1;\n        }\n        return this._lineNumbers[i];\n    }\n    getStartColumn(i) {\n        if (i > 0 && i === this._columns.length) {\n            // the start column of the element after the last element\n            // is the end column of the last element\n            return this.getEndColumn(i - 1);\n        }\n        this._assertIndex(i, this._columns);\n        return this._columns[i];\n    }\n    getEndColumn(i) {\n        if (i === -1) {\n            // the end column of the element before the first element\n            // is the start column of the first element\n            return this.getStartColumn(i + 1);\n        }\n        this._assertIndex(i, this._columns);\n        if (this._charCodes[i] === 10 /* CharCode.LineFeed */) {\n            return 1;\n        }\n        return this._columns[i] + 1;\n    }\n}\nclass CharChange {\n    constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalStartColumn = originalStartColumn;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.originalEndColumn = originalEndColumn;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedStartColumn = modifiedStartColumn;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.modifiedEndColumn = modifiedEndColumn;\n    }\n    static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {\n        const originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\n        const originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\n        const originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n        const originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\n        const modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\n        const modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\n        const modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        const modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        return new CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);\n    }\n}\nfunction postProcessCharChanges(rawChanges) {\n    if (rawChanges.length <= 1) {\n        return rawChanges;\n    }\n    const result = [rawChanges[0]];\n    let prevChange = result[0];\n    for (let i = 1, len = rawChanges.length; i < len; i++) {\n        const currChange = rawChanges[i];\n        const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\n        const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);\n        // Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true\n        const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\n        if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {\n            // Merge the current change into the previous one\n            prevChange.originalLength = (currChange.originalStart + currChange.originalLength) - prevChange.originalStart;\n            prevChange.modifiedLength = (currChange.modifiedStart + currChange.modifiedLength) - prevChange.modifiedStart;\n        }\n        else {\n            // Add the current change\n            result.push(currChange);\n            prevChange = currChange;\n        }\n    }\n    return result;\n}\nclass LineChange {\n    constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.charChanges = charChanges;\n    }\n    static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {\n        let originalStartLineNumber;\n        let originalEndLineNumber;\n        let modifiedStartLineNumber;\n        let modifiedEndLineNumber;\n        let charChanges = undefined;\n        if (diffChange.originalLength === 0) {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\n            originalEndLineNumber = 0;\n        }\n        else {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\n            originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n        }\n        if (diffChange.modifiedLength === 0) {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\n            modifiedEndLineNumber = 0;\n        }\n        else {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\n            modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        }\n        if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {\n            // Compute character changes for diff chunks of at most 20 lines...\n            const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\n            const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\n            if (originalCharSequence.getElements().length > 0 && modifiedCharSequence.getElements().length > 0) {\n                let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;\n                if (shouldPostProcessCharChanges) {\n                    rawChanges = postProcessCharChanges(rawChanges);\n                }\n                charChanges = [];\n                for (let i = 0, length = rawChanges.length; i < length; i++) {\n                    charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\n                }\n            }\n        }\n        return new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);\n    }\n}\nexport class DiffComputer {\n    constructor(originalLines, modifiedLines, opts) {\n        this.shouldComputeCharChanges = opts.shouldComputeCharChanges;\n        this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\n        this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\n        this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;\n        this.originalLines = originalLines;\n        this.modifiedLines = modifiedLines;\n        this.original = new LineSequence(originalLines);\n        this.modified = new LineSequence(modifiedLines);\n        this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);\n        this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5000)); // never run after 5s for character changes...\n    }\n    computeDiff() {\n        if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {\n            // empty original => fast path\n            if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n                return {\n                    quitEarly: false,\n                    changes: []\n                };\n            }\n            return {\n                quitEarly: false,\n                changes: [{\n                        originalStartLineNumber: 1,\n                        originalEndLineNumber: 1,\n                        modifiedStartLineNumber: 1,\n                        modifiedEndLineNumber: this.modified.lines.length,\n                        charChanges: undefined\n                    }]\n            };\n        }\n        if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n            // empty modified => fast path\n            return {\n                quitEarly: false,\n                changes: [{\n                        originalStartLineNumber: 1,\n                        originalEndLineNumber: this.original.lines.length,\n                        modifiedStartLineNumber: 1,\n                        modifiedEndLineNumber: 1,\n                        charChanges: undefined\n                    }]\n            };\n        }\n        const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);\n        const rawChanges = diffResult.changes;\n        const quitEarly = diffResult.quitEarly;\n        // The diff is always computed with ignoring trim whitespace\n        // This ensures we get the prettiest diff\n        if (this.shouldIgnoreTrimWhitespace) {\n            const lineChanges = [];\n            for (let i = 0, length = rawChanges.length; i < length; i++) {\n                lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n            }\n            return {\n                quitEarly: quitEarly,\n                changes: lineChanges\n            };\n        }\n        // Need to post-process and introduce changes where the trim whitespace is different\n        // Note that we are looping starting at -1 to also cover the lines before the first change\n        const result = [];\n        let originalLineIndex = 0;\n        let modifiedLineIndex = 0;\n        for (let i = -1 /* !!!! */, len = rawChanges.length; i < len; i++) {\n            const nextChange = (i + 1 < len ? rawChanges[i + 1] : null);\n            const originalStop = (nextChange ? nextChange.originalStart : this.originalLines.length);\n            const modifiedStop = (nextChange ? nextChange.modifiedStart : this.modifiedLines.length);\n            while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {\n                const originalLine = this.originalLines[originalLineIndex];\n                const modifiedLine = this.modifiedLines[modifiedLineIndex];\n                if (originalLine !== modifiedLine) {\n                    // These lines differ only in trim whitespace\n                    // Check the leading whitespace\n                    {\n                        let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);\n                        let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);\n                        while (originalStartColumn > 1 && modifiedStartColumn > 1) {\n                            const originalChar = originalLine.charCodeAt(originalStartColumn - 2);\n                            const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalStartColumn--;\n                            modifiedStartColumn--;\n                        }\n                        if (originalStartColumn > 1 || modifiedStartColumn > 1) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);\n                        }\n                    }\n                    // Check the trailing whitespace\n                    {\n                        let originalEndColumn = getLastNonBlankColumn(originalLine, 1);\n                        let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);\n                        const originalMaxColumn = originalLine.length + 1;\n                        const modifiedMaxColumn = modifiedLine.length + 1;\n                        while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {\n                            const originalChar = originalLine.charCodeAt(originalEndColumn - 1);\n                            const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalEndColumn++;\n                            modifiedEndColumn++;\n                        }\n                        if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);\n                        }\n                    }\n                }\n                originalLineIndex++;\n                modifiedLineIndex++;\n            }\n            if (nextChange) {\n                // Emit the actual change\n                result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n                originalLineIndex += nextChange.originalLength;\n                modifiedLineIndex += nextChange.modifiedLength;\n            }\n        }\n        return {\n            quitEarly: quitEarly,\n            changes: result\n        };\n    }\n    _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {\n            // Merged into previous\n            return;\n        }\n        let charChanges = undefined;\n        if (this.shouldComputeCharChanges) {\n            charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];\n        }\n        result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));\n    }\n    _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        const len = result.length;\n        if (len === 0) {\n            return false;\n        }\n        const prevChange = result[len - 1];\n        if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {\n            // Don't merge with inserts/deletes\n            return false;\n        }\n        if (prevChange.originalEndLineNumber === originalLineNumber && prevChange.modifiedEndLineNumber === modifiedLineNumber) {\n            if (this.shouldComputeCharChanges && prevChange.charChanges) {\n                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n            }\n            return true;\n        }\n        if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {\n            prevChange.originalEndLineNumber = originalLineNumber;\n            prevChange.modifiedEndLineNumber = modifiedLineNumber;\n            if (this.shouldComputeCharChanges && prevChange.charChanges) {\n                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n            }\n            return true;\n        }\n        return false;\n    }\n}\nfunction getFirstNonBlankColumn(txt, defaultValue) {\n    const r = strings.firstNonWhitespaceIndex(txt);\n    if (r === -1) {\n        return defaultValue;\n    }\n    return r + 1;\n}\nfunction getLastNonBlankColumn(txt, defaultValue) {\n    const r = strings.lastNonWhitespaceIndex(txt);\n    if (r === -1) {\n        return defaultValue;\n    }\n    return r + 2;\n}\nfunction createContinueProcessingPredicate(maximumRuntime) {\n    if (maximumRuntime === 0) {\n        return () => true;\n    }\n    const startTime = Date.now();\n    return () => {\n        return Date.now() - startTime < maximumRuntime;\n    };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LegacyLinesDiffComputer } from './legacyLinesDiffComputer.js';\nimport { DefaultLinesDiffComputer } from './defaultLinesDiffComputer/defaultLinesDiffComputer.js';\nexport const linesDiffComputers = {\n    getLegacy: () => new LegacyLinesDiffComputer(),\n    getDefault: () => new DefaultLinesDiffComputer(),\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Color, HSLA } from '../../../base/common/color.js';\nfunction _parseCaptureGroups(captureGroups) {\n    const values = [];\n    for (const captureGroup of captureGroups) {\n        const parsedNumber = Number(captureGroup);\n        if (parsedNumber || parsedNumber === 0 && captureGroup.replace(/\\s/g, '') !== '') {\n            values.push(parsedNumber);\n        }\n    }\n    return values;\n}\nfunction _toIColor(r, g, b, a) {\n    return {\n        red: r / 255,\n        blue: b / 255,\n        green: g / 255,\n        alpha: a\n    };\n}\nfunction _findRange(model, match) {\n    const index = match.index;\n    const length = match[0].length;\n    if (!index) {\n        return;\n    }\n    const startPosition = model.positionAt(index);\n    const range = {\n        startLineNumber: startPosition.lineNumber,\n        startColumn: startPosition.column,\n        endLineNumber: startPosition.lineNumber,\n        endColumn: startPosition.column + length\n    };\n    return range;\n}\nfunction _findHexColorInformation(range, hexValue) {\n    if (!range) {\n        return;\n    }\n    const parsedHexColor = Color.Format.CSS.parseHex(hexValue);\n    if (!parsedHexColor) {\n        return;\n    }\n    return {\n        range: range,\n        color: _toIColor(parsedHexColor.rgba.r, parsedHexColor.rgba.g, parsedHexColor.rgba.b, parsedHexColor.rgba.a)\n    };\n}\nfunction _findRGBColorInformation(range, matches, isAlpha) {\n    if (!range || matches.length !== 1) {\n        return;\n    }\n    const match = matches[0];\n    const captureGroups = match.values();\n    const parsedRegex = _parseCaptureGroups(captureGroups);\n    return {\n        range: range,\n        color: _toIColor(parsedRegex[0], parsedRegex[1], parsedRegex[2], isAlpha ? parsedRegex[3] : 1)\n    };\n}\nfunction _findHSLColorInformation(range, matches, isAlpha) {\n    if (!range || matches.length !== 1) {\n        return;\n    }\n    const match = matches[0];\n    const captureGroups = match.values();\n    const parsedRegex = _parseCaptureGroups(captureGroups);\n    const colorEquivalent = new Color(new HSLA(parsedRegex[0], parsedRegex[1] / 100, parsedRegex[2] / 100, isAlpha ? parsedRegex[3] : 1));\n    return {\n        range: range,\n        color: _toIColor(colorEquivalent.rgba.r, colorEquivalent.rgba.g, colorEquivalent.rgba.b, colorEquivalent.rgba.a)\n    };\n}\nfunction _findMatches(model, regex) {\n    if (typeof model === 'string') {\n        return [...model.matchAll(regex)];\n    }\n    else {\n        return model.findMatches(regex);\n    }\n}\nfunction computeColors(model) {\n    const result = [];\n    // Early validation for RGB and HSL\n    const initialValidationRegex = /\\b(rgb|rgba|hsl|hsla)(\\([0-9\\s,.\\%]*\\))|(#)([A-Fa-f0-9]{3})\\b|(#)([A-Fa-f0-9]{4})\\b|(#)([A-Fa-f0-9]{6})\\b|(#)([A-Fa-f0-9]{8})\\b/gm;\n    const initialValidationMatches = _findMatches(model, initialValidationRegex);\n    // Potential colors have been found, validate the parameters\n    if (initialValidationMatches.length > 0) {\n        for (const initialMatch of initialValidationMatches) {\n            const initialCaptureGroups = initialMatch.filter(captureGroup => captureGroup !== undefined);\n            const colorScheme = initialCaptureGroups[1];\n            const colorParameters = initialCaptureGroups[2];\n            if (!colorParameters) {\n                continue;\n            }\n            let colorInformation;\n            if (colorScheme === 'rgb') {\n                const regexParameters = /^\\(\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*\\)$/gm;\n                colorInformation = _findRGBColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), false);\n            }\n            else if (colorScheme === 'rgba') {\n                const regexParameters = /^\\(\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\\s*\\)$/gm;\n                colorInformation = _findRGBColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), true);\n            }\n            else if (colorScheme === 'hsl') {\n                const regexParameters = /^\\(\\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\\s*,\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*,\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*\\)$/gm;\n                colorInformation = _findHSLColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), false);\n            }\n            else if (colorScheme === 'hsla') {\n                const regexParameters = /^\\(\\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\\s*,\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*,\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*,\\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\\s*\\)$/gm;\n                colorInformation = _findHSLColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), true);\n            }\n            else if (colorScheme === '#') {\n                colorInformation = _findHexColorInformation(_findRange(model, initialMatch), colorScheme + colorParameters);\n            }\n            if (colorInformation) {\n                result.push(colorInformation);\n            }\n        }\n    }\n    return result;\n}\n/**\n * Returns an array of all default document colors in the provided document\n */\nexport function computeDefaultDocumentColors(model) {\n    if (!model || typeof model.getValue !== 'function' || typeof model.positionAt !== 'function') {\n        // Unknown caller!\n        return [];\n    }\n    return computeColors(model);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { stringDiff } from '../../../base/common/diff/diff.js';\nimport { Range } from '../core/range.js';\nimport { computeLinks } from '../languages/linkComputer.js';\nimport { BasicInplaceReplace } from '../languages/supports/inplaceReplaceSupport.js';\nimport { createMonacoBaseAPI } from './editorBaseApi.js';\nimport { EditorWorkerHost } from './editorWorkerHost.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { UnicodeTextModelHighlighter } from './unicodeTextModelHighlighter.js';\nimport { linesDiffComputers } from '../diff/linesDiffComputers.js';\nimport { createProxyObject, getAllMethodNames } from '../../../base/common/objects.js';\nimport { FileAccess } from '../../../base/common/network.js';\nimport { computeDefaultDocumentColors } from '../languages/defaultDocumentColorsComputer.js';\nimport { findSectionHeaders } from './findSectionHeaders.js';\nimport { WorkerTextModelSyncServer } from './textModelSync/textModelSync.impl.js';\n// ESM-comment-begin\n// const isESM = false;\n// ESM-comment-end\n// ESM-uncomment-begin\nconst isESM = true;\n/**\n * @internal\n */\nexport class BaseEditorSimpleWorker {\n    constructor() {\n        this._workerTextModelSyncServer = new WorkerTextModelSyncServer();\n    }\n    dispose() {\n    }\n    _getModel(uri) {\n        return this._workerTextModelSyncServer.getModel(uri);\n    }\n    _getModels() {\n        return this._workerTextModelSyncServer.getModels();\n    }\n    $acceptNewModel(data) {\n        this._workerTextModelSyncServer.$acceptNewModel(data);\n    }\n    $acceptModelChanged(uri, e) {\n        this._workerTextModelSyncServer.$acceptModelChanged(uri, e);\n    }\n    $acceptRemovedModel(uri) {\n        this._workerTextModelSyncServer.$acceptRemovedModel(uri);\n    }\n    async $computeUnicodeHighlights(url, options, range) {\n        const model = this._getModel(url);\n        if (!model) {\n            return { ranges: [], hasMore: false, ambiguousCharacterCount: 0, invisibleCharacterCount: 0, nonBasicAsciiCharacterCount: 0 };\n        }\n        return UnicodeTextModelHighlighter.computeUnicodeHighlights(model, options, range);\n    }\n    async $findSectionHeaders(url, options) {\n        const model = this._getModel(url);\n        if (!model) {\n            return [];\n        }\n        return findSectionHeaders(model, options);\n    }\n    // ---- BEGIN diff --------------------------------------------------------------------------\n    async $computeDiff(originalUrl, modifiedUrl, options, algorithm) {\n        const original = this._getModel(originalUrl);\n        const modified = this._getModel(modifiedUrl);\n        if (!original || !modified) {\n            return null;\n        }\n        const result = EditorSimpleWorker.computeDiff(original, modified, options, algorithm);\n        return result;\n    }\n    static computeDiff(originalTextModel, modifiedTextModel, options, algorithm) {\n        const diffAlgorithm = algorithm === 'advanced' ? linesDiffComputers.getDefault() : linesDiffComputers.getLegacy();\n        const originalLines = originalTextModel.getLinesContent();\n        const modifiedLines = modifiedTextModel.getLinesContent();\n        const result = diffAlgorithm.computeDiff(originalLines, modifiedLines, options);\n        const identical = (result.changes.length > 0 ? false : this._modelsAreIdentical(originalTextModel, modifiedTextModel));\n        function getLineChanges(changes) {\n            return changes.map(m => ([m.original.startLineNumber, m.original.endLineNumberExclusive, m.modified.startLineNumber, m.modified.endLineNumberExclusive, m.innerChanges?.map(m => [\n                    m.originalRange.startLineNumber,\n                    m.originalRange.startColumn,\n                    m.originalRange.endLineNumber,\n                    m.originalRange.endColumn,\n                    m.modifiedRange.startLineNumber,\n                    m.modifiedRange.startColumn,\n                    m.modifiedRange.endLineNumber,\n                    m.modifiedRange.endColumn,\n                ])]));\n        }\n        return {\n            identical,\n            quitEarly: result.hitTimeout,\n            changes: getLineChanges(result.changes),\n            moves: result.moves.map(m => ([\n                m.lineRangeMapping.original.startLineNumber,\n                m.lineRangeMapping.original.endLineNumberExclusive,\n                m.lineRangeMapping.modified.startLineNumber,\n                m.lineRangeMapping.modified.endLineNumberExclusive,\n                getLineChanges(m.changes)\n            ])),\n        };\n    }\n    static _modelsAreIdentical(original, modified) {\n        const originalLineCount = original.getLineCount();\n        const modifiedLineCount = modified.getLineCount();\n        if (originalLineCount !== modifiedLineCount) {\n            return false;\n        }\n        for (let line = 1; line <= originalLineCount; line++) {\n            const originalLine = original.getLineContent(line);\n            const modifiedLine = modified.getLineContent(line);\n            if (originalLine !== modifiedLine) {\n                return false;\n            }\n        }\n        return true;\n    }\n    // ---- END diff --------------------------------------------------------------------------\n    // ---- BEGIN minimal edits ---------------------------------------------------------------\n    static { this._diffLimit = 100000; }\n    async $computeMoreMinimalEdits(modelUrl, edits, pretty) {\n        const model = this._getModel(modelUrl);\n        if (!model) {\n            return edits;\n        }\n        const result = [];\n        let lastEol = undefined;\n        edits = edits.slice(0).sort((a, b) => {\n            if (a.range && b.range) {\n                return Range.compareRangesUsingStarts(a.range, b.range);\n            }\n            // eol only changes should go to the end\n            const aRng = a.range ? 0 : 1;\n            const bRng = b.range ? 0 : 1;\n            return aRng - bRng;\n        });\n        // merge adjacent edits\n        let writeIndex = 0;\n        for (let readIndex = 1; readIndex < edits.length; readIndex++) {\n            if (Range.getEndPosition(edits[writeIndex].range).equals(Range.getStartPosition(edits[readIndex].range))) {\n                edits[writeIndex].range = Range.fromPositions(Range.getStartPosition(edits[writeIndex].range), Range.getEndPosition(edits[readIndex].range));\n                edits[writeIndex].text += edits[readIndex].text;\n            }\n            else {\n                writeIndex++;\n                edits[writeIndex] = edits[readIndex];\n            }\n        }\n        edits.length = writeIndex + 1;\n        for (let { range, text, eol } of edits) {\n            if (typeof eol === 'number') {\n                lastEol = eol;\n            }\n            if (Range.isEmpty(range) && !text) {\n                // empty change\n                continue;\n            }\n            const original = model.getValueInRange(range);\n            text = text.replace(/\\r\\n|\\n|\\r/g, model.eol);\n            if (original === text) {\n                // noop\n                continue;\n            }\n            // make sure diff won't take too long\n            if (Math.max(text.length, original.length) > EditorSimpleWorker._diffLimit) {\n                result.push({ range, text });\n                continue;\n            }\n            // compute diff between original and edit.text\n            const changes = stringDiff(original, text, pretty);\n            const editOffset = model.offsetAt(Range.lift(range).getStartPosition());\n            for (const change of changes) {\n                const start = model.positionAt(editOffset + change.originalStart);\n                const end = model.positionAt(editOffset + change.originalStart + change.originalLength);\n                const newEdit = {\n                    text: text.substr(change.modifiedStart, change.modifiedLength),\n                    range: { startLineNumber: start.lineNumber, startColumn: start.column, endLineNumber: end.lineNumber, endColumn: end.column }\n                };\n                if (model.getValueInRange(newEdit.range) !== newEdit.text) {\n                    result.push(newEdit);\n                }\n            }\n        }\n        if (typeof lastEol === 'number') {\n            result.push({ eol: lastEol, text: '', range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } });\n        }\n        return result;\n    }\n    // ---- END minimal edits ---------------------------------------------------------------\n    async $computeLinks(modelUrl) {\n        const model = this._getModel(modelUrl);\n        if (!model) {\n            return null;\n        }\n        return computeLinks(model);\n    }\n    // --- BEGIN default document colors -----------------------------------------------------------\n    async $computeDefaultDocumentColors(modelUrl) {\n        const model = this._getModel(modelUrl);\n        if (!model) {\n            return null;\n        }\n        return computeDefaultDocumentColors(model);\n    }\n    // ---- BEGIN suggest --------------------------------------------------------------------------\n    static { this._suggestionsLimit = 10000; }\n    async $textualSuggest(modelUrls, leadingWord, wordDef, wordDefFlags) {\n        const sw = new StopWatch();\n        const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n        const seen = new Set();\n        outer: for (const url of modelUrls) {\n            const model = this._getModel(url);\n            if (!model) {\n                continue;\n            }\n            for (const word of model.words(wordDefRegExp)) {\n                if (word === leadingWord || !isNaN(Number(word))) {\n                    continue;\n                }\n                seen.add(word);\n                if (seen.size > EditorSimpleWorker._suggestionsLimit) {\n                    break outer;\n                }\n            }\n        }\n        return { words: Array.from(seen), duration: sw.elapsed() };\n    }\n    // ---- END suggest --------------------------------------------------------------------------\n    //#region -- word ranges --\n    async $computeWordRanges(modelUrl, range, wordDef, wordDefFlags) {\n        const model = this._getModel(modelUrl);\n        if (!model) {\n            return Object.create(null);\n        }\n        const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n        const result = Object.create(null);\n        for (let line = range.startLineNumber; line < range.endLineNumber; line++) {\n            const words = model.getLineWords(line, wordDefRegExp);\n            for (const word of words) {\n                if (!isNaN(Number(word.word))) {\n                    continue;\n                }\n                let array = result[word.word];\n                if (!array) {\n                    array = [];\n                    result[word.word] = array;\n                }\n                array.push({\n                    startLineNumber: line,\n                    startColumn: word.startColumn,\n                    endLineNumber: line,\n                    endColumn: word.endColumn\n                });\n            }\n        }\n        return result;\n    }\n    //#endregion\n    async $navigateValueSet(modelUrl, range, up, wordDef, wordDefFlags) {\n        const model = this._getModel(modelUrl);\n        if (!model) {\n            return null;\n        }\n        const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n        if (range.startColumn === range.endColumn) {\n            range = {\n                startLineNumber: range.startLineNumber,\n                startColumn: range.startColumn,\n                endLineNumber: range.endLineNumber,\n                endColumn: range.endColumn + 1\n            };\n        }\n        const selectionText = model.getValueInRange(range);\n        const wordRange = model.getWordAtPosition({ lineNumber: range.startLineNumber, column: range.startColumn }, wordDefRegExp);\n        if (!wordRange) {\n            return null;\n        }\n        const word = model.getValueInRange(wordRange);\n        const result = BasicInplaceReplace.INSTANCE.navigateValueSet(range, selectionText, wordRange, word, up);\n        return result;\n    }\n}\n/**\n * @internal\n */\nexport class EditorSimpleWorker extends BaseEditorSimpleWorker {\n    constructor(_host, _foreignModuleFactory) {\n        super();\n        this._host = _host;\n        this._foreignModuleFactory = _foreignModuleFactory;\n        this._foreignModule = null;\n    }\n    async $ping() {\n        return 'pong';\n    }\n    // ---- BEGIN foreign module support --------------------------------------------------------------------------\n    $loadForeignModule(moduleId, createData, foreignHostMethods) {\n        const proxyMethodRequest = (method, args) => {\n            return this._host.$fhr(method, args);\n        };\n        const foreignHost = createProxyObject(foreignHostMethods, proxyMethodRequest);\n        const ctx = {\n            host: foreignHost,\n            getMirrorModels: () => {\n                return this._getModels();\n            }\n        };\n        if (this._foreignModuleFactory) {\n            this._foreignModule = this._foreignModuleFactory(ctx, createData);\n            // static foreing module\n            return Promise.resolve(getAllMethodNames(this._foreignModule));\n        }\n        return new Promise((resolve, reject) => {\n            const onModuleCallback = (foreignModule) => {\n                this._foreignModule = foreignModule.create(ctx, createData);\n                resolve(getAllMethodNames(this._foreignModule));\n            };\n            if (!isESM) {\n                require([`${moduleId}`], onModuleCallback, reject);\n            }\n            else {\n                const url = FileAccess.asBrowserUri(`${moduleId}.js`).toString(true);\n                import(`${url}`).then(onModuleCallback).catch(reject);\n            }\n        });\n    }\n    // foreign method request\n    $fmr(method, args) {\n        if (!this._foreignModule || typeof this._foreignModule[method] !== 'function') {\n            return Promise.reject(new Error('Missing requestHandler or method: ' + method));\n        }\n        try {\n            return Promise.resolve(this._foreignModule[method].apply(this._foreignModule, args));\n        }\n        catch (e) {\n            return Promise.reject(e);\n        }\n    }\n}\n/**\n * Defines the worker entry point. Must be exported and named `create`.\n * @skipMangle\n * @internal\n */\nexport function create(workerServer) {\n    return new EditorSimpleWorker(EditorWorkerHost.getChannel(workerServer), null);\n}\nif (typeof importScripts === 'function') {\n    // Running in a web worker\n    globalThis.monaco = createMonacoBaseAPI();\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class EditorWorkerHost {\n    static { this.CHANNEL_NAME = 'editorWorkerHost'; }\n    static getChannel(workerServer) {\n        return workerServer.getChannel(EditorWorkerHost.CHANNEL_NAME);\n    }\n    static setChannel(workerClient, obj) {\n        workerClient.setChannel(EditorWorkerHost.CHANNEL_NAME, obj);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst markRegex = new RegExp('\\\\bMARK:\\\\s*(.*)$', 'd');\nconst trimDashesRegex = /^-+|-+$/g;\n/**\n * Find section headers in the model.\n *\n * @param model the text model to search in\n * @param options options to search with\n * @returns an array of section headers\n */\nexport function findSectionHeaders(model, options) {\n    let headers = [];\n    if (options.findRegionSectionHeaders && options.foldingRules?.markers) {\n        const regionHeaders = collectRegionHeaders(model, options);\n        headers = headers.concat(regionHeaders);\n    }\n    if (options.findMarkSectionHeaders) {\n        const markHeaders = collectMarkHeaders(model);\n        headers = headers.concat(markHeaders);\n    }\n    return headers;\n}\nfunction collectRegionHeaders(model, options) {\n    const regionHeaders = [];\n    const endLineNumber = model.getLineCount();\n    for (let lineNumber = 1; lineNumber <= endLineNumber; lineNumber++) {\n        const lineContent = model.getLineContent(lineNumber);\n        const match = lineContent.match(options.foldingRules.markers.start);\n        if (match) {\n            const range = { startLineNumber: lineNumber, startColumn: match[0].length + 1, endLineNumber: lineNumber, endColumn: lineContent.length + 1 };\n            if (range.endColumn > range.startColumn) {\n                const sectionHeader = {\n                    range,\n                    ...getHeaderText(lineContent.substring(match[0].length)),\n                    shouldBeInComments: false\n                };\n                if (sectionHeader.text || sectionHeader.hasSeparatorLine) {\n                    regionHeaders.push(sectionHeader);\n                }\n            }\n        }\n    }\n    return regionHeaders;\n}\nfunction collectMarkHeaders(model) {\n    const markHeaders = [];\n    const endLineNumber = model.getLineCount();\n    for (let lineNumber = 1; lineNumber <= endLineNumber; lineNumber++) {\n        const lineContent = model.getLineContent(lineNumber);\n        addMarkHeaderIfFound(lineContent, lineNumber, markHeaders);\n    }\n    return markHeaders;\n}\nfunction addMarkHeaderIfFound(lineContent, lineNumber, sectionHeaders) {\n    markRegex.lastIndex = 0;\n    const match = markRegex.exec(lineContent);\n    if (match) {\n        const column = match.indices[1][0] + 1;\n        const endColumn = match.indices[1][1] + 1;\n        const range = { startLineNumber: lineNumber, startColumn: column, endLineNumber: lineNumber, endColumn: endColumn };\n        if (range.endColumn > range.startColumn) {\n            const sectionHeader = {\n                range,\n                ...getHeaderText(match[1]),\n                shouldBeInComments: true\n            };\n            if (sectionHeader.text || sectionHeader.hasSeparatorLine) {\n                sectionHeaders.push(sectionHeader);\n            }\n        }\n    }\n}\nfunction getHeaderText(text) {\n    text = text.trim();\n    const hasSeparatorLine = text.startsWith('-');\n    text = text.replace(trimDashesRegex, '');\n    return { text, hasSeparatorLine };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../core/range.js';\nimport { Searcher } from '../model/textModelSearch.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { assertNever } from '../../../base/common/assert.js';\nimport { DEFAULT_WORD_REGEXP, getWordAtText } from '../core/wordHelper.js';\nexport class UnicodeTextModelHighlighter {\n    static computeUnicodeHighlights(model, options, range) {\n        const startLine = range ? range.startLineNumber : 1;\n        const endLine = range ? range.endLineNumber : model.getLineCount();\n        const codePointHighlighter = new CodePointHighlighter(options);\n        const candidates = codePointHighlighter.getCandidateCodePoints();\n        let regex;\n        if (candidates === 'allNonBasicAscii') {\n            regex = new RegExp('[^\\\\t\\\\n\\\\r\\\\x20-\\\\x7E]', 'g');\n        }\n        else {\n            regex = new RegExp(`${buildRegExpCharClassExpr(Array.from(candidates))}`, 'g');\n        }\n        const searcher = new Searcher(null, regex);\n        const ranges = [];\n        let hasMore = false;\n        let m;\n        let ambiguousCharacterCount = 0;\n        let invisibleCharacterCount = 0;\n        let nonBasicAsciiCharacterCount = 0;\n        forLoop: for (let lineNumber = startLine, lineCount = endLine; lineNumber <= lineCount; lineNumber++) {\n            const lineContent = model.getLineContent(lineNumber);\n            const lineLength = lineContent.length;\n            // Reset regex to search from the beginning\n            searcher.reset(0);\n            do {\n                m = searcher.next(lineContent);\n                if (m) {\n                    let startIndex = m.index;\n                    let endIndex = m.index + m[0].length;\n                    // Extend range to entire code point\n                    if (startIndex > 0) {\n                        const charCodeBefore = lineContent.charCodeAt(startIndex - 1);\n                        if (strings.isHighSurrogate(charCodeBefore)) {\n                            startIndex--;\n                        }\n                    }\n                    if (endIndex + 1 < lineLength) {\n                        const charCodeBefore = lineContent.charCodeAt(endIndex - 1);\n                        if (strings.isHighSurrogate(charCodeBefore)) {\n                            endIndex++;\n                        }\n                    }\n                    const str = lineContent.substring(startIndex, endIndex);\n                    let word = getWordAtText(startIndex + 1, DEFAULT_WORD_REGEXP, lineContent, 0);\n                    if (word && word.endColumn <= startIndex + 1) {\n                        // The word does not include the problematic character, ignore the word\n                        word = null;\n                    }\n                    const highlightReason = codePointHighlighter.shouldHighlightNonBasicASCII(str, word ? word.word : null);\n                    if (highlightReason !== 0 /* SimpleHighlightReason.None */) {\n                        if (highlightReason === 3 /* SimpleHighlightReason.Ambiguous */) {\n                            ambiguousCharacterCount++;\n                        }\n                        else if (highlightReason === 2 /* SimpleHighlightReason.Invisible */) {\n                            invisibleCharacterCount++;\n                        }\n                        else if (highlightReason === 1 /* SimpleHighlightReason.NonBasicASCII */) {\n                            nonBasicAsciiCharacterCount++;\n                        }\n                        else {\n                            assertNever(highlightReason);\n                        }\n                        const MAX_RESULT_LENGTH = 1000;\n                        if (ranges.length >= MAX_RESULT_LENGTH) {\n                            hasMore = true;\n                            break forLoop;\n                        }\n                        ranges.push(new Range(lineNumber, startIndex + 1, lineNumber, endIndex + 1));\n                    }\n                }\n            } while (m);\n        }\n        return {\n            ranges,\n            hasMore,\n            ambiguousCharacterCount,\n            invisibleCharacterCount,\n            nonBasicAsciiCharacterCount\n        };\n    }\n    static computeUnicodeHighlightReason(char, options) {\n        const codePointHighlighter = new CodePointHighlighter(options);\n        const reason = codePointHighlighter.shouldHighlightNonBasicASCII(char, null);\n        switch (reason) {\n            case 0 /* SimpleHighlightReason.None */:\n                return null;\n            case 2 /* SimpleHighlightReason.Invisible */:\n                return { kind: 1 /* UnicodeHighlighterReasonKind.Invisible */ };\n            case 3 /* SimpleHighlightReason.Ambiguous */: {\n                const codePoint = char.codePointAt(0);\n                const primaryConfusable = codePointHighlighter.ambiguousCharacters.getPrimaryConfusable(codePoint);\n                const notAmbiguousInLocales = strings.AmbiguousCharacters.getLocales().filter((l) => !strings.AmbiguousCharacters.getInstance(new Set([...options.allowedLocales, l])).isAmbiguous(codePoint));\n                return { kind: 0 /* UnicodeHighlighterReasonKind.Ambiguous */, confusableWith: String.fromCodePoint(primaryConfusable), notAmbiguousInLocales };\n            }\n            case 1 /* SimpleHighlightReason.NonBasicASCII */:\n                return { kind: 2 /* UnicodeHighlighterReasonKind.NonBasicAscii */ };\n        }\n    }\n}\nfunction buildRegExpCharClassExpr(codePoints, flags) {\n    const src = `[${strings.escapeRegExpCharacters(codePoints.map((i) => String.fromCodePoint(i)).join(''))}]`;\n    return src;\n}\nclass CodePointHighlighter {\n    constructor(options) {\n        this.options = options;\n        this.allowedCodePoints = new Set(options.allowedCodePoints);\n        this.ambiguousCharacters = strings.AmbiguousCharacters.getInstance(new Set(options.allowedLocales));\n    }\n    getCandidateCodePoints() {\n        if (this.options.nonBasicASCII) {\n            return 'allNonBasicAscii';\n        }\n        const set = new Set();\n        if (this.options.invisibleCharacters) {\n            for (const cp of strings.InvisibleCharacters.codePoints) {\n                if (!isAllowedInvisibleCharacter(String.fromCodePoint(cp))) {\n                    set.add(cp);\n                }\n            }\n        }\n        if (this.options.ambiguousCharacters) {\n            for (const cp of this.ambiguousCharacters.getConfusableCodePoints()) {\n                set.add(cp);\n            }\n        }\n        for (const cp of this.allowedCodePoints) {\n            set.delete(cp);\n        }\n        return set;\n    }\n    shouldHighlightNonBasicASCII(character, wordContext) {\n        const codePoint = character.codePointAt(0);\n        if (this.allowedCodePoints.has(codePoint)) {\n            return 0 /* SimpleHighlightReason.None */;\n        }\n        if (this.options.nonBasicASCII) {\n            return 1 /* SimpleHighlightReason.NonBasicASCII */;\n        }\n        let hasBasicASCIICharacters = false;\n        let hasNonConfusableNonBasicAsciiCharacter = false;\n        if (wordContext) {\n            for (const char of wordContext) {\n                const codePoint = char.codePointAt(0);\n                const isBasicASCII = strings.isBasicASCII(char);\n                hasBasicASCIICharacters = hasBasicASCIICharacters || isBasicASCII;\n                if (!isBasicASCII &&\n                    !this.ambiguousCharacters.isAmbiguous(codePoint) &&\n                    !strings.InvisibleCharacters.isInvisibleCharacter(codePoint)) {\n                    hasNonConfusableNonBasicAsciiCharacter = true;\n                }\n            }\n        }\n        if (\n        /* Don't allow mixing weird looking characters with ASCII */ !hasBasicASCIICharacters &&\n            /* Is there an obviously weird looking character? */ hasNonConfusableNonBasicAsciiCharacter) {\n            return 0 /* SimpleHighlightReason.None */;\n        }\n        if (this.options.invisibleCharacters) {\n            // TODO check for emojis\n            if (!isAllowedInvisibleCharacter(character) && strings.InvisibleCharacters.isInvisibleCharacter(codePoint)) {\n                return 2 /* SimpleHighlightReason.Invisible */;\n            }\n        }\n        if (this.options.ambiguousCharacters) {\n            if (this.ambiguousCharacters.isAmbiguous(codePoint)) {\n                return 3 /* SimpleHighlightReason.Ambiguous */;\n            }\n        }\n        return 0 /* SimpleHighlightReason.None */;\n    }\n}\nfunction isAllowedInvisibleCharacter(character) {\n    return character === ' ' || character === '\\n' || character === '\\t';\n}\n"],"names":["identity","t","LRUCachedFunction","constructor","arg1","arg2","this","lastCache","undefined","lastArgKey","_fn","_computeKey","getCacheKey","get","arg","key","CachedFunction","cachedValues","_map","Map","_map2","has","value","set","DiffChange","originalStart","originalLength","modifiedStart","modifiedLength","getOriginalEnd","getModifiedEnd","Lazy","executor","_didRun","_value","err","_error","rawValue","toUint8","v","toUint32","LineRange","fromRangeInclusive","range","startLineNumber","endLineNumber","joinMany","lineRanges","length","result","LineRangeSet","slice","i","getUnion","ranges","join","BugIndicatingError","endLineNumberExclusive","Math","min","max","ofLength","deserialize","lineRange","concat","contains","lineNumber","isEmpty","delta","offset","deltaLength","other","toString","intersect","intersectsStrict","overlapOrTouch","equals","b","toInclusiveRange","Range","Number","MAX_SAFE_INTEGER","toExclusiveRange","mapToLineArray","f","push","forEach","serialize","includes","toOffsetRange","OffsetRange","_normalizedRanges","arguments","addRange","joinRangeStartIdx","findFirstIdxMonotonousOrArrLen","r","joinRangeEndIdxExclusive","findLastIdxMonotonous","splice","joinRange","rangeThatStartsBeforeEnd","findLastMonotonous","intersects","i1","i2","current","next","lineRange1","lineRange2","subtractFrom","map","getIntersection","r1","r2","getWithDelta","PositionOffsetTransformer","text","lineStartOffsetByLineIdx","charAt","getOffset","position","column","getOffsetRange","getStartPosition","getEndPosition","textLength","lineIdx","TextLength","betweenPositions","position1","position2","ofRange","ofText","line","c","lineCount","columnCount","isGreaterThanOrEqualTo","createRange","startPosition","addToPosition","Position","_TextLength","zero","DiffAlgorithmResult","trivial","seq1","seq2","SequenceDiff","trivialTimedOut","diffs","hitTimeout","invert","sequenceDiffs","doc1Length","forEachAdjacent","a","fromOffsetPairs","getEndExclusives","OffsetPair","getStarts","seq2Range","endExclusive","seq1Range","start","offset1","offset2","assertSorted","last","cur","swap","deltaStart","deltaEnd","_OffsetPair","InfiniteTimeout","isValid","_InfiniteTimeout","instance","DateTimeout","timeout","startTime","Date","now","valid","Array2D","width","height","array","Array","x","y","isSpace","charCode","LineRangeFragment","getKey","chr","chrKeys","size","lines","source","histogram","counter","j","totalCount","computeSimilarity","sumDifferences","maxLength","_this$histogram$i","_other$histogram$i","abs","DynamicProgrammingDiffing","compute","sequence1","sequence2","equalityScore","lcsLengths","directions","lengths","s1","s2","horizontalLen","verticalLen","extendedSeqScore","getElement","newValue","prevLen","lastAligningPosS1","lastAligningPosS2","reportDecreasingAligningPositions","reverse","MyersDiffAlgorithm","seqX","seqY","getXAfterSnake","d","V","FastInt32Array","paths","FastArrayNegativeIndices","SnakePath","k","loop","lowerBound","upperBound","step","maxXofDLineTop","maxXofDLineLeft","newMaxX","lastPath","path","endX","endY","prev","positiveArr","Int32Array","negativeArr","idx","arr","LinesSliceCharSequence","considerWhitespaceChanges","elements","firstElementOffsetByLineIdx","lineStartOffsets","trimmedWsLengthsByLineIdx","lineStartOffset","startColumn","substring","trimmedWsLength","trimmedStartLine","trimStart","trimEnd","lineLength","endColumn","charCodeAt","getText","e","String","fromCharCode","getBoundaryScore","prevCategory","getCategory","nextCategory","score","getCategoryBoundaryScore","translateOffset","preference","lineOffset","translateRange","pos1","pos2","isBefore","fromPositions","findWordContaining","isWordChar","end","countLinesIn","isStronglyEqual","extendToFullLines","_findLastMonotonous","_findFirstMonotonous","findFirstMonotonous","category","computeMovedLines","changes","originalLines","modifiedLines","hashedOriginalLines","hashedModifiedLines","moves","excludedChanges","deletions","filter","modified","original","insertions","Set","deletion","best","highestSimilarity","insertion","similarity","delete","LineRangeMapping","add","computeMovesFromSimpleDeletionsToSimpleInsertions","unchangedMoves","original3LineHashes","SetMap","change","possibleMappings","sort","compareBy","numberComparator","lastMappings","currentModifiedRange","nextMappings","_ref","lastMapping","originalLineRange","modifiedLineRange","mapping","reverseOrder","m","modifiedSet","originalSet","diffOrigToMod","modifiedSections","originalTranslatedSections","modifiedIntersectedSections","s","monotonousChanges","MonotonousArray","move","firstTouchingChangeOrig","firstTouchingChangeMod","linesAbove","lastTouchingChangeOrig","lastTouchingChangeMod","linesBelow","extendToTop","extendToBottom","origLine","modLine","areLinesSimilar","computeUnchangedMoves","pushMany","originalDist","modifiedDist","joinCloseConsecutiveMoves","l","trim","predicate","count","countWhere","changesMonotonous","removeMovesInSameDiff","line1","line2","commonNonSpaceCharCount","inverted","seq","longerLineLength","str","countNonWsChars","LineSequence","trimmedHash","getIndentation","DefaultLinesDiffComputer","dynamicProgrammingDiffing","myersDiffingAlgorithm","computeDiff","options","LinesDiff","DetailedLineRangeMapping","RangeMapping","maxComputationTimeMs","ignoreTrimWhitespace","perfectHashes","getOrCreateHash","hash","originalLinesHashes","modifiedLinesHashes","lineAlignmentResult","log","lineAlignments","optimizeSequenceDiffs","removeVeryShortMatchingLinesBetweenDiffs","alignments","scanForWhitespaceChanges","equalLinesCount","seq1Offset","seq1LastStart","seq2Offset","seq2LastStart","characterDiffs","refineDiff","mappings","diff","assertFn","lineRangeMappingFromRangeMappings","computeMoves","validatePosition","pos","validateRange","innerChanges","ic","modifiedRange","originalRange","MovedText","sequenceDiff","rangeMapping","toRangeMapping2","slice1","slice2","diffResult","check","extendDiffsToEntireWordIfAppropriate","removeShortMatches","removeVeryShortMatchingTextBetweenLongDiffs","dontAssertStartLine","g","groupAdjacentBy","lineStartDelta","lineEndDelta","getLineRangeMapping","a1","a2","first","checkAdjacentItems","m1","m2","joinSequenceDiffsByShifting","prevDiff","nextDiff","seq1ValidRange","seq2ValidRange","shiftDiffToBetterPosition","shiftSequenceDiffs","prevResult","result2","nextResult","deltaBefore","deltaAfter","bestDelta","bestScore","seq2OffsetStart","seq2OffsetEndExclusive","equalMappings","additional","lastPoint","scanWord","pair","equalMapping","w1","w2","w","equalPart","equalChars1","equalChars2","v1","v2","shift","sequenceDiffs1","sequenceDiffs2","sd1","sd2","mergeSequenceDiffs","_sequence2","shouldRepeat","lastResult","shouldJoinDiffs","before","after","unchangedRange","replace","unchangedText","split","beforeLineCount1","beforeSeq1Length","beforeLineCount2","beforeSeq2Length","afterLineCount1","afterSeq1Length","afterLineCount2","afterSeq2Length","cap","pow","newDiffs","forEachWithNeighbors","newDiff","shouldMarkAsChanged","fullRange1","prefix","suffix","availableSpace","lineRangeMapping","inverse","originalLineCount","modifiedLineCount","lastOriginalEndLineNumber","lastModifiedEndLineNumber","clip","flip","toRangeMapping","origInclusiveRange","modInclusiveRange","isValidLineNumber","normalizePosition","content","fromRangeMappings","rangeMappings","super","_this$innerChanges","withInnerChangesFromLineRanges","previous","isBeforeOrEqual","toTextEdit","newText","getValueOfRange","SingleTextEdit","MirrorTextModel","uri","eol","versionId","_uri","_lines","_eol","_versionId","_lineStarts","_cachedTextValue","dispose","version","onEvents","_acceptDeleteRange","_acceptInsertText","_ensureLineStarts","eolLength","linesLength","lineStartValues","Uint32Array","PrefixSumComputer","_setLineText","lineIndex","setValue","removeValues","insertText","insertLines","splitLines","newLengths","insertValues","SearchParams","searchString","isRegex","matchCase","wordSeparators","parseSearchRequest","multiline","len","chCode","nextChCode","isMultilineRegexSource","indexOf","regex","strings","wholeWord","global","unicode","canUseSimpleSearch","toLowerCase","toUpperCase","SearchData","getMapForWordSeparators","createFindMatch","rawMatches","captureMatches","FindMatch","matches","LineFeedCounter","lineFeedsOffsets","lineFeedsOffsetsLen","textLen","_lineFeedsOffsets","findLineFeedCountBeforeOffset","mid","TextModelSearch","findMatches","model","searchParams","searchRange","limitResultCount","searchData","_doFindMatchesMultiline","Searcher","_doFindMatchesLineByLine","_getMultilineMatchRange","deltaOffset","lfCounter","matchIndex","match0","startOffset","endOffset","lineFeedCountBeforeMatch","lineFeedCountInMatch","getPositionAt","endPosition","searcher","getOffsetAt","getValueInRange","getEOL","reset","index","resultLen","getLineContent","_findMatchesInLine","simpleSearch","searchStringLen","lastMatchIndex","isValidMatch","findNextMatch","searchStart","_doFindNextMatchMultiline","_doFindNextMatchLineByLine","searchTextStart","getLineCount","getLineMaxColumn","_findFirstMatchInLine","fromColumn","findPreviousMatch","_doFindPreviousMatchMultiline","_doFindPreviousMatchLineByLine","_findLastMatchInLine","bestResult","matchStartIndex","matchLength","charBefore","firstCharInMatch","leftIsWordBounday","charAfter","lastCharInMatch","rightIsWordBounday","searchRegex","_wordSeparators","_searchRegex","_prevMatchStartIndex","_prevMatchLength","lastIndex","exec","Uint8Matrix","rows","cols","defaultValue","data","Uint8Array","_data","row","col","StateMachine","edges","maxCharCode","maxState","from","to","states","_states","_maxCharCode","nextState","currentState","_stateMachine","_classifier","LinkComputer","_createLink","classifier","linkBeginIndex","linkEndIndex","lastIncludedCharIndex","charCodeBeforeLink","lastCharCodeInLink","url","computeLinks","stateMachine","CharacterClassifier","FORCE_TERMINATION_CHARACTERS","CANNOT_END_WITH_CHARACTERS","getClassifier","linkBeginChCode","state","hasOpenParens","hasOpenSquareBracket","inSquareBrackets","hasOpenCurlyBracket","resetStateMachine","chClass","BasicInplaceReplace","_defaultValueSet","navigateValueSet","range1","text1","range2","text2","up","doNavigateValueSet","numberResult","numberReplace","textReplace","precision","lastIndexOf","n1","n2","parseFloat","isNaN","floor","valueSetsReplace","valueSets","valueSetReplace","valueSet","_BasicInplaceReplace","INSTANCE","LegacyLinesDiffComputer","DiffComputer","maxComputationTime","shouldIgnoreTrimWhitespace","shouldComputeCharChanges","shouldMakePrettyDiff","shouldPostProcessCharChanges","lastChange","_c$charChanges","originalEndLineNumber","originalStartLineNumber","modifiedEndLineNumber","modifiedStartLineNumber","charChanges","originalStartColumn","originalEndColumn","modifiedStartColumn","modifiedEndColumn","pop","quitEarly","originalSequence","modifiedSequence","continueProcessingPredicate","pretty","LcsDiff","ComputeDiff","startColumns","endColumns","getFirstNonBlankColumn","getLastNonBlankColumn","_startColumns","_endColumns","getElements","getStrictElement","getStartLineNumber","getEndLineNumber","createCharSequence","startIndex","endIndex","charCodes","lineNumbers","columns","lineContent","CharSequence","_charCodes","_lineNumbers","_columns","_assertIndex","Error","getStartColumn","getEndColumn","CharChange","createFromDiffChange","diffChange","originalCharSequence","modifiedCharSequence","LineChange","createFromDiffResult","originalLineSequence","modifiedLineSequence","continueCharDiff","rawChanges","prevChange","currChange","originalMatchingLength","modifiedMatchingLength","postProcessCharChanges","opts","continueLineDiff","createContinueProcessingPredicate","lineChanges","originalLineIndex","modifiedLineIndex","nextChange","originalStop","modifiedStop","originalLine","modifiedLine","_pushTrimWhitespaceCharChange","originalMaxColumn","modifiedMaxColumn","originalLineNumber","modifiedLineNumber","_mergeTrimWhitespaceCharChange","txt","maximumRuntime","linesDiffComputers","getLegacy","getDefault","_parseCaptureGroups","captureGroups","values","captureGroup","parsedNumber","_toIColor","red","blue","green","alpha","_findRange","match","positionAt","_findHexColorInformation","hexValue","parsedHexColor","Color","Format","CSS","parseHex","color","rgba","_findRGBColorInformation","isAlpha","parsedRegex","_findHSLColorInformation","colorEquivalent","HSLA","_findMatches","matchAll","computeDefaultDocumentColors","getValue","initialValidationMatches","initialMatch","initialCaptureGroups","colorScheme","colorParameters","colorInformation","regexParameters","computeColors","BaseEditorSimpleWorker","_workerTextModelSyncServer","WorkerTextModelSyncServer","_getModel","getModel","_getModels","getModels","$acceptNewModel","$acceptModelChanged","$acceptRemovedModel","$computeUnicodeHighlights","UnicodeTextModelHighlighter","computeUnicodeHighlights","hasMore","ambiguousCharacterCount","invisibleCharacterCount","nonBasicAsciiCharacterCount","$findSectionHeaders","findSectionHeaders","$computeDiff","originalUrl","modifiedUrl","algorithm","EditorSimpleWorker","originalTextModel","modifiedTextModel","diffAlgorithm","getLinesContent","getLineChanges","_m$innerChanges","identical","_modelsAreIdentical","$computeMoreMinimalEdits","modelUrl","edits","lastEol","compareRangesUsingStarts","writeIndex","readIndex","_diffLimit","stringDiff","editOffset","offsetAt","lift","newEdit","substr","$computeLinks","$computeDefaultDocumentColors","$textualSuggest","modelUrls","leadingWord","wordDef","wordDefFlags","sw","StopWatch","wordDefRegExp","RegExp","seen","outer","word","words","_suggestionsLimit","duration","elapsed","$computeWordRanges","Object","create","getLineWords","$navigateValueSet","selectionText","wordRange","getWordAtPosition","_BaseEditorSimpleWorker","_host","_foreignModuleFactory","_foreignModule","$ping","$loadForeignModule","moduleId","createData","foreignHostMethods","ctx","host","createProxyObject","proxyMethodRequest","method","args","$fhr","getMirrorModels","Promise","resolve","getAllMethodNames","reject","onModuleCallback","foreignModule","FileAccess","asBrowserUri","then","catch","$fmr","apply","workerServer","EditorWorkerHost","getChannel","importScripts","globalThis","monaco","createMonacoBaseAPI","CHANNEL_NAME","setChannel","workerClient","obj","markRegex","trimDashesRegex","_options$foldingRules","headers","findRegionSectionHeaders","foldingRules","markers","regionHeaders","sectionHeader","_objectSpread","getHeaderText","shouldBeInComments","hasSeparatorLine","collectRegionHeaders","findMarkSectionHeaders","markHeaders","addMarkHeaderIfFound","collectMarkHeaders","sectionHeaders","indices","startsWith","startLine","endLine","codePointHighlighter","CodePointHighlighter","candidates","getCandidateCodePoints","codePoints","fromCodePoint","forLoop","charCodeBefore","getWordAtText","DEFAULT_WORD_REGEXP","highlightReason","shouldHighlightNonBasicASCII","assertNever","MAX_RESULT_LENGTH","computeUnicodeHighlightReason","char","kind","codePoint","codePointAt","primaryConfusable","ambiguousCharacters","getPrimaryConfusable","notAmbiguousInLocales","getLocales","getInstance","allowedLocales","isAmbiguous","confusableWith","allowedCodePoints","nonBasicASCII","invisibleCharacters","cp","isAllowedInvisibleCharacter","getConfusableCodePoints","character","wordContext","hasBasicASCIICharacters","hasNonConfusableNonBasicAsciiCharacter","isBasicASCII","isInvisibleCharacter"],"sourceRoot":""}